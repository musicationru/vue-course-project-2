"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
      options2[k] = true;
      return options2;
    }, {});
    module2.exports = parseOptions;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse2 = (version, options) => {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse2;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse2 = require_parse();
    var valid = (version, options) => {
      const v = parse2(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse2 = require_parse();
    var clean = (version, options) => {
      const s = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse2 = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse2(version1);
        const v2 = parse2(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse2 = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node2;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node2(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node2(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node2(value, prev, next, list) {
      if (!(this instanceof Node2)) {
        return new Node2(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// ../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/range.js"(exports2, module2) {
    var Range3 = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range3) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range3(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = /* @__PURE__ */ new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range3)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range3;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range3(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range3(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range3 = require_range();
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range3 = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range3(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range3 = require_range();
    var toComparators = (range, options) => new Range3(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range3 = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range3(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range3 = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range3(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range3 = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range3(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range3 = require_range();
    var validRange = (range, options) => {
      try {
        return new Range3(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range3 = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range3(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range3 = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range3(r1, options);
      r2 = new Range3(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!min)
            min = version;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range3 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom)
        return true;
      sub = new Range3(sub, options);
      dom = new Range3(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// ../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "../../node_modules/.pnpm/semver@7.3.5/node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/utils/is.js
var require_is = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asPromise = exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
    function asPromise(value) {
      if (value instanceof Promise) {
        return value;
      } else if (thenable(value)) {
        return new Promise((resolve, reject) => {
          value.then((resolved) => resolve(resolved), (error2) => reject(error2));
        });
      } else {
        return Promise.resolve(value);
      }
    }
    exports2.asPromise = asPromise;
  }
});

// ../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../node_modules/.pnpm/minimatch@3.1.1/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../node_modules/.pnpm/minimatch@3.1.1/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports2.Disposable || (exports2.Disposable = {}));
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = ErrorCodes2.jsonrpcReservedErrorRangeStart;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = ErrorCodes2.jsonrpcReservedErrorRangeEnd;
    })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message = exports2.Message || (exports2.Message = {}));
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a2] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is3 = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is3.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is3 = require_is2();
    var events_1 = require_events();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is3.func(candidate.listen) && Is3.func(candidate.dispose) && Is3.func(candidate.onError) && Is3.func(candidate.onClose) && Is3.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is3.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is3 = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is3.func(candidate.dispose) && Is3.func(candidate.onClose) && Is3.func(candidate.onError) && Is3.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is3.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is3 = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken = exports2.ProgressToken || (exports2.ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is3.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is3.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is3.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is3.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is3.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is3.func(candidate.sendCancellation) && Is3.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ Object.create(null);
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ Object.create(null);
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ Object.create(null);
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ Object.create(null);
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const tokenKey = String(cancelId);
            const cancellationToken = requestTokens[tokenKey];
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = String(requestMessage.id);
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is3.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is3.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = String(responseMessage.id);
          const responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is3.string(responseMessage.id) || Is3.number(responseMessage.id)) {
          const key = String(responseMessage.id);
          const responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is3.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is3.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is3.string(type)) {
              method = type;
              notificationHandlers[type] = { type: void 0, handler };
            } else {
              method = type.method;
              notificationHandlers[type.method] = { type, handler };
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                delete notificationHandlers[method];
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is3.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const result = new Promise((resolve, reject) => {
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is3.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers[type] = { handler, type: void 0 };
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers[type.method] = { type, handler };
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                delete requestHandlers[method];
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is3.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) }).catch(() => {
              logger.error(`Sending trace notification failed`);
            });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = /* @__PURE__ */ Object.create(null);
          requestTokens = /* @__PURE__ */ Object.create(null);
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is3.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is3.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    var path = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readble), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// ../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/vscode-jsonrpc@8.0.0-next.6/node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-types@3.17.0-next.7/node_modules/vscode-languageserver-types/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  AnnotatedTextEdit: () => AnnotatedTextEdit,
  ChangeAnnotation: () => ChangeAnnotation,
  ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
  CodeAction: () => CodeAction,
  CodeActionContext: () => CodeActionContext,
  CodeActionKind: () => CodeActionKind,
  CodeActionTriggerKind: () => CodeActionTriggerKind,
  CodeDescription: () => CodeDescription,
  CodeLens: () => CodeLens,
  Color: () => Color,
  ColorInformation: () => ColorInformation,
  ColorPresentation: () => ColorPresentation,
  Command: () => Command,
  CompletionItem: () => CompletionItem,
  CompletionItemKind: () => CompletionItemKind,
  CompletionItemLabelDetails: () => CompletionItemLabelDetails,
  CompletionItemTag: () => CompletionItemTag,
  CompletionList: () => CompletionList,
  CreateFile: () => CreateFile,
  DeleteFile: () => DeleteFile,
  Diagnostic: () => Diagnostic,
  DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
  DiagnosticSeverity: () => DiagnosticSeverity,
  DiagnosticTag: () => DiagnosticTag,
  DocumentHighlight: () => DocumentHighlight,
  DocumentHighlightKind: () => DocumentHighlightKind,
  DocumentLink: () => DocumentLink,
  DocumentSymbol: () => DocumentSymbol,
  DocumentUri: () => DocumentUri,
  EOL: () => EOL,
  FoldingRange: () => FoldingRange,
  FoldingRangeKind: () => FoldingRangeKind,
  FormattingOptions: () => FormattingOptions,
  Hover: () => Hover,
  InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression,
  InlineValueText: () => InlineValueText,
  InlineValueVariableLookup: () => InlineValueVariableLookup,
  InlineValuesContext: () => InlineValuesContext,
  InsertReplaceEdit: () => InsertReplaceEdit,
  InsertTextFormat: () => InsertTextFormat,
  InsertTextMode: () => InsertTextMode,
  Location: () => Location,
  LocationLink: () => LocationLink,
  MarkedString: () => MarkedString,
  MarkupContent: () => MarkupContent,
  MarkupKind: () => MarkupKind,
  OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
  ParameterInformation: () => ParameterInformation,
  Position: () => Position,
  Range: () => Range,
  RenameFile: () => RenameFile,
  SelectionRange: () => SelectionRange,
  SemanticTokenModifiers: () => SemanticTokenModifiers,
  SemanticTokenTypes: () => SemanticTokenTypes,
  SemanticTokens: () => SemanticTokens,
  SignatureInformation: () => SignatureInformation,
  SymbolInformation: () => SymbolInformation,
  SymbolKind: () => SymbolKind,
  SymbolTag: () => SymbolTag,
  TextDocument: () => TextDocument,
  TextDocumentEdit: () => TextDocumentEdit,
  TextDocumentIdentifier: () => TextDocumentIdentifier,
  TextDocumentItem: () => TextDocumentItem,
  TextEdit: () => TextEdit,
  URI: () => URI,
  VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
  WorkspaceChange: () => WorkspaceChange,
  WorkspaceEdit: () => WorkspaceEdit,
  WorkspaceSymbol: () => WorkspaceSymbol,
  integer: () => integer,
  uinteger: () => uinteger
});
var DocumentUri, URI, integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItemLabelDetails, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, WorkspaceSymbol, DocumentSymbol, CodeActionKind, CodeActionTriggerKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, SemanticTokenTypes, SemanticTokenModifiers, SemanticTokens, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValuesContext, EOL, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "../../node_modules/.pnpm/vscode-languageserver-types@3.17.0-next.7/node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(DocumentUri2) {
      function is(value) {
        return typeof value === "string";
      }
      DocumentUri2.is = is;
    })(DocumentUri || (DocumentUri = {}));
    (function(URI3) {
      function is(value) {
        return typeof value === "string";
      }
      URI3.is = is;
    })(URI || (URI = {}));
    (function(integer3) {
      integer3.MIN_VALUE = -2147483648;
      integer3.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && integer3.MIN_VALUE <= value && value <= integer3.MAX_VALUE;
      }
      integer3.is = is;
    })(integer || (integer = {}));
    (function(uinteger3) {
      uinteger3.MIN_VALUE = 0;
      uinteger3.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && uinteger3.MIN_VALUE <= value && value <= uinteger3.MAX_VALUE;
      }
      uinteger3.is = is;
    })(uinteger || (uinteger = {}));
    (function(Position3) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position3.is = is;
    })(Position || (Position = {}));
    (function(Range3) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
      }
      Range3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range3.is = is;
    })(Range || (Range = {}));
    (function(Location3) {
      function create(uri, range) {
        return { uri, range };
      }
      Location3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location3.is = is;
    })(Location || (Location = {}));
    (function(LocationLink3) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink3.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color3) {
      function create(red, green, blue, alpha) {
        return {
          red,
          green,
          blue,
          alpha
        };
      }
      Color3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color3.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation3) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation3.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation3) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation3.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind3) {
      FoldingRangeKind3["Comment"] = "comment";
      FoldingRangeKind3["Imports"] = "imports";
      FoldingRangeKind3["Region"] = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange3) {
      function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        return result;
      }
      FoldingRange3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange3.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation3) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation3.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity3) {
      DiagnosticSeverity3.Error = 1;
      DiagnosticSeverity3.Warning = 2;
      DiagnosticSeverity3.Information = 3;
      DiagnosticSeverity3.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag3) {
      DiagnosticTag3.Unnecessary = 1;
      DiagnosticTag3.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(CodeDescription3) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
      }
      CodeDescription3.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function(Diagnostic3) {
      function create(range, message, severity, code, source, relatedInformation) {
        var result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic3.create = create;
      function is(value) {
        var _a2;
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic3.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command3) {
      function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command3.is = is;
    })(Command || (Command = {}));
    (function(TextEdit3) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit3.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit3.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit3.del = del;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit3.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(ChangeAnnotation3) {
      function create(label, needsConfirmation, description) {
        var result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation3.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function(ChangeAnnotationIdentifier3) {
      function is(value) {
        var candidate = value;
        return Is.string(candidate);
      }
      ChangeAnnotationIdentifier3.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function(AnnotatedTextEdit3) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit3.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit3.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit3.del = del;
      function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit3.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function(TextDocumentEdit3) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit3.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile3) {
      function create(uri, options, annotation) {
        var result = {
          kind: "create",
          uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile3.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile3) {
      function create(oldUri, newUri, options, annotation) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile3.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile3) {
      function create(uri, options, annotation) {
        var result = {
          kind: "delete",
          uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile3.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit3) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit3.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = function() {
      function TextEditChangeImpl3(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl3.prototype.insert = function(position, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl3.prototype.replace = function(range, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl3.prototype.delete = function(range, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl3.prototype.add = function(edit) {
        this.edits.push(edit);
      };
      TextEditChangeImpl3.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl3.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl3.prototype.assertChangeAnnotations = function(value) {
        if (value === void 0) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl3;
    }();
    ChangeAnnotations = function() {
      function ChangeAnnotations3(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations3.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations3.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations3.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === void 0) {
          throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations3.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations3;
    }();
    WorkspaceChange = function() {
      function WorkspaceChange3(workspaceEdit) {
        var _this = this;
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange3.prototype, "edit", {
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange3.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange3.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange3.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      };
      WorkspaceChange3.prototype.createFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange3.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange3.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      return WorkspaceChange3;
    }();
    (function(TextDocumentIdentifier3) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier3.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier3) {
      function create(uri, version) {
        return { uri, version };
      }
      VersionedTextDocumentIdentifier3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier3.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(OptionalVersionedTextDocumentIdentifier3) {
      function create(uri, version) {
        return { uri, version };
      }
      OptionalVersionedTextDocumentIdentifier3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier3.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem3) {
      function create(uri, languageId, version, text) {
        return { uri, languageId, version, text };
      }
      TextDocumentItem3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem3.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind3) {
      MarkupKind3.PlainText = "plaintext";
      MarkupKind3.Markdown = "markdown";
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupKind3) {
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind3.PlainText || candidate === MarkupKind3.Markdown;
      }
      MarkupKind3.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent3) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent3.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind3) {
      CompletionItemKind3.Text = 1;
      CompletionItemKind3.Method = 2;
      CompletionItemKind3.Function = 3;
      CompletionItemKind3.Constructor = 4;
      CompletionItemKind3.Field = 5;
      CompletionItemKind3.Variable = 6;
      CompletionItemKind3.Class = 7;
      CompletionItemKind3.Interface = 8;
      CompletionItemKind3.Module = 9;
      CompletionItemKind3.Property = 10;
      CompletionItemKind3.Unit = 11;
      CompletionItemKind3.Value = 12;
      CompletionItemKind3.Enum = 13;
      CompletionItemKind3.Keyword = 14;
      CompletionItemKind3.Snippet = 15;
      CompletionItemKind3.Color = 16;
      CompletionItemKind3.File = 17;
      CompletionItemKind3.Reference = 18;
      CompletionItemKind3.Folder = 19;
      CompletionItemKind3.EnumMember = 20;
      CompletionItemKind3.Constant = 21;
      CompletionItemKind3.Struct = 22;
      CompletionItemKind3.Event = 23;
      CompletionItemKind3.Operator = 24;
      CompletionItemKind3.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat3) {
      InsertTextFormat3.PlainText = 1;
      InsertTextFormat3.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag3) {
      CompletionItemTag3.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(InsertReplaceEdit3) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit3.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function(InsertTextMode3) {
      InsertTextMode3.asIs = 1;
      InsertTextMode3.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function(CompletionItemLabelDetails2) {
      function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      CompletionItemLabelDetails2.is = is;
    })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
    (function(CompletionItem3) {
      function create(label) {
        return { label };
      }
      CompletionItem3.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList3) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList3.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString3) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString3.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString3.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover3) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover3.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation3) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation3.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation3) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation3.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind3) {
      DocumentHighlightKind3.Text = 1;
      DocumentHighlightKind3.Read = 2;
      DocumentHighlightKind3.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight3) {
      function create(range, kind) {
        var result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight3.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind3) {
      SymbolKind3.File = 1;
      SymbolKind3.Module = 2;
      SymbolKind3.Namespace = 3;
      SymbolKind3.Package = 4;
      SymbolKind3.Class = 5;
      SymbolKind3.Method = 6;
      SymbolKind3.Property = 7;
      SymbolKind3.Field = 8;
      SymbolKind3.Constructor = 9;
      SymbolKind3.Enum = 10;
      SymbolKind3.Interface = 11;
      SymbolKind3.Function = 12;
      SymbolKind3.Variable = 13;
      SymbolKind3.Constant = 14;
      SymbolKind3.String = 15;
      SymbolKind3.Number = 16;
      SymbolKind3.Boolean = 17;
      SymbolKind3.Array = 18;
      SymbolKind3.Object = 19;
      SymbolKind3.Key = 20;
      SymbolKind3.Null = 21;
      SymbolKind3.EnumMember = 22;
      SymbolKind3.Struct = 23;
      SymbolKind3.Event = 24;
      SymbolKind3.Operator = 25;
      SymbolKind3.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag3) {
      SymbolTag3.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation3) {
      function create(name, kind, range, uri, containerName) {
        var result = {
          name,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation3.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(WorkspaceSymbol2) {
      function create(name, kind, uri, range) {
        return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
      }
      WorkspaceSymbol2.create = create;
    })(WorkspaceSymbol || (WorkspaceSymbol = {}));
    (function(DocumentSymbol3) {
      function create(name, detail, kind, range, selectionRange, children) {
        var result = {
          name,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol3.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind3) {
      CodeActionKind3.Empty = "";
      CodeActionKind3.QuickFix = "quickfix";
      CodeActionKind3.Refactor = "refactor";
      CodeActionKind3.RefactorExtract = "refactor.extract";
      CodeActionKind3.RefactorInline = "refactor.inline";
      CodeActionKind3.RefactorRewrite = "refactor.rewrite";
      CodeActionKind3.Source = "source";
      CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind3.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionTriggerKind2) {
      CodeActionTriggerKind2.Invoked = 1;
      CodeActionTriggerKind2.Automatic = 2;
    })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
    (function(CodeActionContext3) {
      function create(diagnostics, only, triggerKind) {
        var result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        if (triggerKind !== void 0 && triggerKind !== null) {
          result.triggerKind = triggerKind;
        }
        return result;
      }
      CodeActionContext3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
      }
      CodeActionContext3.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction3) {
      function create(title, kindOrCommandOrEdit, kind) {
        var result = { title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction3.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens3) {
      function create(range, data) {
        var result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens3.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions3) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions3.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink3) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink3.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange3) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange3.is(candidate.parent));
      }
      SelectionRange3.is = is;
    })(SelectionRange || (SelectionRange = {}));
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
      SemanticTokenTypes2["decorator"] = "decorator";
    })(SemanticTokenTypes || (SemanticTokenTypes = {}));
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
    (function(SemanticTokens2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens2.is = is;
    })(SemanticTokens || (SemanticTokens = {}));
    (function(InlineValueText2) {
      function create(range, text) {
        return { range, text };
      }
      InlineValueText2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
      }
      InlineValueText2.is = is;
    })(InlineValueText || (InlineValueText = {}));
    (function(InlineValueVariableLookup2) {
      function create(range, variableName, caseSensitiveLookup) {
        return { range, variableName, caseSensitiveLookup };
      }
      InlineValueVariableLookup2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
      }
      InlineValueVariableLookup2.is = is;
    })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
    (function(InlineValueEvaluatableExpression2) {
      function create(range, expression) {
        return { range, expression };
      }
      InlineValueEvaluatableExpression2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
      }
      InlineValueEvaluatableExpression2.is = is;
    })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
    (function(InlineValuesContext2) {
      function create(stoppedLocation) {
        return { stoppedLocation };
      }
      InlineValuesContext2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
      }
      InlineValuesContext2.is = is;
    })(InlineValuesContext || (InlineValuesContext = {}));
    EOL = ["\n", "\r\n", "\r"];
    (function(TextDocument4) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument4.is = is;
      function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort2(edits, function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document.offsetAt(e.range.start);
          var endOffset = document.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument4.applyEdits = applyEdits;
      function mergeSort2(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort2(left, compare);
        mergeSort2(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = function() {
      function FullTextDocument4(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument4.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument4.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument4.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument4.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument4.prototype.update = function(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = void 0;
      };
      FullTextDocument4.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument4.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument4.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument4.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument4;
    }();
    (function(Is3) {
      var toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is3.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is3.undefined = undefined2;
      function boolean(value) {
        return value === true || value === false;
      }
      Is3.boolean = boolean;
      function string(value) {
        return toString.call(value) === "[object String]";
      }
      Is3.string = string;
      function number(value) {
        return toString.call(value) === "[object Number]";
      }
      Is3.number = number;
      function numberRange(value, min, max) {
        return toString.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is3.numberRange = numberRange;
      function integer3(value) {
        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is3.integer = integer3;
      function uinteger3(value) {
        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is3.uinteger = uinteger3;
      function func(value) {
        return toString.call(value) === "[object Function]";
      }
      Is3.func = func;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      Is3.objectLiteral = objectLiteral;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is3.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
    })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRequest = exports2.FoldingRangeKind = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeKind3;
    (function(FoldingRangeKind4) {
      FoldingRangeKind4["Comment"] = "comment";
      FoldingRangeKind4["Imports"] = "imports";
      FoldingRangeKind4["Region"] = "region";
    })(FoldingRangeKind3 = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
    })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
    })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat = exports2.TokenFormat || (exports2.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
    })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
    })(SemanticTokensDeltaRequest = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
    })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2["document"] = "document";
      UniquenessLevel2["project"] = "project";
      UniquenessLevel2["group"] = "group";
      UniquenessLevel2["scheme"] = "scheme";
      UniquenessLevel2["global"] = "global";
    })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2["import"] = "import";
      MonikerKind2["export"] = "export";
      MonikerKind2["local"] = "local";
    })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeError = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = void 0;
    var messages_1 = require_messages2();
    var Is3 = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is3.string(candidate.language) || Is3.string(candidate.scheme) || Is3.string(candidate.pattern);
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter = exports2.TextDocumentFilter || (exports2.TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is3.objectLiteral(candidate) && (Is3.string(candidate.notebookType) || Is3.string(candidate.scheme) || Is3.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter = exports2.NotebookDocumentFilter || (exports2.NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is3.objectLiteral(candidate) && (NotebookDocumentFilter.is(candidate.notebookDocument) || Is3.string(candidate.cellLanguage));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter = exports2.NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is3.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
    })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
    })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is3.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is3.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is3.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is3.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
    })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
    var InitializeError;
    (function(InitializeError2) {
      InitializeError2.unknownProtocolVersion = 1;
    })(InitializeError = exports2.InitializeError || (exports2.InitializeError = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
    })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
    })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
    })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
    })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
    })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
    })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
    })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports2.FileChangeType || (exports2.FileChangeType = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest = exports2.WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
    })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js
var require_proposed_diagnostic = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is3 = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is3.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData = exports2.DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2["full"] = "full";
      DocumentDiagnosticReportKind2["unChanged"] = "unChanged";
    })(DocumentDiagnosticReportKind = exports2.DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest = exports2.DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest = exports2.WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest = exports2.DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/proposed.typeHierarchy.js
var require_proposed_typeHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/proposed.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest = exports2.TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest = exports2.TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest = exports2.TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/proposed.inlineValue.js
var require_proposed_inlineValue = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/proposed.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValuesRefreshRequest = exports2.InlineValuesRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValuesRequest;
    (function(InlineValuesRequest2) {
      InlineValuesRequest2.method = "textDocument/inlineValues";
      InlineValuesRequest2.type = new messages_1.ProtocolRequestType(InlineValuesRequest2.method);
    })(InlineValuesRequest = exports2.InlineValuesRequest || (exports2.InlineValuesRequest = {}));
    var InlineValuesRefreshRequest;
    (function(InlineValuesRefreshRequest2) {
      InlineValuesRefreshRequest2.method = `workspace/inlineValues/refresh`;
      InlineValuesRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValuesRefreshRequest2.method);
    })(InlineValuesRefreshRequest = exports2.InlineValuesRefreshRequest || (exports2.InlineValuesRefreshRequest = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/proposed.notebooks.js
var require_proposed_notebooks = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/proposed.notebooks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidSelectNotebookControllerNotification = exports2.NotebookController = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is3 = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind = exports2.NotebookCellKind || (exports2.NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is3.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is3.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary = exports2.ExecutionSummary || (exports2.ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is3.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is3.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function equals(one, other, compareMetaData = true) {
        if (one.kind !== other.kind || one.document !== other.document) {
          return false;
        }
        return !compareMetaData || compareMetaData && equalsMetadata(one.metadata, other.metadata);
      }
      NotebookCell2.equals = equals;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is3.objectLiteral(one) && Is3.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
    })(NotebookCell = exports2.NotebookCell || (exports2.NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is3.objectLiteral(candidate) && Is3.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is3.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument = exports2.NotebookDocument || (exports2.NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType = exports2.NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
    })(DidOpenNotebookDocumentNotification = exports2.DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is3.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is3.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange = exports2.NotebookCellArrayChange || (exports2.NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
    })(DidChangeNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
    })(DidSaveNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
    })(DidCloseNotebookDocumentNotification = exports2.DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = {}));
    var NotebookController;
    (function(NotebookController2) {
      function create(id, metadata) {
        const result = { id };
        if (metadata !== void 0) {
          result.metadata = metadata;
        }
        return result;
      }
      NotebookController2.create = create;
      function is(value) {
        const candidate = value;
        return Is3.objectLiteral(candidate) && Is3.string(candidate.id) && (candidate.metadata === void 0 || Is3.objectLiteral(candidate.metadata));
      }
      NotebookController2.is = is;
    })(NotebookController = exports2.NotebookController || (exports2.NotebookController = {}));
    var DidSelectNotebookControllerNotification;
    (function(DidSelectNotebookControllerNotification2) {
      DidSelectNotebookControllerNotification2.method = "notebookDocument/didSelectNotebookController";
      DidSelectNotebookControllerNotification2.type = new messages_1.ProtocolNotificationType(DidSelectNotebookControllerNotification2.method);
    })(DidSelectNotebookControllerNotification = exports2.DidSelectNotebookControllerNotification || (exports2.DidSelectNotebookControllerNotification = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Proposed = exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar((init_main(), __toCommonJS(main_exports)), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
    var diag = require_proposed_diagnostic();
    var typeh = require_proposed_typeHierarchy();
    var iv = require_proposed_inlineValue();
    var nb = require_proposed_notebooks();
    var Proposed;
    (function(Proposed2) {
      Proposed2.DiagnosticServerCancellationData = diag.DiagnosticServerCancellationData;
      Proposed2.DocumentDiagnosticReportKind = diag.DocumentDiagnosticReportKind;
      Proposed2.DocumentDiagnosticRequest = diag.DocumentDiagnosticRequest;
      Proposed2.WorkspaceDiagnosticRequest = diag.WorkspaceDiagnosticRequest;
      Proposed2.DiagnosticRefreshRequest = diag.DiagnosticRefreshRequest;
      Proposed2.TypeHierarchyPrepareRequest = typeh.TypeHierarchyPrepareRequest;
      Proposed2.TypeHierarchySupertypesRequest = typeh.TypeHierarchySupertypesRequest;
      Proposed2.TypeHierarchySubtypesRequest = typeh.TypeHierarchySubtypesRequest;
      Proposed2.InlineValuesRequest = iv.InlineValuesRequest;
      Proposed2.InlineValuesRefreshRequest = iv.InlineValuesRefreshRequest;
      Proposed2.NotebookCellKind = nb.NotebookCellKind;
      Proposed2.NotebookCell = nb.NotebookCell;
      Proposed2.NotebookDocument = nb.NotebookDocument;
      Proposed2.NotebookDocumentSyncRegistrationType = nb.NotebookDocumentSyncRegistrationType;
      Proposed2.DidOpenNotebookDocumentNotification = nb.DidOpenNotebookDocumentNotification;
      Proposed2.DidChangeNotebookDocumentNotification = nb.DidChangeNotebookDocumentNotification;
      Proposed2.DidSaveNotebookDocumentNotification = nb.DidSaveNotebookDocumentNotification;
      Proposed2.DidCloseNotebookDocumentNotification = nb.DidCloseNotebookDocumentNotification;
      Proposed2.NotebookController = nb.NotebookController;
      Proposed2.DidSelectNotebookControllerNotification = nb.DidSelectNotebookControllerNotification;
    })(Proposed = exports2.Proposed || (exports2.Proposed = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/configuration.js
var require_configuration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toJSONObject = exports2.ConfigurationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var ConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
      }
      initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
          let configuration = (params2) => {
            let result = [];
            for (let item of params2.items) {
              let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : void 0;
              result.push(this.getConfiguration(resource, item.section !== null ? item.section : void 0));
            }
            return result;
          };
          let middleware = client.clientOptions.middleware.workspace;
          return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
        });
      }
      getConfiguration(resource, section) {
        let result = null;
        if (section) {
          let index = section.lastIndexOf(".");
          if (index === -1) {
            result = toJSONObject(vscode_1.workspace.getConfiguration(void 0, resource).get(section));
          } else {
            let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
            if (config) {
              result = toJSONObject(config.get(section.substr(index + 1)));
            }
          }
        } else {
          let config = vscode_1.workspace.getConfiguration(void 0, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        if (result === void 0) {
          result = null;
        }
        return result;
      }
      dispose() {
      }
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
    function toJSONObject(obj) {
      if (obj) {
        if (Array.isArray(obj)) {
          return obj.map(toJSONObject);
        } else if (typeof obj === "object") {
          const res = /* @__PURE__ */ Object.create(null);
          for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              res[key] = toJSONObject(obj[key]);
            }
          }
          return res;
        }
      }
      return obj;
    }
    exports2.toJSONObject = toJSONObject;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js
var require_protocolCompletionItem = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCompletionItem = class extends code.CompletionItem {
      constructor(label) {
        super(label);
      }
    };
    exports2.default = ProtocolCompletionItem;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolCodeLens.js
var require_protocolCodeLens = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolCodeLens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCodeLens = class extends code.CodeLens {
      constructor(range) {
        super(range);
      }
    };
    exports2.default = ProtocolCodeLens;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js
var require_protocolDocumentLink = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolDocumentLink = class extends code.DocumentLink {
      constructor(range, target) {
        super(range, target);
      }
    };
    exports2.default = ProtocolDocumentLink;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolCodeAction.js
var require_protocolCodeAction = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolCodeAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode2 = require("vscode");
    var ProtocolCodeAction = class extends vscode2.CodeAction {
      constructor(title, data) {
        super(title);
        this.data = data;
      }
    };
    exports2.default = ProtocolCodeAction;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js
var require_protocolDiagnostic = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolDiagnostic = exports2.DiagnosticCode = void 0;
    var vscode2 = require("vscode");
    var Is3 = require_is();
    var DiagnosticCode;
    (function(DiagnosticCode2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && (Is3.number(candidate.value) || Is3.string(candidate.value)) && Is3.string(candidate.target);
      }
      DiagnosticCode2.is = is;
    })(DiagnosticCode = exports2.DiagnosticCode || (exports2.DiagnosticCode = {}));
    var ProtocolDiagnostic = class extends vscode2.Diagnostic {
      constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
      }
    };
    exports2.ProtocolDiagnostic = ProtocolDiagnostic;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js
var require_protocolCallHierarchyItem = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolCallHierarchyItem = class extends code.CallHierarchyItem {
      constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports2.default = ProtocolCallHierarchyItem;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js
var require_protocolTypeHierarchyItem = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolTypeHierarchyItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var ProtocolTypeHierarchyItem = class extends code.TypeHierarchyItem {
      constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports2.default = ProtocolTypeHierarchyItem;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js
var require_protocolWorkspaceSymbol = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolWorkspaceSymbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require("vscode");
    var WorkspaceSymbol2 = class extends code.SymbolInformation {
      constructor(name, kind, containerName, locationOrUri, data) {
        const hasRange = !(locationOrUri instanceof code.Uri);
        super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
        this.hasRange = hasRange;
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports2.default = WorkspaceSymbol2;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/codeConverter.js
var require_codeConverter = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/codeConverter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConverter = void 0;
    var code = require("vscode");
    var proto = require_main2();
    var Is3 = require_is();
    var protocolCompletionItem_1 = require_protocolCompletionItem();
    var protocolCodeLens_1 = require_protocolCodeLens();
    var protocolDocumentLink_1 = require_protocolDocumentLink();
    var protocolCodeAction_1 = require_protocolCodeAction();
    var protocolDiagnostic_1 = require_protocolDiagnostic();
    var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
    var vscode_languageserver_protocol_1 = require_main2();
    var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
    var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
    var InsertReplaceRange;
    (function(InsertReplaceRange2) {
      function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
      }
      InsertReplaceRange2.is = is;
    })(InsertReplaceRange || (InsertReplaceRange = {}));
    function createConverter(uriConverter) {
      const nullConverter = (value) => value.toString();
      const _uriConverter = uriConverter || nullConverter;
      function asUri(value) {
        return _uriConverter(value);
      }
      function asTextDocumentIdentifier(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri)
        };
      }
      function asTextDocumentItem(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri),
          languageId: textDocument.languageId,
          version: textDocument.version,
          text: textDocument.getText()
        };
      }
      function asVersionedTextDocumentIdentifier(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri),
          version: textDocument.version
        };
      }
      function asOpenTextDocumentParams(textDocument) {
        return {
          textDocument: asTextDocumentItem(textDocument)
        };
      }
      function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
      }
      function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
      }
      function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
          let result = {
            textDocument: {
              uri: _uriConverter(arg.uri),
              version: arg.version
            },
            contentChanges: [{ text: arg.getText() }]
          };
          return result;
        } else if (isTextDocumentChangeEvent(arg)) {
          let document = arg.document;
          let result = {
            textDocument: {
              uri: _uriConverter(document.uri),
              version: document.version
            },
            contentChanges: arg.contentChanges.map((change) => {
              let range = change.range;
              return {
                range: {
                  start: { line: range.start.line, character: range.start.character },
                  end: { line: range.end.line, character: range.end.character }
                },
                rangeLength: change.rangeLength,
                text: change.text
              };
            })
          };
          return result;
        } else {
          throw Error("Unsupported text document change parameter");
        }
      }
      function asCloseTextDocumentParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
          result.text = textDocument.getText();
        }
        return result;
      }
      function asTextDocumentSaveReason(reason) {
        switch (reason) {
          case code.TextDocumentSaveReason.Manual:
            return proto.TextDocumentSaveReason.Manual;
          case code.TextDocumentSaveReason.AfterDelay:
            return proto.TextDocumentSaveReason.AfterDelay;
          case code.TextDocumentSaveReason.FocusOut:
            return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
      }
      function asWillSaveTextDocumentParams(event) {
        return {
          textDocument: asTextDocumentIdentifier(event.document),
          reason: asTextDocumentSaveReason(event.reason)
        };
      }
      function asDidCreateFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asDidRenameFilesParams(event) {
        return {
          files: event.files.map((file) => ({
            oldUri: _uriConverter(file.oldUri),
            newUri: _uriConverter(file.newUri)
          }))
        };
      }
      function asDidDeleteFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asWillCreateFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asWillRenameFilesParams(event) {
        return {
          files: event.files.map((file) => ({
            oldUri: _uriConverter(file.oldUri),
            newUri: _uriConverter(file.newUri)
          }))
        };
      }
      function asWillDeleteFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asTextDocumentPositionParams(textDocument, position) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position)
        };
      }
      function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
          case code.CompletionTriggerKind.TriggerCharacter:
            return proto.CompletionTriggerKind.TriggerCharacter;
          case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
            return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
          default:
            return proto.CompletionTriggerKind.Invoked;
        }
      }
      function asCompletionParams(textDocument, position, context) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: {
            triggerKind: asCompletionTriggerKind(context.triggerKind),
            triggerCharacter: context.triggerCharacter
          }
        };
      }
      function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
          case code.SignatureHelpTriggerKind.Invoke:
            return proto.SignatureHelpTriggerKind.Invoked;
          case code.SignatureHelpTriggerKind.TriggerCharacter:
            return proto.SignatureHelpTriggerKind.TriggerCharacter;
          case code.SignatureHelpTriggerKind.ContentChange:
            return proto.SignatureHelpTriggerKind.ContentChange;
        }
      }
      function asParameterInformation(value) {
        return {
          label: value.label
        };
      }
      function asParameterInformations(values) {
        return values.map(asParameterInformation);
      }
      function asSignatureInformation(value) {
        return {
          label: value.label,
          parameters: asParameterInformations(value.parameters)
        };
      }
      function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
      }
      function asSignatureHelp(value) {
        if (value === void 0) {
          return value;
        }
        return {
          signatures: asSignatureInformations(value.signatures),
          activeSignature: value.activeSignature,
          activeParameter: value.activeParameter
        };
      }
      function asSignatureHelpParams(textDocument, position, context) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: {
            isRetrigger: context.isRetrigger,
            triggerCharacter: context.triggerCharacter,
            triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
            activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
          }
        };
      }
      function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
      }
      function asPosition(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return { line: value.line > vscode_languageserver_protocol_1.uinteger.MAX_VALUE ? vscode_languageserver_protocol_1.uinteger.MAX_VALUE : value.line, character: value.character > vscode_languageserver_protocol_1.uinteger.MAX_VALUE ? vscode_languageserver_protocol_1.uinteger.MAX_VALUE : value.character };
      }
      function asPositions(value) {
        let result = [];
        for (let elem of value) {
          result.push(asPosition(elem));
        }
        return result;
      }
      function asRange(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
      }
      function asLocation(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
      }
      function asDiagnosticSeverity(value) {
        switch (value) {
          case code.DiagnosticSeverity.Error:
            return proto.DiagnosticSeverity.Error;
          case code.DiagnosticSeverity.Warning:
            return proto.DiagnosticSeverity.Warning;
          case code.DiagnosticSeverity.Information:
            return proto.DiagnosticSeverity.Information;
          case code.DiagnosticSeverity.Hint:
            return proto.DiagnosticSeverity.Hint;
        }
      }
      function asDiagnosticTags(tags) {
        if (!tags) {
          return void 0;
        }
        let result = [];
        for (let tag of tags) {
          let converted = asDiagnosticTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length > 0 ? result : void 0;
      }
      function asDiagnosticTag(tag) {
        switch (tag) {
          case code.DiagnosticTag.Unnecessary:
            return proto.DiagnosticTag.Unnecessary;
          case code.DiagnosticTag.Deprecated:
            return proto.DiagnosticTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asRelatedInformation(item) {
        return {
          message: item.message,
          location: asLocation(item.location)
        };
      }
      function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
      }
      function asDiagnosticCode(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        if (Is3.number(value) || Is3.string(value)) {
          return value;
        }
        return { value: value.value, target: asUri(value.target) };
      }
      function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : void 0;
        if (protocolDiagnostic !== void 0 && protocolDiagnostic.data !== void 0) {
          result.data = protocolDiagnostic.data;
        }
        const code2 = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code2)) {
          if (protocolDiagnostic !== void 0 && protocolDiagnostic.hasDiagnosticCode) {
            result.code = code2;
          } else {
            result.code = code2.value;
            result.codeDescription = { href: code2.target };
          }
        } else {
          result.code = code2;
        }
        if (Is3.number(item.severity)) {
          result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
          result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
          result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
          result.source = item.source;
        }
        return result;
      }
      function asDiagnostics(items) {
        if (items === void 0 || items === null) {
          return items;
        }
        return items.map(asDiagnostic);
      }
      function asDocumentation(format2, documentation) {
        switch (format2) {
          case "$string":
            return documentation;
          case proto.MarkupKind.PlainText:
            return { kind: format2, value: documentation };
          case proto.MarkupKind.Markdown:
            return { kind: format2, value: documentation.value };
          default:
            return `Unsupported Markup content received. Kind is: ${format2}`;
        }
      }
      function asCompletionItemTag(tag) {
        switch (tag) {
          case code.CompletionItemTag.Deprecated:
            return proto.CompletionItemTag.Deprecated;
        }
        return void 0;
      }
      function asCompletionItemTags(tags) {
        if (tags === void 0) {
          return tags;
        }
        const result = [];
        for (let tag of tags) {
          const converted = asCompletionItemTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result;
      }
      function asCompletionItemKind(value, original) {
        if (original !== void 0) {
          return original;
        }
        return value + 1;
      }
      function asCompletionItem(item, labelDetailsSupport = false) {
        let label;
        let labelDetails;
        if (Is3.string(item.label)) {
          label = item.label;
        } else {
          label = item.label.label;
          if (labelDetailsSupport && (item.label.detail !== void 0 || item.label.description !== void 0)) {
            labelDetails = { detail: item.label.detail, description: item.label.description };
          }
        }
        let result = { label };
        if (labelDetails !== void 0) {
          result.labelDetails = labelDetails;
        }
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : void 0;
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          if (!protocolItem || protocolItem.documentationFormat === "$string") {
            result.documentation = item.documentation;
          } else {
            result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
          }
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is3.number(item.kind)) {
          result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
          result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
          if (protocolItem.data !== void 0) {
            result.data = protocolItem.data;
          }
          if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
            if (protocolItem.deprecated === true && tags !== void 0 && tags.length > 0) {
              const index = tags.indexOf(code.CompletionItemTag.Deprecated);
              if (index !== -1) {
                tags.splice(index, 1);
              }
            }
            result.deprecated = protocolItem.deprecated;
          }
          if (protocolItem.insertTextMode !== void 0) {
            result.insertTextMode = protocolItem.insertTextMode;
          }
        }
        if (tags !== void 0 && tags.length > 0) {
          result.tags = tags;
        }
        if (result.insertTextMode === void 0 && item.keepWhitespace === true) {
          result.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        }
        return result;
      }
      function fillPrimaryInsertText(target, source) {
        let format2 = proto.InsertTextFormat.PlainText;
        let text = void 0;
        let range = void 0;
        if (source.textEdit) {
          text = source.textEdit.newText;
          range = source.textEdit.range;
        } else if (source.insertText instanceof code.SnippetString) {
          format2 = proto.InsertTextFormat.Snippet;
          text = source.insertText.value;
        } else {
          text = source.insertText;
        }
        if (source.range) {
          range = source.range;
        }
        target.insertTextFormat = format2;
        if (source.fromEdit && text !== void 0 && range !== void 0) {
          target.textEdit = asCompletionTextEdit(text, range);
        } else {
          target.insertText = text;
        }
      }
      function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
          return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        } else {
          return { newText, range: asRange(range) };
        }
      }
      function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
      }
      function asTextEdits(edits) {
        if (edits === void 0 || edits === null) {
          return edits;
        }
        return edits.map(asTextEdit);
      }
      function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
          return item + 1;
        }
        return proto.SymbolKind.Property;
      }
      function asSymbolTag(item) {
        return item;
      }
      function asSymbolTags(items) {
        return items.map(asSymbolTag);
      }
      function asReferenceParams(textDocument, position, options) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: { includeDeclaration: options.includeDeclaration }
        };
      }
      function asCodeAction(item) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
          result.data = item.data;
        }
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== void 0) {
          throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      function asCodeActionContext(context) {
        if (context === void 0 || context === null) {
          return context;
        }
        let only;
        if (context.only && Is3.string(context.only.value)) {
          only = [context.only.value];
        }
        return proto.CodeActionContext.create(asDiagnostics(context.diagnostics), only, asCodeActionTriggerKind(context.triggerKind));
      }
      function asCodeActionTriggerKind(kind) {
        switch (kind) {
          case code.CodeActionTriggerKind.Invoke:
            return proto.CodeActionTriggerKind.Invoked;
          case code.CodeActionTriggerKind.Automatic:
            return proto.CodeActionTriggerKind.Automatic;
          default:
            return void 0;
        }
      }
      function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        return item.value;
      }
      function asInlineValuesContext(context) {
        if (context === void 0 || context === null) {
          return context;
        }
        return proto.InlineValuesContext.create(context.stoppedLocation);
      }
      function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
          result.arguments = item.arguments;
        }
        return result;
      }
      function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
          if (item.data) {
            result.data = item.data;
          }
        }
        return result;
      }
      function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
          result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
          result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
          result.insertFinalNewline = true;
        }
        return result;
      }
      function asDocumentSymbolParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asCodeLensParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
          result.target = asUri(item.target);
        }
        if (item.tooltip !== void 0) {
          result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : void 0;
        if (protocolItem && protocolItem.data) {
          result.data = protocolItem.data;
        }
        return result;
      }
      function asDocumentLinkParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asCallHierarchyItem(value) {
        const result = {
          name: value.name,
          kind: asSymbolKind(value.kind),
          uri: asUri(value.uri),
          range: asRange(value.range),
          selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== void 0 && value.detail.length > 0) {
          result.detail = value.detail;
        }
        if (value.tags !== void 0) {
          result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      function asTypeHierarchyItem(value) {
        const result = {
          name: value.name,
          kind: asSymbolKind(value.kind),
          uri: asUri(value.uri),
          range: asRange(value.range),
          selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== void 0 && value.detail.length > 0) {
          result.detail = value.detail;
        }
        if (value.tags !== void 0) {
          result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      function asWorkspaceSymbol(item) {
        const result = item instanceof protocolWorkspaceSymbol_1.default ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data } : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        if (item.containerName !== "") {
          result.containerName = item.containerName;
        }
        return result;
      }
      return {
        asUri,
        asTextDocumentIdentifier,
        asTextDocumentItem,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionContext,
        asInlineValuesContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem,
        asTypeHierarchyItem,
        asWorkspaceSymbol
      };
    }
    exports2.createConverter = createConverter;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolConverter.js
var require_protocolConverter = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/protocolConverter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConverter = void 0;
    var code = require("vscode");
    var ls = require_main2();
    var Is3 = require_is();
    var protocolCompletionItem_1 = require_protocolCompletionItem();
    var protocolCodeLens_1 = require_protocolCodeLens();
    var protocolDocumentLink_1 = require_protocolDocumentLink();
    var protocolCodeAction_1 = require_protocolCodeAction();
    var protocolDiagnostic_1 = require_protocolDiagnostic();
    var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
    var vscode_languageserver_protocol_1 = require_main2();
    var protocolTypeHierarchyItem_1 = require_protocolTypeHierarchyItem();
    var protocolWorkspaceSymbol_1 = require_protocolWorkspaceSymbol();
    var CodeBlock;
    (function(CodeBlock2) {
      function is(value) {
        let candidate = value;
        return candidate && Is3.string(candidate.language) && Is3.string(candidate.value);
      }
      CodeBlock2.is = is;
    })(CodeBlock || (CodeBlock = {}));
    function createConverter(uriConverter, trustMarkdown, supportHtml) {
      const nullConverter = (value) => code.Uri.parse(value);
      const _uriConverter = uriConverter || nullConverter;
      function asUri(value) {
        return _uriConverter(value);
      }
      function asDiagnostics(diagnostics) {
        return diagnostics.map(asDiagnostic);
      }
      function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== void 0) {
          if (ls.CodeDescription.is(diagnostic.codeDescription)) {
            result.code = {
              value: diagnostic.code,
              target: asUri(diagnostic.codeDescription.href)
            };
          } else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
            result.hasDiagnosticCode = true;
            result.code = {
              value: diagnostic.code.value,
              target: asUri(diagnostic.code.target)
            };
          } else {
            result.code = diagnostic.code;
          }
        }
        if (diagnostic.source) {
          result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
          result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
          result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
      }
      function asRelatedInformation(relatedInformation) {
        return relatedInformation.map(asDiagnosticRelatedInformation);
      }
      function asDiagnosticRelatedInformation(information) {
        return new code.DiagnosticRelatedInformation(asLocation(information.location), information.message);
      }
      function asDiagnosticTags(tags) {
        if (!tags) {
          return void 0;
        }
        let result = [];
        for (let tag of tags) {
          let converted = asDiagnosticTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length > 0 ? result : void 0;
      }
      function asDiagnosticTag(tag) {
        switch (tag) {
          case ls.DiagnosticTag.Unnecessary:
            return code.DiagnosticTag.Unnecessary;
          case ls.DiagnosticTag.Deprecated:
            return code.DiagnosticTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asPosition(value) {
        if (!value) {
          return void 0;
        }
        return new code.Position(value.line, value.character);
      }
      function asRange(value) {
        if (!value) {
          return void 0;
        }
        return new code.Range(asPosition(value.start), asPosition(value.end));
      }
      function asRanges(value) {
        return value.map((value2) => asRange(value2));
      }
      function asDiagnosticSeverity(value) {
        if (value === void 0 || value === null) {
          return code.DiagnosticSeverity.Error;
        }
        switch (value) {
          case ls.DiagnosticSeverity.Error:
            return code.DiagnosticSeverity.Error;
          case ls.DiagnosticSeverity.Warning:
            return code.DiagnosticSeverity.Warning;
          case ls.DiagnosticSeverity.Information:
            return code.DiagnosticSeverity.Information;
          case ls.DiagnosticSeverity.Hint:
            return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
      }
      function asHoverContent(value) {
        if (Is3.string(value)) {
          return asMarkdownString(value);
        } else if (CodeBlock.is(value)) {
          let result = asMarkdownString();
          return result.appendCodeblock(value.value, value.language);
        } else if (Array.isArray(value)) {
          let result = [];
          for (let element of value) {
            let item = asMarkdownString();
            if (CodeBlock.is(element)) {
              item.appendCodeblock(element.value, element.language);
            } else {
              item.appendMarkdown(element);
            }
            result.push(item);
          }
          return result;
        } else {
          let result;
          switch (value.kind) {
            case ls.MarkupKind.Markdown:
              return asMarkdownString(value.value);
            case ls.MarkupKind.PlainText:
              result = asMarkdownString();
              result.appendText(value.value);
              return result;
            default:
              result = asMarkdownString();
              result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
              return result;
          }
        }
      }
      function asDocumentation(value) {
        if (Is3.string(value)) {
          return value;
        } else {
          switch (value.kind) {
            case ls.MarkupKind.Markdown:
              return asMarkdownString(value.value);
            case ls.MarkupKind.PlainText:
              return value.value;
            default:
              return `Unsupported Markup content received. Kind is: ${value.kind}`;
          }
        }
      }
      function asMarkdownString(value) {
        const result = new code.MarkdownString(value);
        result.isTrusted = trustMarkdown;
        result.supportHtml = supportHtml;
        return result;
      }
      function asHover(hover) {
        if (!hover) {
          return void 0;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
      }
      function asCompletionResult(result, allCommitCharacters) {
        if (!result) {
          return void 0;
        }
        if (Array.isArray(result)) {
          let items = result;
          return items.map((item) => asCompletionItem(item, allCommitCharacters));
        }
        const list = result;
        const rangeDefaults = list.itemDefaults?.editRange;
        const [range, inserting, replacing] = ls.Range.is(rangeDefaults) ? [asRange(rangeDefaults), void 0, void 0] : rangeDefaults !== void 0 ? [void 0, asRange(rangeDefaults.insert), asRange(rangeDefaults.replace)] : [void 0, void 0, void 0];
        const commitCharacterDefaults = list.itemDefaults?.commitCharacters ?? allCommitCharacters;
        return new code.CompletionList(list.items.map((item) => {
          const result2 = asCompletionItem(item, commitCharacterDefaults, list.itemDefaults?.insertTextMode, list.itemDefaults?.insertTextFormat);
          if (result2.range === void 0) {
            if (range !== void 0) {
              result2.range = range;
            } else if (inserting !== void 0 && replacing !== void 0) {
              result2.range = { inserting, replacing };
            }
          }
          return result2;
        }), list.isIncomplete);
      }
      function asCompletionItemKind(value) {
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
          return [value - 1, void 0];
        }
        return [code.CompletionItemKind.Text, value];
      }
      function asCompletionItemTag(tag) {
        switch (tag) {
          case ls.CompletionItemTag.Deprecated:
            return code.CompletionItemTag.Deprecated;
        }
        return void 0;
      }
      function asCompletionItemTags(tags) {
        if (tags === void 0 || tags === null) {
          return [];
        }
        const result = [];
        for (const tag of tags) {
          const converted = asCompletionItemTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result;
      }
      function asCompletionItem(item, defaultCommitCharacters, defaultInsertTextMode, defaultInsertTextFormat) {
        const tags = asCompletionItemTags(item.tags);
        const label = asCompletionItemLabel(item);
        const result = new protocolCompletionItem_1.default(label);
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          result.documentation = asDocumentation(item.documentation);
          result.documentationFormat = Is3.string(item.documentation) ? "$string" : item.documentation.kind;
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        const insertText = asCompletionInsertText(item, defaultInsertTextFormat);
        if (insertText) {
          result.insertText = insertText.text;
          result.range = insertText.range;
          result.fromEdit = insertText.fromEdit;
        }
        if (Is3.number(item.kind)) {
          let [itemKind, original] = asCompletionItemKind(item.kind);
          result.kind = itemKind;
          if (original) {
            result.originalItemKind = original;
          }
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        const commitCharacters = item.commitCharacters !== void 0 ? Is3.stringArray(item.commitCharacters) ? item.commitCharacters : void 0 : defaultCommitCharacters;
        if (commitCharacters) {
          result.commitCharacters = commitCharacters.slice();
        }
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
          result.deprecated = item.deprecated;
          if (item.deprecated === true) {
            tags.push(code.CompletionItemTag.Deprecated);
          }
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        if (item.data !== void 0) {
          result.data = item.data;
        }
        if (tags.length > 0) {
          result.tags = tags;
        }
        const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
        if (insertTextMode !== void 0) {
          result.insertTextMode = insertTextMode;
          if (insertTextMode === vscode_languageserver_protocol_1.InsertTextMode.asIs) {
            result.keepWhitespace = true;
          }
        }
        return result;
      }
      function asCompletionItemLabel(item) {
        if (vscode_languageserver_protocol_1.CompletionItemLabelDetails.is(item.labelDetails)) {
          return {
            label: item.label,
            detail: item.labelDetails.detail,
            description: item.labelDetails.description
          };
        } else {
          return item.label;
        }
      }
      function asCompletionInsertText(item, defaultInsertTextFormat) {
        const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
        if (item.textEdit) {
          if (insertTextFormat === ls.InsertTextFormat.Snippet) {
            return { text: new code.SnippetString(item.textEdit.newText), range: asCompletionRange(item.textEdit), fromEdit: true };
          } else {
            return { text: item.textEdit.newText, range: asCompletionRange(item.textEdit), fromEdit: true };
          }
        } else if (item.insertText) {
          if (insertTextFormat === ls.InsertTextFormat.Snippet) {
            return { text: new code.SnippetString(item.insertText), fromEdit: false };
          } else {
            return { text: item.insertText, fromEdit: false };
          }
        } else {
          return void 0;
        }
      }
      function asCompletionRange(value) {
        if (ls.InsertReplaceEdit.is(value)) {
          return { inserting: asRange(value.insert), replacing: asRange(value.replace) };
        } else {
          return asRange(value.range);
        }
      }
      function asTextEdit(edit) {
        if (!edit) {
          return void 0;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
      }
      function asTextEdits(items) {
        if (!items) {
          return void 0;
        }
        return items.map(asTextEdit);
      }
      function asSignatureHelp(item) {
        if (!item) {
          return void 0;
        }
        let result = new code.SignatureHelp();
        if (Is3.number(item.activeSignature)) {
          result.activeSignature = item.activeSignature;
        } else {
          result.activeSignature = 0;
        }
        if (Is3.number(item.activeParameter)) {
          result.activeParameter = item.activeParameter;
        } else {
          result.activeParameter = 0;
        }
        if (item.signatures) {
          result.signatures = asSignatureInformations(item.signatures);
        }
        return result;
      }
      function asSignatureInformations(items) {
        return items.map(asSignatureInformation);
      }
      function asSignatureInformation(item) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== void 0) {
          result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== void 0) {
          result.parameters = asParameterInformations(item.parameters);
        }
        if (item.activeParameter !== void 0) {
          result.activeParameter = item.activeParameter;
        }
        {
          return result;
        }
      }
      function asParameterInformations(item) {
        return item.map(asParameterInformation);
      }
      function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
          result.documentation = asDocumentation(item.documentation);
        }
        return result;
      }
      function asLocation(item) {
        if (!item) {
          return void 0;
        }
        return new code.Location(_uriConverter(item.uri), asRange(item.range));
      }
      function asDeclarationResult(item) {
        if (!item) {
          return void 0;
        }
        return asLocationResult(item);
      }
      function asDefinitionResult(item) {
        if (!item) {
          return void 0;
        }
        return asLocationResult(item);
      }
      function asLocationLink(item) {
        if (!item) {
          return void 0;
        }
        let result = {
          targetUri: _uriConverter(item.targetUri),
          targetRange: asRange(item.targetRange),
          originSelectionRange: asRange(item.originSelectionRange),
          targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
          throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
      }
      function asLocationResult(item) {
        if (!item) {
          return void 0;
        }
        if (Is3.array(item)) {
          if (item.length === 0) {
            return [];
          } else if (ls.LocationLink.is(item[0])) {
            let links = item;
            return links.map((link) => asLocationLink(link));
          } else {
            let locations = item;
            return locations.map((location) => asLocation(location));
          }
        } else if (ls.LocationLink.is(item)) {
          return [asLocationLink(item)];
        } else {
          return asLocation(item);
        }
      }
      function asReferences(values) {
        if (!values) {
          return void 0;
        }
        return values.map((location) => asLocation(location));
      }
      function asDocumentHighlights(values) {
        if (!values) {
          return void 0;
        }
        return values.map(asDocumentHighlight);
      }
      function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is3.number(item.kind)) {
          result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
      }
      function asDocumentHighlightKind(item) {
        switch (item) {
          case ls.DocumentHighlightKind.Text:
            return code.DocumentHighlightKind.Text;
          case ls.DocumentHighlightKind.Read:
            return code.DocumentHighlightKind.Read;
          case ls.DocumentHighlightKind.Write:
            return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
      }
      function asSymbolInformations(values) {
        if (!values) {
          return void 0;
        }
        return values.map((information) => asSymbolInformation(information));
      }
      function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
          return item - 1;
        }
        return code.SymbolKind.Property;
      }
      function asSymbolTag(value) {
        switch (value) {
          case ls.SymbolTag.Deprecated:
            return code.SymbolTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asSymbolTags(items) {
        if (items === void 0 || items === null) {
          return void 0;
        }
        const result = [];
        for (const item of items) {
          const converted = asSymbolTag(item);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length === 0 ? void 0 : result;
      }
      function asSymbolInformation(item) {
        const data = item.data;
        const location = item.location;
        const result = location.range === void 0 || data !== void 0 ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? "", location.range === void 0 ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data) : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? "", new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
        fillTags(result, item);
        return result;
      }
      function asDocumentSymbols(values) {
        if (values === void 0 || values === null) {
          return void 0;
        }
        return values.map(asDocumentSymbol);
      }
      function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || "", asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== void 0 && value.children.length > 0) {
          let children = [];
          for (let child of value.children) {
            children.push(asDocumentSymbol(child));
          }
          result.children = children;
        }
        return result;
      }
      function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
          if (!result.tags) {
            result.tags = [code.SymbolTag.Deprecated];
          } else {
            if (!result.tags.includes(code.SymbolTag.Deprecated)) {
              result.tags = result.tags.concat(code.SymbolTag.Deprecated);
            }
          }
        }
      }
      function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
          result.arguments = item.arguments;
        }
        return result;
      }
      function asCommands(items) {
        if (!items) {
          return void 0;
        }
        return items.map(asCommand);
      }
      const kindMapping = /* @__PURE__ */ new Map();
      kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
      kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
      kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
      kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
      kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
      kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
      kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
      kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
      function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        let result = kindMapping.get(item);
        if (result) {
          return result;
        }
        let parts = item.split(".");
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
          result = result.append(part);
        }
        return result;
      }
      function asCodeActionKinds(items) {
        if (items === void 0 || items === null) {
          return void 0;
        }
        return items.map((kind) => asCodeActionKind(kind));
      }
      function asCodeAction(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== void 0) {
          result.edit = asWorkspaceEdit(item.edit);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      function asCodeLens(item) {
        if (!item) {
          return void 0;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.data !== void 0 && item.data !== null) {
          result.data = item.data;
        }
        return result;
      }
      function asCodeLenses(items) {
        if (!items) {
          return void 0;
        }
        return items.map((codeLens) => asCodeLens(codeLens));
      }
      function asWorkspaceEdit(item) {
        if (!item) {
          return void 0;
        }
        const sharedMetadata = /* @__PURE__ */ new Map();
        if (item.changeAnnotations !== void 0) {
          for (const key of Object.keys(item.changeAnnotations)) {
            const metaData = asWorkspaceEditEntryMetadata(item.changeAnnotations[key]);
            sharedMetadata.set(key, metaData);
          }
        }
        const asMetadata = (annotation) => {
          if (annotation === void 0) {
            return void 0;
          } else {
            return sharedMetadata.get(annotation);
          }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
          for (const change of item.documentChanges) {
            if (ls.CreateFile.is(change)) {
              result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
            } else if (ls.RenameFile.is(change)) {
              result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
            } else if (ls.DeleteFile.is(change)) {
              result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
            } else if (ls.TextDocumentEdit.is(change)) {
              const uri = _uriConverter(change.textDocument.uri);
              for (const edit of change.edits) {
                if (vscode_languageserver_protocol_1.AnnotatedTextEdit.is(edit)) {
                  result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                } else {
                  result.replace(uri, asRange(edit.range), edit.newText);
                }
              }
            } else {
              throw new Error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
            }
          }
        } else if (item.changes) {
          Object.keys(item.changes).forEach((key) => {
            result.set(_uriConverter(key), asTextEdits(item.changes[key]));
          });
        }
        return result;
      }
      function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === void 0) {
          return void 0;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
      }
      function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : void 0;
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== void 0) {
          link.tooltip = item.tooltip;
        }
        if (item.data !== void 0 && item.data !== null) {
          link.data = item.data;
        }
        return link;
      }
      function asDocumentLinks(items) {
        if (!items) {
          return void 0;
        }
        return items.map(asDocumentLink);
      }
      function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
      }
      function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
      }
      function asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
          return colorInformation.map(asColorInformation);
        }
        return void 0;
      }
      function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEdits(cp.additionalTextEdits);
        if (cp.textEdit) {
          presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
      }
      function asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
          return colorPresentations.map(asColorPresentation);
        }
        return void 0;
      }
      function asFoldingRangeKind(kind) {
        if (kind) {
          switch (kind) {
            case ls.FoldingRangeKind.Comment:
              return code.FoldingRangeKind.Comment;
            case ls.FoldingRangeKind.Imports:
              return code.FoldingRangeKind.Imports;
            case ls.FoldingRangeKind.Region:
              return code.FoldingRangeKind.Region;
          }
        }
        return void 0;
      }
      function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
      }
      function asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
          return foldingRanges.map(asFoldingRange);
        }
        return void 0;
      }
      function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : void 0);
      }
      function asSelectionRanges(selectionRanges) {
        if (!Array.isArray(selectionRanges)) {
          return [];
        }
        let result = [];
        for (let range of selectionRanges) {
          result.push(asSelectionRange(range));
        }
        return result;
      }
      function asInlineValue(inlineValue) {
        if (ls.InlineValueText.is(inlineValue)) {
          return new code.InlineValueText(asRange(inlineValue.range), inlineValue.text);
        } else if (ls.InlineValueVariableLookup.is(inlineValue)) {
          return new code.InlineValueVariableLookup(asRange(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup);
        } else {
          return new code.InlineValueEvaluatableExpression(asRange(inlineValue.range), inlineValue.expression);
        }
      }
      function asInlineValues(inlineValues) {
        if (!Array.isArray(inlineValues)) {
          return [];
        }
        const result = [];
        for (const inlineValue of inlineValues) {
          result.push(asInlineValue(inlineValue));
        }
        return result;
      }
      function asCallHierarchyItem(item) {
        if (item === null) {
          return void 0;
        }
        const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        return result;
      }
      function asCallHierarchyItems(items) {
        if (items === null) {
          return void 0;
        }
        return items.map((item) => asCallHierarchyItem(item));
      }
      function asCallHierarchyIncomingCall(item) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), asRanges(item.fromRanges));
      }
      function asCallHierarchyIncomingCalls(items) {
        if (items === null) {
          return void 0;
        }
        return items.map((item) => asCallHierarchyIncomingCall(item));
      }
      function asCallHierarchyOutgoingCall(item) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), asRanges(item.fromRanges));
      }
      function asCallHierarchyOutgoingCalls(items) {
        if (items === null) {
          return void 0;
        }
        return items.map((item) => asCallHierarchyOutgoingCall(item));
      }
      function asSemanticTokens(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
      }
      function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== void 0 ? new Uint32Array(value.data) : void 0);
      }
      function asSemanticTokensEdits(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
      }
      function asSemanticTokensLegend(value) {
        return value;
      }
      function asLinkedEditingRanges(value) {
        if (value === null || value === void 0) {
          return void 0;
        }
        return new code.LinkedEditingRanges(asRanges(value.ranges), asRegularExpression(value.wordPattern));
      }
      function asRegularExpression(value) {
        if (value === null || value === void 0) {
          return void 0;
        }
        return new RegExp(value);
      }
      function asTypeHierarchyItem(item) {
        if (item === null) {
          return void 0;
        }
        let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        return result;
      }
      function asTypeHierarchyItems(items) {
        if (items === null) {
          return void 0;
        }
        return items.map((item) => asTypeHierarchyItem(item));
      }
      return {
        asUri,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asInlineValue,
        asInlineValues,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges,
        asTypeHierarchyItem,
        asTypeHierarchyItems
      };
    }
    exports2.createConverter = createConverter;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/utils/async.js
var require_async = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/utils/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Delayer = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var Delayer = class {
      constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = void 0;
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
      }
      trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
          this.cancelTimeout();
        }
        if (!this.completionPromise) {
          this.completionPromise = new Promise((resolve) => {
            this.onSuccess = resolve;
          }).then(() => {
            this.completionPromise = void 0;
            this.onSuccess = void 0;
            var result = this.task();
            this.task = void 0;
            return result;
          });
        }
        if (delay >= 0 || this.timeout === void 0) {
          this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.timeout = void 0;
            this.onSuccess(void 0);
          }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
      }
      forceDelivery() {
        if (!this.completionPromise) {
          return void 0;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
        return result;
      }
      isTriggered() {
        return this.timeout !== void 0;
      }
      cancel() {
        this.cancelTimeout();
        this.completionPromise = void 0;
      }
      cancelTimeout() {
        if (this.timeout !== void 0) {
          this.timeout.dispose();
          this.timeout = void 0;
        }
      }
    };
    exports2.Delayer = Delayer;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class extends ValueUUID {
      constructor() {
        super([
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          "4",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._oneOf(V4UUID._timeHighBits),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse2(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse2;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/progressPart.js
var require_progressPart = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/progressPart.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressPart = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var Is3 = require_is();
    var ProgressPart = class {
      constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._infinite = false;
        this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done();
              done && done(this);
              break;
          }
        });
      }
      begin(params) {
        this._infinite = params.percentage === void 0;
        if (this._lspProgressDisposable === void 0) {
          return;
        }
        void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
          if (this._lspProgressDisposable === void 0) {
            return;
          }
          this._progress = progress;
          this._cancellationToken = cancellationToken;
          this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
            this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
          });
          this.report(params);
          return new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
          });
        });
      }
      report(params) {
        if (this._infinite && Is3.string(params.message)) {
          this._progress !== void 0 && this._progress.report({ message: params.message });
        } else if (Is3.number(params.percentage)) {
          const percentage = Math.max(0, Math.min(params.percentage, 100));
          const delta = Math.max(0, percentage - this._reported);
          this._reported += delta;
          this._progress !== void 0 && this._progress.report({ message: params.message, increment: delta });
        }
      }
      cancel() {
        this.cleanup();
        if (this._reject !== void 0) {
          this._reject();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      done() {
        this.cleanup();
        if (this._resolve !== void 0) {
          this._resolve();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      cleanup() {
        if (this._lspProgressDisposable !== void 0) {
          this._lspProgressDisposable.dispose();
          this._lspProgressDisposable = void 0;
        }
        if (this._tokenDisposable !== void 0) {
          this._tokenDisposable.dispose();
          this._tokenDisposable = void 0;
        }
        this._progress = void 0;
        this._cancellationToken = void 0;
      }
    };
    exports2.ProgressPart = ProgressPart;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/client.js
var require_client = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseLanguageClient = exports2.LSPCancellationError = exports2.MessageTransports = exports2.TextDocumentFeature = exports2.State = exports2.RevealOutputChannelOn = exports2.DiagnosticPullMode = exports2.CloseAction = exports2.ErrorAction = exports2.$DocumentSelector = void 0;
    var minimatch = require_minimatch();
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var configuration_1 = require_configuration();
    var c2p = require_codeConverter();
    var p2c = require_protocolConverter();
    var Is3 = require_is();
    var async_1 = require_async();
    var UUID = require_uuid();
    var progressPart_1 = require_progressPart();
    var $DocumentSelector;
    (function($DocumentSelector2) {
      const CellScheme = "vscode-notebook-cell";
      let $NotebookCellTextDocumentFilter;
      (function($NotebookCellTextDocumentFilter2) {
        function is(value) {
          const candidate = value;
          return vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(value) && candidate.sync === true;
        }
        $NotebookCellTextDocumentFilter2.is = is;
      })($NotebookCellTextDocumentFilter || ($NotebookCellTextDocumentFilter = {}));
      function matchForDocumentSync(selector, textDocument) {
        return match(selector, textDocument, $NotebookCellTextDocumentFilter.is);
      }
      $DocumentSelector2.matchForDocumentSync = matchForDocumentSync;
      function matchForProvider(selector, textDocument) {
        return match(selector, textDocument, vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is);
      }
      $DocumentSelector2.matchForProvider = matchForProvider;
      function match(selector, textDocument, isNotebookCellTextDocumentFilter) {
        const isCellDocument = textDocument.uri.scheme === CellScheme;
        for (const filter of selector) {
          if (isCellDocument && isNotebookCellTextDocumentFilter(filter)) {
            if (filter.cellLanguage !== void 0 && filter.cellLanguage !== textDocument.languageId) {
              continue;
            }
            const notebookDocument = findNotebook(textDocument);
            if (notebookDocument === void 0) {
              continue;
            }
            if (filter.notebookDocument === void 0 || matchNotebookDocument(filter.notebookDocument, notebookDocument)) {
              return true;
            }
          } else if (!isCellDocument && vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
            if (vscode_1.languages.match(filter, textDocument) !== 0) {
              return true;
            }
          }
        }
        return false;
      }
      function skipCellTextDocument(selector, textDocument) {
        if (textDocument.uri.scheme !== CellScheme) {
          return false;
        }
        return !matchForProvider(selector, textDocument);
      }
      $DocumentSelector2.skipCellTextDocument = skipCellTextDocument;
      function asTextDocumentFilters(selector) {
        const result = [];
        const generated = /* @__PURE__ */ new Set();
        for (const filter of selector) {
          if (typeof filter === "string" || vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
            result.push(filter);
          } else {
            if (filter.cellLanguage !== void 0 && !generated.has(filter.cellLanguage)) {
              result.push({ scheme: CellScheme, language: filter.cellLanguage });
              generated.add(filter.cellLanguage);
            } else if (!generated.has(null)) {
              result.push({ scheme: CellScheme });
              generated.add(null);
            }
          }
        }
        return result;
      }
      $DocumentSelector2.asTextDocumentFilters = asTextDocumentFilters;
      function findNotebook(textDocument) {
        if (textDocument.uri.scheme !== CellScheme) {
          return void 0;
        }
        for (const notebookDocument of vscode_1.workspace.notebookDocuments) {
          for (const cell of notebookDocument.getCells()) {
            if (cell.document === textDocument) {
              return notebookDocument;
            }
          }
        }
        return void 0;
      }
      function matchNotebookDocument(filter, notebookDocument) {
        if (filter.notebookType !== void 0 && notebookDocument.notebookType !== filter.notebookType) {
          false;
        }
        const uri = notebookDocument.uri;
        if (filter.scheme !== void 0 && uri.scheme !== filter.scheme) {
          false;
        }
        if (filter.pattern !== void 0) {
          const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
          if (!matcher.makeRe()) {
            return false;
          }
          return matcher.match(uri.fsPath);
        } else {
          return true;
        }
      }
    })($DocumentSelector = exports2.$DocumentSelector || (exports2.$DocumentSelector = {}));
    var ConsoleLogger = class {
      error(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
      }
      warn(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
      }
      info(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
      }
      log(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
      }
    };
    function createConnection(input, output, errorHandler, closeHandler, options) {
      let logger = new ConsoleLogger();
      let connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
      connection.onError((data) => {
        errorHandler(data[0], data[1], data[2]);
      });
      connection.onClose(closeHandler);
      let result = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(type, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, params) => connection.sendNotification(type, params),
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
          const defaultTraceOptions = {
            sendNotification: false,
            traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
          };
          if (sendNotificationOrTraceOptions === void 0) {
            connection.trace(value, tracer, defaultTraceOptions);
          } else if (Is3.boolean(sendNotificationOrTraceOptions)) {
            connection.trace(value, tracer, sendNotificationOrTraceOptions);
          } else {
            connection.trace(value, tracer, sendNotificationOrTraceOptions);
          }
        },
        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0),
        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
        end: () => connection.end(),
        dispose: () => connection.dispose()
      };
      return result;
    }
    var ErrorAction;
    (function(ErrorAction2) {
      ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
      ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
    })(ErrorAction = exports2.ErrorAction || (exports2.ErrorAction = {}));
    var CloseAction;
    (function(CloseAction2) {
      CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
    })(CloseAction = exports2.CloseAction || (exports2.CloseAction = {}));
    var DefaultErrorHandler = class {
      constructor(client, maxRestartCount) {
        this.client = client;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return { action: ErrorAction.Continue };
        }
        return { action: ErrorAction.Shutdown };
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
          return { action: CloseAction.Restart };
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= 3 * 60 * 1e3) {
            return { action: CloseAction.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
          } else {
            this.restarts.shift();
            return { action: CloseAction.Restart };
          }
        }
      }
    };
    var DiagnosticPullMode;
    (function(DiagnosticPullMode2) {
      DiagnosticPullMode2["onType"] = "onType";
      DiagnosticPullMode2["onSave"] = "onSave";
    })(DiagnosticPullMode = exports2.DiagnosticPullMode || (exports2.DiagnosticPullMode = {}));
    var RevealOutputChannelOn;
    (function(RevealOutputChannelOn2) {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
    })(RevealOutputChannelOn = exports2.RevealOutputChannelOn || (exports2.RevealOutputChannelOn = {}));
    var State;
    (function(State2) {
      State2[State2["Stopped"] = 1] = "Stopped";
      State2[State2["Starting"] = 3] = "Starting";
      State2[State2["Running"] = 2] = "Running";
    })(State = exports2.State || (exports2.State = {}));
    var ClientState;
    (function(ClientState2) {
      ClientState2[ClientState2["Initial"] = 0] = "Initial";
      ClientState2[ClientState2["Starting"] = 1] = "Starting";
      ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
      ClientState2[ClientState2["Running"] = 3] = "Running";
      ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
      ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
    })(ClientState || (ClientState = {}));
    var SupportedSymbolKinds = [
      vscode_languageserver_protocol_1.SymbolKind.File,
      vscode_languageserver_protocol_1.SymbolKind.Module,
      vscode_languageserver_protocol_1.SymbolKind.Namespace,
      vscode_languageserver_protocol_1.SymbolKind.Package,
      vscode_languageserver_protocol_1.SymbolKind.Class,
      vscode_languageserver_protocol_1.SymbolKind.Method,
      vscode_languageserver_protocol_1.SymbolKind.Property,
      vscode_languageserver_protocol_1.SymbolKind.Field,
      vscode_languageserver_protocol_1.SymbolKind.Constructor,
      vscode_languageserver_protocol_1.SymbolKind.Enum,
      vscode_languageserver_protocol_1.SymbolKind.Interface,
      vscode_languageserver_protocol_1.SymbolKind.Function,
      vscode_languageserver_protocol_1.SymbolKind.Variable,
      vscode_languageserver_protocol_1.SymbolKind.Constant,
      vscode_languageserver_protocol_1.SymbolKind.String,
      vscode_languageserver_protocol_1.SymbolKind.Number,
      vscode_languageserver_protocol_1.SymbolKind.Boolean,
      vscode_languageserver_protocol_1.SymbolKind.Array,
      vscode_languageserver_protocol_1.SymbolKind.Object,
      vscode_languageserver_protocol_1.SymbolKind.Key,
      vscode_languageserver_protocol_1.SymbolKind.Null,
      vscode_languageserver_protocol_1.SymbolKind.EnumMember,
      vscode_languageserver_protocol_1.SymbolKind.Struct,
      vscode_languageserver_protocol_1.SymbolKind.Event,
      vscode_languageserver_protocol_1.SymbolKind.Operator,
      vscode_languageserver_protocol_1.SymbolKind.TypeParameter
    ];
    var SupportedCompletionItemKinds = [
      vscode_languageserver_protocol_1.CompletionItemKind.Text,
      vscode_languageserver_protocol_1.CompletionItemKind.Method,
      vscode_languageserver_protocol_1.CompletionItemKind.Function,
      vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
      vscode_languageserver_protocol_1.CompletionItemKind.Field,
      vscode_languageserver_protocol_1.CompletionItemKind.Variable,
      vscode_languageserver_protocol_1.CompletionItemKind.Class,
      vscode_languageserver_protocol_1.CompletionItemKind.Interface,
      vscode_languageserver_protocol_1.CompletionItemKind.Module,
      vscode_languageserver_protocol_1.CompletionItemKind.Property,
      vscode_languageserver_protocol_1.CompletionItemKind.Unit,
      vscode_languageserver_protocol_1.CompletionItemKind.Value,
      vscode_languageserver_protocol_1.CompletionItemKind.Enum,
      vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
      vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
      vscode_languageserver_protocol_1.CompletionItemKind.Color,
      vscode_languageserver_protocol_1.CompletionItemKind.File,
      vscode_languageserver_protocol_1.CompletionItemKind.Reference,
      vscode_languageserver_protocol_1.CompletionItemKind.Folder,
      vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
      vscode_languageserver_protocol_1.CompletionItemKind.Constant,
      vscode_languageserver_protocol_1.CompletionItemKind.Struct,
      vscode_languageserver_protocol_1.CompletionItemKind.Event,
      vscode_languageserver_protocol_1.CompletionItemKind.Operator,
      vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
    ];
    var SupportedSymbolTags = [
      vscode_languageserver_protocol_1.SymbolTag.Deprecated
    ];
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var FileFormattingOptions;
    (function(FileFormattingOptions2) {
      function fromConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration("files", document);
        return {
          trimTrailingWhitespace: filesConfig.get("trimTrailingWhitespace"),
          trimFinalNewlines: filesConfig.get("trimFinalNewlines"),
          insertFinalNewline: filesConfig.get("insertFinalNewline")
        };
      }
      FileFormattingOptions2.fromConfiguration = fromConfiguration;
    })(FileFormattingOptions || (FileFormattingOptions = {}));
    var DynamicFeature;
    (function(DynamicFeature2) {
      function is(value) {
        let candidate = value;
        return candidate && Is3.func(candidate.register) && Is3.func(candidate.unregister) && Is3.func(candidate.dispose) && candidate.registrationType !== void 0;
      }
      DynamicFeature2.is = is;
    })(DynamicFeature || (DynamicFeature = {}));
    var DocumentNotifications = class {
      constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = /* @__PURE__ */ new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
      }
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if ($DocumentSelector.matchForDocumentSync(selector, textDocument)) {
            return true;
          }
        }
        return false;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event((data2) => {
            this.callback(data2).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed.`, error);
            });
          });
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      async callback(data) {
        const doSend = async (data2) => {
          const params = this._createParams(data2);
          await this._client.sendNotification(this._type, params).catch();
          this.notificationSent(data2, this._type, params);
        };
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
          return this._middleware ? this._middleware(data, (data2) => doSend(data2)) : doSend(data);
        }
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(data, type, params) {
        this._onNotificationSent.fire({ original: data, type, params });
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document) {
        for (const selector of this._selectors.values()) {
          if ($DocumentSelector.matchForDocumentSync(selector, document)) {
            return {
              send: (data) => {
                return this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    };
    var DidOpenTextDocumentFeature = class extends DocumentNotifications {
      constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get openDocuments() {
        return this._syncedDocuments.values();
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
        }
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
      }
      register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
          let uri = textDocument.uri.toString();
          if (this._syncedDocuments.has(uri)) {
            return;
          }
          if ($DocumentSelector.matchForDocumentSync(documentSelector, textDocument)) {
            let middleware = this._client.clientOptions.middleware;
            let didOpen = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed`, error);
            });
            this._syncedDocuments.set(uri, textDocument);
          }
        });
      }
      notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
      }
    };
    var DidCloseTextDocumentFeature = class extends DocumentNotifications {
      constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
        }
      }
      notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.delete(textDocument.uri.toString());
      }
      unregister(id) {
        let selector = this._selectors.get(id);
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if ($DocumentSelector.matchForDocumentSync(selector, textDocument) && !this._selectorFilter(selectors, textDocument)) {
            let middleware = this._client.clientOptions.middleware;
            let didClose = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed`, error);
            });
          }
        });
      }
    };
    var DidChangeTextDocumentFeature = class {
      constructor(_client) {
        this._client = _client;
        this._changeData = /* @__PURE__ */ new Map();
        this._forcingDelivery = false;
        this._onNotificationSent = new vscode_1.EventEmitter();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          documentSelector: data.registerOptions.documentSelector,
          syncKind: data.registerOptions.syncKind
        });
      }
      async callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        const promises = [];
        for (const changeData of this._changeData.values()) {
          if ($DocumentSelector.matchForDocumentSync(changeData.documentSelector, event.document)) {
            const middleware = this._client.clientOptions.middleware;
            if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
              const didChange = async (event2) => {
                const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event2);
                await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
              };
              promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
            } else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
              const didChange = async (event2) => {
                const doSend = async (event3) => {
                  const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event3.document);
                  await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                  this.notificationSent(event3, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                };
                if (this._changeDelayer) {
                  if (this._changeDelayer.uri !== event2.document.uri.toString()) {
                    this.forceDelivery();
                    this._changeDelayer.uri = event2.document.uri.toString();
                  }
                  return this._changeDelayer.delayer.trigger(() => doSend(event2));
                } else {
                  this._changeDelayer = {
                    uri: event2.document.uri.toString(),
                    delayer: new async_1.Delayer(200)
                  };
                  return this._changeDelayer.delayer.trigger(() => doSend(event2), -1);
                }
              };
              promises.push(middleware.didChange ? middleware.didChange(event, (event2) => didChange(event2)) : didChange(event));
            }
          }
        }
        return Promise.all(promises).then(void 0, (error) => {
          this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
          throw error;
        });
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(changeEvent, type, params) {
        this._onNotificationSent.fire({ original: changeEvent, type, params });
      }
      unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        if (this._changeDelayer !== void 0) {
          this._changeDelayer.delayer.cancel();
        }
        this._changeDelayer = void 0;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
          return;
        }
        try {
          this._forcingDelivery = true;
          this._changeDelayer.delayer.forceDelivery();
        } finally {
          this._forcingDelivery = false;
        }
      }
      getProvider(document) {
        for (const changeData of this._changeData.values()) {
          if ($DocumentSelector.matchForDocumentSync(changeData.documentSelector, document)) {
            return {
              send: (event) => {
                return this.callback(event);
              }
            };
          }
        }
        return void 0;
      }
    };
    var WillSaveFeature = class extends DocumentNotifications {
      constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifications.textDocumentFilter(selectors, willSaveEvent.document));
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
    };
    var WillSaveWaitUntilFeature = class {
      constructor(_client) {
        this._client = _client;
        this._selectors = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(event) {
        if (DocumentNotifications.textDocumentFilter(this._selectors.values(), event.document)) {
          let middleware = this._client.clientOptions.middleware;
          let willSaveWaitUntil = (event2) => {
            return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event2)).then((edits) => {
              let vEdits = this._client.protocol2CodeConverter.asTextEdits(edits);
              return vEdits === void 0 ? [] : vEdits;
            });
          };
          event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
        }
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    var DidSaveTextDocumentFeature = class extends DocumentNotifications {
      constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifications.textDocumentFilter);
        this._includeText = false;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, saveOptions)
          });
        }
      }
      register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
      }
    };
    var FileSystemWatcherFeature = class {
      constructor(_client, _notifyFileEvent) {
        this._client = _client;
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
      }
      initialize(_capabilities, _documentSelector) {
      }
      register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
          if (!Is3.string(watcher.globPattern)) {
            continue;
          }
          let watchCreate = true, watchChange = true, watchDelete = true;
          if (watcher.kind !== void 0 && watcher.kind !== null) {
            watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
            watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
          }
          let fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
          this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete);
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
          this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
          fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Created
          }), null, listeners);
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Changed
          }), null, listeners);
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Deleted
          }), null, listeners);
        }
      }
      unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        }
      }
      dispose() {
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
    var TextDocumentFeature = class {
      constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability) {
          return [void 0, void 0];
        } else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
          const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
          const selector = capability.documentSelector || documentSelector;
          if (selector) {
            return [id, Object.assign({}, capability, { documentSelector: selector })];
          }
        } else if (Is3.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
          if (!documentSelector) {
            return [void 0, void 0];
          }
          let options = Is3.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
          return [UUID.generateUuid(), options];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return Is3.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && $DocumentSelector.matchForProvider(selector, textDocument)) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    };
    exports2.TextDocumentFeature = TextDocumentFeature;
    var WorkspaceFeature = class {
      constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((registration) => {
          registration.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    };
    var CompletionItemFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
        this.labelDetailsSupport = /* @__PURE__ */ new Map();
      }
      fillClientCapabilities(capabilities) {
        let completion = ensure(ensure(capabilities, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport: true,
          commitCharactersSupport: true,
          documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
          deprecatedSupport: true,
          preselectSupport: true,
          tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
          insertReplaceSupport: true,
          resolveSupport: {
            properties: ["documentation", "detail", "additionalTextEdits"]
          },
          insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
          labelDetailsSupport: true
        };
        completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.completionList = {
          itemDefaults: [
            "commitCharacters",
            "editRange",
            "insertTextFormat",
            "insertTextMode"
          ]
        };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options, id) {
        this.labelDetailsSupport.set(id, !!options.completionItem?.labelDetailsSupport);
        const triggerCharacters = options.triggerCharacters ?? [];
        const defaultCommitCharacters = options.allCommitCharacters;
        const selector = options.documentSelector;
        const provider = {
          provideCompletionItems: (document, position, token, context) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const provideCompletionItems = (document2, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document2, position2, context2), token2).then((result) => client.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters), (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token2, error, null);
              });
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems) : provideCompletionItems(document, position, context, token);
          },
          resolveCompletionItem: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item2, !!this.labelDetailsSupport.get(id)), token2).then(client.protocol2CodeConverter.asCompletionItem, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token2, error, item2);
              });
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerCompletionItemProvider($DocumentSelector.asTextDocumentFilters(selector), provider, ...triggerCharacters), provider];
      }
    };
    var HoverFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const hoverCapability = ensure(ensure(capabilities, "textDocument"), "hover");
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideHover: (document, position, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideHover = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then(client.protocol2CodeConverter.asHover, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideHover ? middleware.provideHover(document, position, token, provideHover) : provideHover(document, position, token);
          }
        };
        return [vscode_1.languages.registerHoverProvider($DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    var SignatureHelpFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = ensure(ensure(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideSignatureHelp: (document, position, token, context) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const providerSignatureHelp = (document2, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document2, position2, context2), token2).then(client.protocol2CodeConverter.asSignatureHelp, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp) : providerSignatureHelp(document, position, context, token);
          }
        };
        let disposable;
        const textDocumentSelector = $DocumentSelector.asTextDocumentFilters(selector);
        if (options.retriggerCharacters === void 0) {
          const triggerCharacters = options.triggerCharacters || [];
          disposable = vscode_1.languages.registerSignatureHelpProvider(textDocumentSelector, provider, ...triggerCharacters);
        } else {
          const metaData = {
            triggerCharacters: options.triggerCharacters || [],
            retriggerCharacters: options.retriggerCharacters || []
          };
          disposable = vscode_1.languages.registerSignatureHelpProvider(textDocumentSelector, provider, metaData);
        }
        return [disposable, provider];
      }
    };
    var DefinitionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let definitionSupport = ensure(ensure(capabilities, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDefinition: (document, position, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideDefinition = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document, position, token, provideDefinition) : provideDefinition(document, position, token);
          }
        };
        return [vscode_1.languages.registerDefinitionProvider($DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    var ReferencesFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "references").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideReferences: (document, position, options2, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const _providerReferences = (document2, position2, options3, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document2, position2, options3), token2).then(client.protocol2CodeConverter.asReferences, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document, position, options2, token, _providerReferences) : _providerReferences(document, position, options2, token);
          }
        };
        return [vscode_1.languages.registerReferenceProvider($DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    var DocumentHighlightFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentHighlights: (document, position, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const _provideDocumentHighlights = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then(client.protocol2CodeConverter.asDocumentHighlights, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document, position, token);
          }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider($DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    var DocumentSymbolFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentSymbols: (document, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const _provideDocumentSymbols = (document2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document2), token2).then((data) => {
                if (data === null) {
                  return void 0;
                }
                if (data.length === 0) {
                  return [];
                } else {
                  let element = data[0];
                  if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {
                    return client.protocol2CodeConverter.asDocumentSymbols(data);
                  } else {
                    return client.protocol2CodeConverter.asSymbolInformations(data);
                  }
                }
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols) : _provideDocumentSymbols(document, token);
          }
        };
        const metaData = options.label !== void 0 ? { label: options.label } : void 0;
        return [vscode_1.languages.registerDocumentSymbolProvider($DocumentSelector.asTextDocumentFilters(selector), provider, metaData), provider];
      }
    };
    var WorkspaceSymbolFeature = class extends WorkspaceFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ["location.range"] };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query: query2 }, token2).then(client.protocol2CodeConverter.asSymbolInformations, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          },
          resolveWorkspaceSymbol: options.resolveProvider === true ? (item, token) => {
            const client = this._client;
            const resolveWorkspaceSymbol = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client.code2ProtocolConverter.asWorkspaceSymbol(item2), token2).then(client.protocol2CodeConverter.asSymbolInformation, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
      }
    };
    var CodeActionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const cap = ensure(ensure(capabilities, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.resolveSupport = {
          properties: ["edit"]
        };
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              vscode_languageserver_protocol_1.CodeActionKind.Empty,
              vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
              vscode_languageserver_protocol_1.CodeActionKind.Refactor,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
              vscode_languageserver_protocol_1.CodeActionKind.Source,
              vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
            ]
          }
        };
        cap.honorsChangeAnnotations = false;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideCodeActions: (document, range, context, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const _provideCodeActions = (document2, range2, context2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(range2),
                context: client.code2ProtocolConverter.asCodeActionContext(context2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token2).then((values) => {
                if (values === null) {
                  return void 0;
                }
                const result = [];
                for (let item of values) {
                  if (vscode_languageserver_protocol_1.Command.is(item)) {
                    result.push(client.protocol2CodeConverter.asCommand(item));
                  } else {
                    result.push(client.protocol2CodeConverter.asCodeAction(item));
                  }
                }
                return result;
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions) : _provideCodeActions(document, range, context, token);
          },
          resolveCodeAction: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const resolveCodeAction = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, client.code2ProtocolConverter.asCodeAction(item2), token2).then(client.protocol2CodeConverter.asCodeAction, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token2, error, item2);
              });
            };
            return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerCodeActionsProvider($DocumentSelector.asTextDocumentFilters(selector), provider, options.codeActionKinds ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) } : void 0), provider];
      }
    };
    var CodeLensFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeCodeLensEmitter.fire();
          }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
          onDidChangeCodeLenses: eventEmitter.event,
          provideCodeLenses: (document, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideCodeLenses = (document2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document2), token2).then(client.protocol2CodeConverter.asCodeLenses, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document, token, provideCodeLenses) : provideCodeLenses(document, token);
          },
          resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens2), token2).then(client.protocol2CodeConverter.asCodeLens, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token2, error, codeLens2);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        return [vscode_1.languages.registerCodeLensProvider($DocumentSelector.asTextDocumentFilters(selector), provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
      }
    };
    var DocumentFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentFormattingEdits: (document, options2, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideDocumentFormattingEdits = (document2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token2).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document, options2, token);
          }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider($DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    var DocumentRangeFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "rangeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentRangeFormattingEdits: (document, range, options2, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document2, range2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client.code2ProtocolConverter.asRange(range2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token2).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document, range, options2, token);
          }
        };
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider($DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    var DocumentOnTypeFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideOnTypeFormattingEdits: (document, position, ch, options2, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideOnTypeFormattingEdits = (document2, position2, ch2, options3, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2),
                ch: ch2,
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document2))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token2).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document, position, ch, options2, token);
          }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider($DocumentSelector.asTextDocumentFilters(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
      }
    };
    var RenameFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let rename = ensure(ensure(capabilities, "textDocument"), "rename");
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename.honorsChangeAnnotations = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
          return;
        }
        if (Is3.boolean(capabilities.renameProvider)) {
          options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideRenameEdits: (document, position, newName, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideRenameEdits = (document2, position2, newName2, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2),
                newName: newName2
              };
              return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token2).then(client.protocol2CodeConverter.asWorkspaceEdit, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token2, error, null, false);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits) : provideRenameEdits(document, position, newName, token);
          },
          prepareRename: options.prepareProvider ? (document, position, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const prepareRename = (document2, position2, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                position: client.code2ProtocolConverter.asPosition(position2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token2).then((result) => {
                if (vscode_languageserver_protocol_1.Range.is(result)) {
                  return client.protocol2CodeConverter.asRange(result);
                } else if (this.isDefaultBehavior(result)) {
                  return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                } else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                  return {
                    range: client.protocol2CodeConverter.asRange(result.range),
                    placeholder: result.placeholder
                  };
                }
                return Promise.reject(new Error(`The element can't be renamed.`));
              }, (error) => {
                if (typeof error.message === "string") {
                  throw new Error(error.message);
                } else {
                  throw new Error(`The element can't be renamed.`);
                }
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document, position, token, prepareRename) : prepareRename(document, position, token);
          } : void 0
        };
        return [vscode_1.languages.registerRenameProvider($DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
      isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is3.boolean(candidate.defaultBehavior);
      }
    };
    var DocumentLinkFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = ensure(ensure(capabilities, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDocumentLinks: (document, token) => {
            if ($DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideDocumentLinks = (document2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document2), token2).then(client.protocol2CodeConverter.asDocumentLinks, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document, token, provideDocumentLinks) : provideDocumentLinks(document, token);
          },
          resolveDocumentLink: options.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link2), token2).then(client.protocol2CodeConverter.asDocumentLink, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token2, error, link2);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        return [vscode_1.languages.registerDocumentLinkProvider($DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    var ConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        let section = this._client.clientOptions.synchronize.configurationSection;
        if (section !== void 0) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: {
              section
            }
          });
        }
      }
      register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
          this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== void 0) {
          this.onDidChangeConfiguration(data.registerOptions.section, void 0);
        }
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
          this._listeners.delete(id);
          disposable.dispose();
        }
      }
      dispose() {
        for (const disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is3.string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        if (sections !== void 0 && event !== void 0) {
          let affected = sections.some((section) => event.affectsConfiguration(section));
          if (!affected) {
            return;
          }
        }
        const didChangeConfiguration = async (sections2) => {
          if (sections2 === void 0) {
            return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
          } else {
            return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections2) });
          }
        };
        let middleware = this.getMiddleware();
        (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
          this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
        });
      }
      extractSettingsInformation(keys) {
        function ensurePath(config, path) {
          let current = config;
          for (let i = 0; i < path.length - 1; i++) {
            let obj = current[path[i]];
            if (!obj) {
              obj = /* @__PURE__ */ Object.create(null);
              current[path[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let resource = this._client.clientOptions.workspaceFolder ? this._client.clientOptions.workspaceFolder.uri : void 0;
        let result = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config = null;
          if (index >= 0) {
            config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
          } else {
            config = vscode_1.workspace.getConfiguration(void 0, resource).get(key);
          }
          if (config) {
            let path = keys[i].split(".");
            ensurePath(result, path)[path[path.length - 1]] = (0, configuration_1.toJSONObject)(config);
          }
        }
        return result;
      }
      getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
          return middleware.workspace.didChangeConfiguration;
        } else {
          return void 0;
        }
      }
    };
    var ExecuteCommandFeature = class {
      constructor(_client) {
        this._client = _client;
        this._commands = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        const client = this._client;
        const middleware = client.clientOptions.middleware;
        const executeCommand = (command, args) => {
          let params = {
            command,
            arguments: args
          };
          return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(void 0, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, void 0, error, void 0);
          });
        };
        if (data.registerOptions.commands) {
          const disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      dispose() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
    var MessageTransports;
    (function(MessageTransports2) {
      function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports = exports2.MessageTransports || (exports2.MessageTransports = {}));
    var OnReady = class {
      constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
      }
      get isUsed() {
        return this._used;
      }
      resolve() {
        this._used = true;
        this._resolve();
      }
      reject(error) {
        this._used = true;
        this._reject(error);
      }
    };
    var LSPCancellationError = class extends vscode_1.CancellationError {
      constructor(data) {
        super();
        this.data = data;
      }
    };
    exports2.LSPCancellationError = LSPCancellationError;
    var BaseLanguageClient = class {
      constructor(id, name, clientOptions) {
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._features = [];
        this._dynamicFeatures = /* @__PURE__ */ new Map();
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown !== void 0) {
          markdown.isTrusted = clientOptions.markdown.isTrusted === true;
          markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        this._clientOptions = {
          documentSelector: clientOptions.documentSelector ?? [],
          synchronize: clientOptions.synchronize ?? {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName ?? this._name,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn.Error,
          stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: !!clientOptions.progressOnInitialization,
          errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
          middleware: clientOptions.middleware ?? {},
          uriConverters: clientOptions.uriConverters,
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown,
          diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false }
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
        this._initializeResult = void 0;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
          this._disposeOutputChannel = false;
        } else {
          this._outputChannel = void 0;
          this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._listeners = void 0;
        this._providers = void 0;
        this._diagnostics = void 0;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise((resolve, reject) => {
          this._onReadyCallbacks = new OnReady(resolve, reject);
        });
        this._onStop = void 0;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (Is3.string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : void 0);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : void 0, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this.registerBuiltinFeatures();
      }
      get state() {
        return this._state;
      }
      set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      getPublicState() {
        if (this.state === ClientState.Running) {
          return State.Running;
        } else if (this.state === ClientState.Starting) {
          return State.Starting;
        } else {
          return State.Stopped;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
          throw new Error(`Language client is not ready yet when handling ${Is3.string(type) ? type : type.method}`);
        }
        this.forceDocumentSync();
        try {
          return this._resolvedConnection.sendRequest(type, ...params);
        } catch (error) {
          this.error(`Sending request ${Is3.string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onRequest(type, handler) {
        if (!this.isConnectionActive()) {
          throw new Error(`Language client is not ready yet when handling ${Is3.string(type) ? type : type.method}`);
        }
        try {
          return this._resolvedConnection.onRequest(type, handler);
        } catch (error) {
          this.error(`Registering request handler ${Is3.string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      sendNotification(type, params) {
        if (!this.isConnectionActive()) {
          throw new Error(`Language client is not ready yet when handling ${Is3.string(type) ? type : type.method}`);
        }
        this.forceDocumentSync();
        try {
          return this._resolvedConnection.sendNotification(type, params);
        } catch (error) {
          this.error(`Sending notification ${Is3.string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onNotification(type, handler) {
        if (!this.isConnectionActive()) {
          throw new Error(`Language client is not ready yet when handling ${Is3.string(type) ? type : type.method}`);
        }
        try {
          return this._resolvedConnection.onNotification(type, handler);
        } catch (error) {
          this.error(`Registering notification handler ${Is3.string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onProgress(type, token, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet when trying to send progress");
        }
        try {
          if (vscode_languageserver_protocol_1.WorkDoneProgress.is(type)) {
            const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
            if (handleWorkDoneProgress !== void 0) {
              return this._resolvedConnection.onProgress(type, token, (params) => {
                handleWorkDoneProgress(token, params, () => handler(params));
              });
            }
          }
          return this._resolvedConnection.onProgress(type, token, handler);
        } catch (error) {
          this.error(`Registering progress handler for token ${token} failed.`, error);
          throw error;
        }
      }
      sendProgress(type, token, value) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet when trying to send progress");
        }
        this.forceDocumentSync();
        return this._resolvedConnection.sendProgress(type, token, value).then(void 0, (error) => {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        });
      }
      get name() {
        return this._name;
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get protocol2CodeConverter() {
        return this._p2c;
      }
      get code2ProtocolConverter() {
        return this._c2p;
      }
      get onTelemetry() {
        return this._telemetryEmitter.event;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
      }
      get traceOutputChannel() {
        if (this._traceOutputChannel) {
          return this._traceOutputChannel;
        }
        return this.outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== void 0 && maxRestartCount < 0) {
          throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this, maxRestartCount ?? 4);
      }
      set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
          this.resolveConnection().then((connection) => {
            connection.trace(this._trace, this._tracer, {
              sendNotification: false,
              traceFormat: this._traceFormat
            });
          }, () => this.info(`Setting trace value failed`, void 0, false));
        }, () => {
        });
      }
      data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
          const responseError = data;
          return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
        }
        if (data instanceof Error) {
          if (Is3.string(data.stack)) {
            return data.stack;
          }
          return data.message;
        }
        if (Is3.string(data)) {
          return data;
        }
        return data.toString();
      }
      info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
          this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
      }
      warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
          this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
      }
      error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
          this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
      }
      showNotificationMessage(type, message) {
        message = message ?? "A request has failed. See the output for more information.";
        const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error ? vscode_1.window.showErrorMessage : type === vscode_languageserver_protocol_1.MessageType.Warning ? vscode_1.window.showWarningMessage : vscode_1.window.showInformationMessage;
        void messageFunc(message, "Go to output").then((selection) => {
          if (selection !== void 0) {
            this.outputChannel.show(true);
          }
        });
      }
      logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data) {
          this.traceOutputChannel.appendLine(this.data2String(data));
        }
      }
      logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
          this.traceOutputChannel.append(`[LSP   - ${new Date().toLocaleTimeString()}] `);
        } else {
          this.traceOutputChannel.append(`[Trace - ${new Date().toLocaleTimeString()}] `);
        }
        if (data) {
          this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
      }
      needsStart() {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
      }
      needsStop() {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
      }
      onReady() {
        return this._onReady;
      }
      isConnectionActive() {
        return this.state === ClientState.Running && !!this._resolvedConnection;
      }
      start() {
        if (this._onReadyCallbacks.isUsed) {
          this._onReady = new Promise((resolve, reject) => {
            this._onReadyCallbacks = new OnReady(resolve, reject);
          });
        }
        this._listeners = [];
        this._providers = [];
        if (!this._diagnostics) {
          this._diagnostics = this._clientOptions.diagnosticCollectionName ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName) : vscode_1.languages.createDiagnosticCollection();
        }
        this.state = ClientState.Starting;
        this.resolveConnection().then((connection) => {
          connection.onLogMessage((message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                this.error(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                this.warn(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                this.info(message.message, void 0, false);
                break;
              default:
                this.outputChannel.appendLine(message.message);
            }
          });
          connection.onShowMessage((message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                void vscode_1.window.showErrorMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                void vscode_1.window.showWarningMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                void vscode_1.window.showInformationMessage(message.message);
                break;
              default:
                void vscode_1.window.showInformationMessage(message.message);
            }
          });
          connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
            let messageFunc;
            switch (params.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                messageFunc = vscode_1.window.showErrorMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                messageFunc = vscode_1.window.showWarningMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                messageFunc = vscode_1.window.showInformationMessage;
                break;
              default:
                messageFunc = vscode_1.window.showInformationMessage;
            }
            let actions = params.actions || [];
            return messageFunc(params.message, ...actions);
          });
          connection.onTelemetry((data) => {
            this._telemetryEmitter.fire(data);
          });
          connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
            const showDocument = async (params2) => {
              const uri = this.protocol2CodeConverter.asUri(params2.uri);
              try {
                if (params2.external === true) {
                  const success = await vscode_1.env.openExternal(uri);
                  return { success };
                } else {
                  const options = {};
                  if (params2.selection !== void 0) {
                    options.selection = this.protocol2CodeConverter.asRange(params2.selection);
                  }
                  if (params2.takeFocus === void 0 || params2.takeFocus === false) {
                    options.preserveFocus = true;
                  } else if (params2.takeFocus === true) {
                    options.preserveFocus = false;
                  }
                  await vscode_1.window.showTextDocument(uri, options);
                  return { success: true };
                }
              } catch (error) {
                return { success: true };
              }
            };
            const middleware = this._clientOptions.middleware.window?.showDocument;
            if (middleware !== void 0) {
              return middleware(params, showDocument);
            } else {
              return showDocument(params);
            }
          });
          connection.listen();
          return this.initialize(connection);
        }).catch((error) => {
          this.state = ClientState.StartFailed;
          this._onReadyCallbacks.reject(error);
          this.error(`${this._name} client: couldn't create connection to server`, error, "force");
        });
        return new vscode_1.Disposable(() => {
          if (this.needsStop()) {
            this.stop().catch((error) => {
              this.error(`Stopping server failed.`, error, false);
            });
          }
        });
      }
      resolveConnection() {
        if (!this._connectionPromise) {
          this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
      }
      initialize(connection) {
        this.refreshTrace(connection, false);
        const initOption = this._clientOptions.initializationOptions;
        const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== void 0 ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]] : [this._clientGetRootPath(), null];
        const initParams = {
          processId: null,
          clientInfo: {
            name: vscode_1.env.appName,
            version: vscode_1.version
          },
          locale: this.getLocale(),
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: Is3.func(initOption) ? initOption() : initOption,
          trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
          workspaceFolders
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
          const token = UUID.generateUuid();
          const part = new progressPart_1.ProgressPart(connection, token);
          initParams.workDoneToken = token;
          return this.doInitialize(connection, initParams).then((result) => {
            part.done();
            return result;
          }, (error) => {
            part.cancel();
            throw error;
          });
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      doInitialize(connection, initParams) {
        return connection.initialize(initParams).then((result) => {
          this._resolvedConnection = connection;
          this._initializeResult = result;
          this.state = ClientState.Running;
          let textDocumentSyncOptions = void 0;
          if (Is3.number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
          connection.onDiagnostics((params) => this.handleDiagnostics(params));
          connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          return connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {}).then(() => {
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            this._onReadyCallbacks.resolve();
            return result;
          });
        }).then(void 0, (error) => {
          if (this._clientOptions.initializationFailedHandler) {
            if (this._clientOptions.initializationFailedHandler(error)) {
              void this.initialize(connection);
            } else {
              void this.stop();
              this._onReadyCallbacks.reject(error);
            }
          } else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
            void vscode_1.window.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
              if (item && item.id === "retry") {
                void this.initialize(connection);
              } else {
                void this.stop();
                this._onReadyCallbacks.reject(error);
              }
            });
          } else {
            if (error && error.message) {
              void vscode_1.window.showErrorMessage(error.message);
            }
            this.error("Server initialization failed.", error);
            void this.stop();
            this._onReadyCallbacks.reject(error);
          }
          throw error;
        });
      }
      _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        if (folder.uri.scheme === "file") {
          return folder.uri.fsPath;
        }
        return void 0;
      }
      async stop(timeout = 2e3) {
        await this.onReady();
        this._initializeResult = void 0;
        if (!this._connectionPromise) {
          this.state = ClientState.Stopped;
          return Promise.resolve();
        }
        if (this.state === ClientState.Stopping && this._onStop) {
          return this._onStop;
        }
        this.state = ClientState.Stopping;
        this.cleanUp(false);
        const tp = new Promise((c) => {
          (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout);
        });
        const shutdown = this.resolveConnection().then((connection) => {
          return connection.shutdown().then(() => {
            return connection.exit().then(() => {
              return connection;
            });
          });
        });
        return this._onStop = Promise.race([tp, shutdown]).then((connection) => {
          if (connection !== void 0) {
            connection.end();
            connection.dispose();
          } else {
            this.error(`Stopping server timed out`, void 0, false);
            throw new Error(`Stopping the server timed out`);
          }
        }, (error) => {
          this.error(`Stopping server failed`, error, false);
          throw error;
        }).finally(() => {
          this.state = ClientState.Stopped;
          this.cleanUpChannel();
          this._onStop = void 0;
          this._connectionPromise = void 0;
          this._resolvedConnection = void 0;
        });
      }
      cleanUp(channel = true, diagnostics = true) {
        this._fileEvents = [];
        this._fileEventDelayer.cancel();
        if (this._listeners) {
          this._listeners.forEach((listener) => listener.dispose());
          this._listeners = void 0;
        }
        if (this._providers) {
          this._providers.forEach((provider) => provider.dispose());
          this._providers = void 0;
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        for (const feature of Array.from(this._features.entries()).map((entry) => entry[1]).reverse()) {
          feature.dispose();
        }
        if (channel) {
          this.cleanUpChannel();
        }
        if (diagnostics && this._diagnostics) {
          this._diagnostics.dispose();
          this._diagnostics = void 0;
        }
      }
      cleanUpChannel() {
        if (this._outputChannel && this._disposeOutputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      notifyFileEvent(event) {
        const client = this;
        async function didChangeWatchedFile(event2) {
          client._fileEvents.push(event2);
          return client._fileEventDelayer.trigger(async () => {
            await client.onReady();
            const connection = await client.resolveConnection();
            let promise = Promise.resolve();
            if (client.isConnectionActive()) {
              client.forceDocumentSync();
              promise = connection.didChangeWatchedFiles({ changes: client._fileEvents });
            }
            client._fileEvents = [];
            return promise;
          });
        }
        const workSpaceMiddleware = this.clientOptions.middleware?.workspace;
        (workSpaceMiddleware?.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
          client.error(`Notify file events failed.`, error);
        });
      }
      forceDocumentSync() {
        if (this._didChangeTextDocumentFeature === void 0) {
          this._didChangeTextDocumentFeature = this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method);
        }
        this._didChangeTextDocumentFeature.forceDelivery();
      }
      handleDiagnostics(params) {
        if (!this._diagnostics) {
          return;
        }
        let uri = this._p2c.asUri(params.uri);
        let diagnostics = this._p2c.asDiagnostics(params.diagnostics);
        let middleware = this.clientOptions.middleware;
        if (middleware.handleDiagnostics) {
          middleware.handleDiagnostics(uri, diagnostics, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
        } else {
          this.setDiagnostics(uri, diagnostics);
        }
      }
      setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
          return;
        }
        this._diagnostics.set(uri, diagnostics);
      }
      createConnection() {
        let errorHandler = (error, message, count) => {
          this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
          this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8").then((transports) => {
          return createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        });
      }
      handleConnectionClosed() {
        if (this.state === ClientState.Stopped) {
          return;
        }
        try {
          if (this._resolvedConnection) {
            this._resolvedConnection.dispose();
          }
        } catch (error) {
        }
        let handlerResult = { action: CloseAction.DoNotRestart };
        if (this.state !== ClientState.Stopping) {
          try {
            handlerResult = this._clientOptions.errorHandler.closed();
          } catch (error) {
          }
        }
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
        if (handlerResult.action === CloseAction.DoNotRestart) {
          this.error(handlerResult.message ?? "Connection to server got closed. Server will not be restarted.", void 0, "force");
          if (this.state === ClientState.Starting) {
            this._onReadyCallbacks.reject(new Error(`Connection to server got closed. Server will not be restarted.`));
            this.state = ClientState.StartFailed;
          } else {
            this.state = ClientState.Stopped;
          }
          this.cleanUp(false, true);
        } else if (handlerResult.action === CloseAction.Restart) {
          this.info(handlerResult.message ?? "Connection to server got closed. Server will restart.");
          this.cleanUp(false, false);
          this.state = ClientState.Initial;
          this.start();
        }
      }
      handleConnectionError(error, message, count) {
        const handlerResult = this._clientOptions.errorHandler.error(error, message, count);
        if (handlerResult.action === ErrorAction.Shutdown) {
          this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring. Shutting down server.`, void 0, "force");
          this.stop().catch((error2) => {
            this.error(`Stopping server failed`, error2, false);
          });
        }
      }
      hookConfigurationChanged(connection) {
        vscode_1.workspace.onDidChangeConfiguration(() => {
          this.refreshTrace(connection, true);
        });
      }
      refreshTrace(connection, sendNotification = false) {
        const config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
          } else {
            trace = vscode_languageserver_protocol_1.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        });
      }
      hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
          return;
        }
        let watchers;
        if (Is3.array(fileEvents)) {
          watchers = fileEvents;
        } else {
          watchers = [fileEvents];
        }
        if (!watchers) {
          return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature);
        }
      }
      registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getFeature(request) {
        return this._dynamicFeatures.get(request);
      }
      registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new CompletionItemFeature(this));
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (Is3.func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        ensure(result, "workspace").applyEdit = true;
        const workspaceEdit = ensure(ensure(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
          groupsOnLabel: true
        };
        const diagnostics = ensure(ensure(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = ensure(result, "window");
        const showMessage = ensure(windowCapabilities, "showMessage");
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = ensure(windowCapabilities, "showDocument");
        showDocument.support = true;
        const generalCapabilities = ensure(result, "general");
        generalCapabilities.staleRequestSupport = {
          cancel: true,
          retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = {
          parser: "marked",
          version: "1.1.0"
        };
        if (this._clientOptions.markdown.supportHtml) {
          generalCapabilities.markdown.allowedTags = ["ul", "li", "p", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"];
        }
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      handleRegistrationRequest(params) {
        return new Promise((resolve, reject) => {
          for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (feature === void 0) {
              reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
              return;
            }
            const options = registration.registerOptions ?? {};
            options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
            const data = {
              id: registration.id,
              registerOptions: options
            };
            try {
              feature.register(data);
            } catch (err) {
              reject(err);
              return;
            }
          }
          resolve();
        });
      }
      handleUnregistrationRequest(params) {
        return new Promise((resolve, reject) => {
          for (let unregistration of params.unregisterations) {
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
              reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
              return;
            }
            feature.unregister(unregistration.id);
          }
          resolve();
        });
      }
      handleApplyWorkspaceEdit(params) {
        let workspaceEdit = params.edit;
        let openTextDocuments = /* @__PURE__ */ new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              let textDocument = openTextDocuments.get(change.textDocument.uri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return Is3.asPromise(vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then((value) => {
          return { applied: value };
        }));
      }
      handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
          if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
            if (token !== void 0 && token.isCancellationRequested) {
              return defaultValue;
            } else {
              if (error.data !== void 0) {
                throw new LSPCancellationError(error.data);
              } else {
                throw new vscode_1.CancellationError();
              }
            }
          } else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
            if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
              throw new vscode_1.CancellationError();
            } else {
              return defaultValue;
            }
          }
        }
        this.error(`Request ${type.method} failed.`, error, showNotification);
        throw error;
      }
    };
    exports2.BaseLanguageClient = BaseLanguageClient;
    BaseLanguageClient.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
      vscode_languageserver_protocol_1.SemanticTokensRequest.method,
      vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
      vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
    ]);
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/colorProvider.js
var require_colorProvider = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorProviderFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var ColorProviderFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context2.document),
                range: client.code2ProtocolConverter.asRange(context2.range)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token2).then(this.asColorPresentations.bind(this), (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideDocumentColors = (document2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token2).then(this.asColorInformations.bind(this), (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document, token, provideDocumentColors) : provideDocumentColors(document, token);
          }
        };
        return [vscode_1.languages.registerColorProvider(client_1.$DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
      asColor(color) {
        return new vscode_1.Color(color.red, color.green, color.blue, color.alpha);
      }
      asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
          return colorInformation.map((ci) => {
            return new vscode_1.ColorInformation(this._client.protocol2CodeConverter.asRange(ci.range), this.asColor(ci.color));
          });
        }
        return [];
      }
      asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
          return colorPresentations.map((cp) => {
            let presentation = new vscode_1.ColorPresentation(cp.label);
            presentation.additionalTextEdits = this._client.protocol2CodeConverter.asTextEdits(cp.additionalTextEdits);
            presentation.textEdit = this._client.protocol2CodeConverter.asTextEdit(cp.textEdit);
            return presentation;
          });
        }
        return [];
      }
    };
    exports2.ColorProviderFeature = ColorProviderFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var ImplementationFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let implementationSupport = ensure(ensure(capabilities, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideImplementation: (document, position, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideImplementation = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document, position, token, provideImplementation) : provideImplementation(document, position, token);
          }
        };
        return [vscode_1.languages.registerImplementationProvider(client_1.$DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    exports2.ImplementationFeature = ImplementationFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/typeDefinition.js
var require_typeDefinition = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var TypeDefinitionFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "typeDefinition").dynamicRegistration = true;
        let typeDefinitionSupport = ensure(ensure(capabilities, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideTypeDefinition: (document, position, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideTypeDefinition = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition) : provideTypeDefinition(document, position, token);
          }
        };
        return [vscode_1.languages.registerTypeDefinitionProvider(client_1.$DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    exports2.TypeDefinitionFeature = TypeDefinitionFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/workspaceFolders.js
var require_workspaceFolders = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/workspaceFolders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = exports2.arrayDiff = void 0;
    var UUID = require_uuid();
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    function access(target, key) {
      if (target === void 0) {
        return void 0;
      }
      return target[key];
    }
    function arrayDiff(left, right) {
      return left.filter((element) => right.indexOf(element) < 0);
    }
    exports2.arrayDiff = arrayDiff;
    var WorkspaceFoldersFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
      }
      fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
          const workspaceFolders = () => {
            const folders = vscode_1.workspace.workspaceFolders;
            if (folders === void 0) {
              return null;
            }
            const result = folders.map((folder) => {
              return this.asProtocol(folder);
            });
            return result;
          };
          const middleware = client.clientOptions.middleware.workspace;
          return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id;
        if (typeof value === "string") {
          id = value;
        } else if (value === true) {
          id = UUID.generateUuid();
        }
        if (id) {
          this.register({ id, registerOptions: void 0 });
        }
      }
      sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            promise = this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          promise = this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise !== void 0) {
          promise.catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
      }
      register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (event2) => {
            return this.doSendEvent(event2.added, event2.removed);
          };
          let middleware = client.clientOptions.middleware.workspace;
          const promise = middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
          promise.catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
          return;
        }
        this._listeners.delete(id);
        disposable.dispose();
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
          return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
      }
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var FoldingRangeFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideFoldingRanges: (document, context, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideFoldingRanges = (document2, _, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token2).then(FoldingRangeFeature.asFoldingRanges, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges) : provideFoldingRanges(document, context, token);
          }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(client_1.$DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
      static asFoldingRangeKind(kind) {
        if (kind) {
          switch (kind) {
            case vscode_languageserver_protocol_1.FoldingRangeKind.Comment:
              return vscode_1.FoldingRangeKind.Comment;
            case vscode_languageserver_protocol_1.FoldingRangeKind.Imports:
              return vscode_1.FoldingRangeKind.Imports;
            case vscode_languageserver_protocol_1.FoldingRangeKind.Region:
              return vscode_1.FoldingRangeKind.Region;
          }
        }
        return void 0;
      }
      static asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
          return foldingRanges.map((r) => {
            return new vscode_1.FoldingRange(r.startLine, r.endLine, FoldingRangeFeature.asFoldingRangeKind(r.kind));
          });
        }
        return [];
      }
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/declaration.js
var require_declaration = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var DeclarationFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const declarationSupport = ensure(ensure(capabilities, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideDeclaration: (document, position, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideDeclaration = (document2, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then(client.protocol2CodeConverter.asDeclarationResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document, position, token, provideDeclaration) : provideDeclaration(document, position, token);
          }
        };
        return [vscode_1.languages.registerDeclarationProvider(client_1.$DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    exports2.DeclarationFeature = DeclarationFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/selectionRange.js
var require_selectionRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = /* @__PURE__ */ Object.create(null);
      }
      return target[key];
    }
    var SelectionRangeFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "selectionRange");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideSelectionRanges: (document, positions, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideSelectionRanges = (document2, positions2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                positions: client.code2ProtocolConverter.asPositions(positions2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token2).then((ranges) => client.protocol2CodeConverter.asSelectionRanges(ranges), (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges) : provideSelectionRanges(document, positions, token);
          }
        };
        return [vscode_1.languages.registerSelectionRangeProvider(client_1.$DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    exports2.SelectionRangeFeature = SelectionRangeFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/progress.js
var require_progress = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var progressPart_1 = require_progressPart();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = /* @__PURE__ */ Object.create(null);
      }
      return target[key];
    }
    var ProgressFeature = class {
      constructor(_client) {
        this._client = _client;
        this.activeParts = /* @__PURE__ */ new Set();
      }
      fillClientCapabilities(capabilities) {
        ensure(capabilities, "window").workDoneProgress = true;
      }
      initialize() {
        const client = this._client;
        const deleteHandler = (part) => {
          this.activeParts.delete(part);
        };
        const createHandler = (params) => {
          this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
      }
      dispose() {
        for (const part of this.activeParts) {
          part.done();
        }
        this.activeParts.clear();
      }
    };
    exports2.ProgressFeature = ProgressFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var CallHierarchyProvider = class {
      constructor(client, options) {
        this.client = client;
        this.options = options;
        this.middleware = client.clientOptions.middleware;
      }
      prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document2, position2, token2) => {
          if (client_1.$DocumentSelector.skipCellTextDocument(this.options.documentSelector, document2)) {
            return void 0;
          }
          const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2);
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asCallHierarchyItems(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token2, error, null);
          });
        };
        return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy) : prepareCallHierarchy(document, position, token);
      }
      provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token2, error, null);
          });
        };
        return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
      }
      provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token2, error, null);
          });
        };
        return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
      }
    };
    var CallHierarchyFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure(ensure(capabilities, "textDocument"), "callHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client, options);
        return [vscode_1.languages.registerCallHierarchyProvider(client_1.$DocumentSelector.asTextDocumentFilters(options.documentSelector), provider), provider];
      }
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensFeature = void 0;
    var vscode2 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    var Is3 = require_is();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var SemanticTokensFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
          vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
          vscode_languageserver_protocol_1.SemanticTokenTypes.type,
          vscode_languageserver_protocol_1.SemanticTokenTypes.class,
          vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
          vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
          vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
          vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
          vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
          vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
          vscode_languageserver_protocol_1.SemanticTokenTypes.property,
          vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
          vscode_languageserver_protocol_1.SemanticTokenTypes.event,
          vscode_languageserver_protocol_1.SemanticTokenTypes.function,
          vscode_languageserver_protocol_1.SemanticTokenTypes.method,
          vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
          vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
          vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
          vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
          vscode_languageserver_protocol_1.SemanticTokenTypes.string,
          vscode_languageserver_protocol_1.SemanticTokenTypes.number,
          vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
          vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
          vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
        ];
        capability.tokenModifiers = [
          vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
          range: true,
          full: {
            delta: true
          }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        ensure(ensure(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeSemanticTokensEmitter.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const fullProvider = Is3.boolean(options.full) ? options.full : options.full !== void 0;
        const hasEditProvider = options.full !== void 0 && typeof options.full !== "boolean" && options.full.delta === true;
        const eventEmitter = new vscode2.EventEmitter();
        const documentProvider = fullProvider ? {
          onDidChangeSemanticTokens: eventEmitter.event,
          provideDocumentSemanticTokens: (document, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client2 = this._client;
            const middleware = client2.clientOptions.middleware;
            const provideDocumentSemanticTokens = (document2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2)
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token2).then((result) => {
                return client2.protocol2CodeConverter.asSemanticTokens(result);
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document, token);
          },
          provideDocumentSemanticTokensEdits: hasEditProvider ? (document, previousResultId, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client2 = this._client;
            const middleware = client2.clientOptions.middleware;
            const provideDocumentSemanticTokensEdits = (document2, previousResultId2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                previousResultId: previousResultId2
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token2).then((result) => {
                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                  return client2.protocol2CodeConverter.asSemanticTokens(result);
                } else {
                  return client2.protocol2CodeConverter.asSemanticTokensEdits(result);
                }
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document, previousResultId, token);
          } : void 0
        } : void 0;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider ? {
          provideDocumentRangeSemanticTokens: (document, range, token) => {
            const client2 = this._client;
            const middleware = client2.clientOptions.middleware;
            const provideDocumentRangeSemanticTokens = (document2, range2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                range: client2.code2ProtocolConverter.asRange(range2)
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token2).then((result) => {
                return client2.protocol2CodeConverter.asSemanticTokens(result);
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token2, error, null);
              });
            };
            return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document, range, token);
          }
        } : void 0;
        const disposables = [];
        const client = this._client;
        const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        const textDocumentSelectors = client_1.$DocumentSelector.asTextDocumentFilters(selector);
        if (documentProvider !== void 0) {
          disposables.push(vscode2.languages.registerDocumentSemanticTokensProvider(textDocumentSelectors, documentProvider, legend));
        }
        if (rangeProvider !== void 0) {
          disposables.push(vscode2.languages.registerDocumentRangeSemanticTokensProvider(textDocumentSelectors, rangeProvider, legend));
        }
        return [new vscode2.Disposable(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
      }
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesFeature = exports2.WillRenameFilesFeature = exports2.WillCreateFilesFeature = exports2.DidDeleteFilesFeature = exports2.DidRenameFilesFeature = exports2.DidCreateFilesFeature = void 0;
    var code = require("vscode");
    var minimatch = require_minimatch();
    var proto = require_main2();
    var UUID = require_uuid();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    function access(target, key) {
      return target[key];
    }
    function assign(target, key, value) {
      target[key] = value;
    }
    var FileOperationFeature = class {
      constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._filters = /* @__PURE__ */ new Map();
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
      }
      filterSize() {
        return this._filters.size;
      }
      get registrationType() {
        return this._registrationType;
      }
      fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
        assign(value, "dynamicRegistration", true);
        assign(value, this._clientCapability, true);
      }
      initialize(capabilities) {
        const options = capabilities.workspace?.fileOperations;
        const capability = options !== void 0 ? access(options, this._serverCapability) : void 0;
        if (capability?.filters !== void 0) {
          try {
            this.register({
              id: UUID.generateUuid(),
              registerOptions: { filters: capability.filters }
            });
          } catch (e) {
            this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
          }
        }
      }
      register(data) {
        if (!this._listener) {
          this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
          const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
          if (!matcher.makeRe()) {
            throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
          }
          return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
      }
      unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._filters.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getFileType(uri) {
        return FileOperationFeature.getFileType(uri);
      }
      async filter(event, prop) {
        const fileMatches = await Promise.all(event.files.map(async (item) => {
          const uri = prop(item);
          const path = uri.fsPath.replace(/\\/g, "/");
          for (const filters of this._filters.values()) {
            for (const filter of filters) {
              if (filter.scheme !== void 0 && filter.scheme !== uri.scheme) {
                continue;
              }
              if (filter.matcher.match(path)) {
                if (filter.kind === void 0) {
                  return true;
                }
                const fileType = await this.getFileType(uri);
                if (fileType === void 0) {
                  this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                  return true;
                }
                if (fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file || fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder) {
                  return true;
                }
              } else if (filter.kind === proto.FileOperationPatternKind.folder) {
                const fileType = await FileOperationFeature.getFileType(uri);
                if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {
                  return true;
                }
              }
            }
          }
          return false;
        }));
        const files = event.files.filter((_, index) => fileMatches[index]);
        return { ...event, files };
      }
      static async getFileType(uri) {
        try {
          return (await code.workspace.fs.stat(uri)).type;
        } catch (e) {
          return void 0;
        }
      }
      static asMinimatchOptions(options) {
        if (options === void 0) {
          return void 0;
        }
        if (options.ignoreCase === true) {
          return { nocase: true };
        }
        return void 0;
      }
    };
    var NotificationFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = async (event) => {
            return this._client.sendNotification(this._notificationType, this._createParams(event));
          };
          return this.doSend(filteredEvent, next);
        }
      }
    };
    var CachingNotificationFileOperationFeature = class extends NotificationFileOperationFeature {
      constructor() {
        super(...arguments);
        this._fsPathFileTypes = /* @__PURE__ */ new Map();
      }
      async getFileType(uri) {
        const fsPath = uri.fsPath;
        if (this._fsPathFileTypes.has(fsPath)) {
          return this._fsPathFileTypes.get(fsPath);
        }
        const type = await FileOperationFeature.getFileType(uri);
        if (type) {
          this._fsPathFileTypes.set(fsPath, type);
        }
        return type;
      }
      async cacheFileTypes(event, prop) {
        await this.filter(event, prop);
      }
      clearFileTypeCache() {
        this._fsPathFileTypes.clear();
      }
      unregister(id) {
        super.unregister(id);
        if (this.filterSize() === 0 && this._willListener) {
          this._willListener.dispose();
          this._willListener = void 0;
        }
      }
      dispose() {
        super.dispose();
        if (this._willListener) {
          this._willListener.dispose();
          this._willListener = void 0;
        }
      }
    };
    var DidCreateFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, "didCreate", "didCreate", (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.clientOptions.middleware?.workspace;
        return middleware?.didCreateFiles ? middleware.didCreateFiles(event, next) : next(event);
      }
    };
    exports2.DidCreateFilesFeature = DidCreateFilesFeature;
    var DidRenameFilesFeature = class extends CachingNotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, "didRename", "didRename", (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
      }
      register(data) {
        if (!this._willListener) {
          this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
        }
        super.register(data);
      }
      willRename(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
      }
      doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.clientOptions.middleware?.workspace;
        return middleware?.didRenameFiles ? middleware.didRenameFiles(event, next) : next(event);
      }
    };
    exports2.DidRenameFilesFeature = DidRenameFilesFeature;
    var DidDeleteFilesFeature = class extends CachingNotificationFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, "didDelete", "didDelete", (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
      }
      register(data) {
        if (!this._willListener) {
          this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
        }
        super.register(data);
      }
      willDelete(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i));
      }
      doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.clientOptions.middleware?.workspace;
        return middleware?.didDeleteFiles ? middleware.didDeleteFiles(event, next) : next(event);
      }
    };
    exports2.DidDeleteFilesFeature = DidDeleteFilesFeature;
    var RequestFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
      }
      async waitUntil(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = (event) => {
            return this._client.sendRequest(this._requestType, this._createParams(event), event.token).then(this._client.protocol2CodeConverter.asWorkspaceEdit);
          };
          return this.doSend(filteredEvent, next);
        } else {
          return void 0;
        }
      }
    };
    var WillCreateFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, "willCreate", "willCreate", (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.clientOptions.middleware?.workspace;
        return middleware?.willCreateFiles ? middleware.willCreateFiles(event, next) : next(event);
      }
    };
    exports2.WillCreateFilesFeature = WillCreateFilesFeature;
    var WillRenameFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, "willRename", "willRename", (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.clientOptions.middleware?.workspace;
        return middleware?.willRenameFiles ? middleware.willRenameFiles(event, next) : next(event);
      }
    };
    exports2.WillRenameFilesFeature = WillRenameFilesFeature;
    var WillDeleteFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, "willDelete", "willDelete", (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
      }
      doSend(event, next) {
        const middleware = this._client.clientOptions.middleware?.workspace;
        return middleware?.willDeleteFiles ? middleware.willDeleteFiles(event, next) : next(event);
      }
    };
    exports2.WillDeleteFilesFeature = WillDeleteFilesFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingFeature = void 0;
    var code = require("vscode");
    var proto = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var LinkedEditingFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, proto.LinkedEditingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const linkedEditingSupport = ensure(ensure(capabilities, "textDocument"), "linkedEditingRange");
        linkedEditingSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
          provideLinkedEditingRanges: (document, position, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideLinkedEditing = (document2, position2, token2) => {
              return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2), token2).then(client.protocol2CodeConverter.asLinkedEditingRanges, (error) => {
                return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document, position, token, provideLinkedEditing) : provideLinkedEditing(document, position, token);
          }
        };
        return [code.languages.registerLinkedEditingRangeProvider(client_1.$DocumentSelector.asTextDocumentFilters(selector), provider), provider];
      }
    };
    exports2.LinkedEditingFeature = LinkedEditingFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/proposed.diagnostic.js
var require_proposed_diagnostic2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/proposed.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = exports2.vsdiag = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var uuid_1 = require_uuid();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var vsdiag;
    (function(vsdiag2) {
      let DocumentDiagnosticReportKind;
      (function(DocumentDiagnosticReportKind2) {
        DocumentDiagnosticReportKind2["full"] = "full";
        DocumentDiagnosticReportKind2["unChanged"] = "unChanged";
      })(DocumentDiagnosticReportKind = vsdiag2.DocumentDiagnosticReportKind || (vsdiag2.DocumentDiagnosticReportKind = {}));
    })(vsdiag = exports2.vsdiag || (exports2.vsdiag = {}));
    var RequestStateKind;
    (function(RequestStateKind2) {
      RequestStateKind2["active"] = "open";
      RequestStateKind2["reschedule"] = "reschedule";
      RequestStateKind2["outDated"] = "drop";
    })(RequestStateKind || (RequestStateKind = {}));
    var EditorTracker = class {
      constructor() {
        this.open = /* @__PURE__ */ new Set();
        const openTabsHandler = () => {
          this.open.clear();
          if (vscode_1.window.tabs !== void 0) {
            for (const tab of vscode_1.window.tabs) {
              if (tab.resource !== void 0) {
                this.open.add(tab.resource.toString());
              }
            }
          } else if (vscode_1.window.openEditors !== void 0) {
            for (const info of vscode_1.window.openEditors) {
              if (info.resource !== void 0) {
                this.open.add(info.resource.toString());
              }
            }
          }
        };
        openTabsHandler();
        if (vscode_1.window.onDidChangeTabs !== void 0) {
          this.disposable = vscode_1.window.onDidChangeTabs(openTabsHandler);
        } else if (vscode_1.window.onDidChangeOpenEditors !== void 0) {
          this.disposable = vscode_1.window.onDidChangeOpenEditors(openTabsHandler);
        } else {
          this.disposable = { dispose: () => {
          } };
        }
      }
      dispose() {
        this.disposable.dispose();
      }
      isActive(textDocument) {
        return vscode_1.window.activeTextEditor?.document === textDocument;
      }
      isVisible(textDocument) {
        return this.open.has(textDocument.uri.toString());
      }
    };
    var PullState;
    (function(PullState2) {
      PullState2[PullState2["document"] = 1] = "document";
      PullState2[PullState2["workspace"] = 2] = "workspace";
    })(PullState || (PullState = {}));
    var DocumentPullStateTracker = class {
      constructor() {
        this.documentPullStates = /* @__PURE__ */ new Map();
        this.workspacePullStates = /* @__PURE__ */ new Map();
      }
      track(kind, document, arg1) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version] = typeof document === "string" ? [document, vscode_1.Uri.parse(document), arg1] : [document.uri.toString(), document.uri, document.version];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version, resultId: void 0 };
          states.set(key, state);
        }
        return state;
      }
      update(kind, document, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = typeof document === "string" ? [document, vscode_1.Uri.parse(document), arg1, arg2] : [document.uri.toString(), document.uri, document.version, arg1];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version, resultId };
          states.set(key, state);
        } else {
          state.pulledVersion = version;
          state.resultId = resultId;
        }
      }
      unTrack(kind, textDocument) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(textDocument.uri.toString());
      }
      tracks(kind, document) {
        const key = typeof document === "string" ? document : document.uri.toString();
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
      }
      getResultId(kind, textDocument) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.get(textDocument.uri.toString())?.resultId;
      }
      getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
          if (this.documentPullStates.has(uri)) {
            value = this.documentPullStates.get(uri);
          }
          if (value.resultId !== void 0) {
            result.push({ uri, value: value.resultId });
          }
        }
        return result;
      }
    };
    var DiagnosticRequestor = class {
      constructor(client, editorTracker, options) {
        this.client = client;
        this.editorTracker = editorTracker;
        this.options = options;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        this.provider = this.createProvider();
        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
        this.openRequests = /* @__PURE__ */ new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
      }
      knows(kind, textDocument) {
        return this.documentStates.tracks(kind, textDocument);
      }
      pull(textDocument, cb) {
        this.pullAsync(textDocument).then(() => {
          if (cb) {
            cb();
          }
        }, (error) => {
          this.client.error(`Document pull failed for text document ${textDocument.uri.toString()}`, error, false);
        });
      }
      async pullAsync(textDocument) {
        const key = textDocument.uri.toString();
        const version = textDocument.version;
        const currentRequestState = this.openRequests.get(key);
        const documentState = this.documentStates.track(PullState.document, textDocument);
        if (currentRequestState === void 0) {
          const tokenSource = new vscode_1.CancellationTokenSource();
          this.openRequests.set(key, { state: RequestStateKind.active, version, textDocument, tokenSource });
          let report;
          let afterState;
          try {
            report = await this.provider.provideDiagnostics(textDocument, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
          } catch (error) {
            if (error instanceof client_1.LSPCancellationError && vscode_languageserver_protocol_1.Proposed.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
              afterState = { state: RequestStateKind.outDated, textDocument };
            }
            if (afterState === void 0 && error instanceof vscode_1.CancellationError) {
              afterState = { state: RequestStateKind.reschedule, textDocument };
            } else {
              throw error;
            }
          }
          afterState = afterState ?? this.openRequests.get(key);
          if (afterState === void 0) {
            this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
            this.diagnostics.delete(textDocument.uri);
            return;
          }
          this.openRequests.delete(key);
          if (!this.editorTracker.isVisible(textDocument)) {
            this.documentStates.unTrack(PullState.document, textDocument);
            return;
          }
          if (afterState.state === RequestStateKind.outDated) {
            return;
          }
          if (report !== void 0) {
            if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
              this.diagnostics.set(textDocument.uri, report.items);
            }
            documentState.pulledVersion = version;
            documentState.resultId = report.resultId;
          }
          if (afterState.state === RequestStateKind.reschedule) {
            this.pull(textDocument);
          }
        } else {
          if (currentRequestState.state === RequestStateKind.active) {
            currentRequestState.tokenSource.cancel();
            this.openRequests.set(key, { state: RequestStateKind.reschedule, textDocument: currentRequestState.textDocument });
          } else if (currentRequestState.state === RequestStateKind.outDated) {
            this.openRequests.set(key, { state: RequestStateKind.reschedule, textDocument: currentRequestState.textDocument });
          }
        }
      }
      cleanupPull(textDocument) {
        const key = textDocument.uri.toString();
        const request = this.openRequests.get(key);
        if (this.options.workspaceDiagnostics || this.options.interFileDependencies) {
          if (request !== void 0) {
            this.openRequests.set(key, { state: RequestStateKind.reschedule, textDocument });
          } else {
            this.pull(textDocument);
          }
        } else {
          if (request !== void 0) {
            if (request.state === RequestStateKind.active) {
              request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, textDocument });
          }
          this.diagnostics.delete(textDocument.uri);
        }
      }
      pullWorkspace() {
        this.pullWorkspaceAsync().then(() => {
          this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, 2e3);
        }, (error) => {
          if (!(error instanceof client_1.LSPCancellationError) && !vscode_languageserver_protocol_1.Proposed.DiagnosticServerCancellationData.is(error.data)) {
            this.client.error(`Workspace diagnostic pull failed.`, error, false);
            this.workspaceErrorCounter++;
          }
          if (this.workspaceErrorCounter <= 5) {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, 2e3);
          }
        });
      }
      async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics) {
          return;
        }
        if (this.workspaceCancellation !== void 0) {
          this.workspaceCancellation.cancel();
          this.workspaceCancellation = void 0;
        }
        this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
          return {
            uri: this.client.protocol2CodeConverter.asUri(item.uri),
            value: item.value
          };
        });
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
          if (!chunk || this.isDisposed) {
            return;
          }
          for (const item of chunk.items) {
            if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
              if (!this.documentStates.tracks(PullState.document, item.uri.toString())) {
                this.diagnostics.set(item.uri, item.items);
              }
            }
            this.documentStates.update(PullState.workspace, item.uri.toString(), item.version ?? void 0, item.resultId);
          }
        });
      }
      createProvider() {
        const result = {
          onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
          provideDiagnostics: (textDocument, previousResultId, token) => {
            const provideDiagnostics = (textDocument2, previousResultId2, token2) => {
              const params = {
                identifier: this.options.identifier,
                textDocument: { uri: this.client.code2ProtocolConverter.asUri(textDocument2.uri) },
                previousResultId: previousResultId2
              };
              return this.client.sendRequest(vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type, params, token2).then((result2) => {
                if (result2 === void 0 || result2 === null || this.isDisposed) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                }
                if (result2.kind === vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticReportKind.full) {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result2.resultId, items: this.client.protocol2CodeConverter.asDiagnostics(result2.items) };
                } else {
                  return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result2.resultId };
                }
              }, (error) => {
                return this.client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type, token2, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
              });
            };
            const middleware = this.client.clientOptions.middleware;
            return middleware.provideDiagnostics ? middleware.provideDiagnostics(textDocument, previousResultId, token, provideDiagnostics) : provideDiagnostics(textDocument, previousResultId, token);
          }
        };
        if (this.options.workspaceDiagnostics) {
          result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
            const convertReport = (report) => {
              if (report.kind === vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticReportKind.full) {
                return {
                  kind: vsdiag.DocumentDiagnosticReportKind.full,
                  uri: this.client.protocol2CodeConverter.asUri(report.uri),
                  resultId: report.resultId,
                  version: report.version,
                  items: this.client.protocol2CodeConverter.asDiagnostics(report.items)
                };
              } else {
                return {
                  kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                  uri: this.client.protocol2CodeConverter.asUri(report.uri),
                  resultId: report.resultId,
                  version: report.version
                };
              }
            };
            const convertPreviousResultIds = (resultIds2) => {
              const converted = [];
              for (const item of resultIds2) {
                converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
              }
              return converted;
            };
            const provideDiagnostics = (resultIds2, token2) => {
              const partialResultToken = (0, uuid_1.generateUuid)();
              const disposable = this.client.onProgress(vscode_languageserver_protocol_1.Proposed.WorkspaceDiagnosticRequest.partialResult, partialResultToken, (partialResult) => {
                if (partialResult === void 0 || partialResult === null) {
                  resultReporter(null);
                  return;
                }
                const converted = {
                  items: []
                };
                for (const item of partialResult.items) {
                  converted.items.push(convertReport(item));
                }
                resultReporter(converted);
              });
              const params = {
                identifier: this.options.identifier,
                previousResultIds: convertPreviousResultIds(resultIds2),
                partialResultToken
              };
              return this.client.sendRequest(vscode_languageserver_protocol_1.Proposed.WorkspaceDiagnosticRequest.type, params, token2).then((result2) => {
                const converted = {
                  items: []
                };
                for (const item of result2.items) {
                  converted.items.push(convertReport(item));
                }
                disposable.dispose();
                resultReporter(converted);
                return { items: [] };
              }, (error) => {
                disposable.dispose();
                return this.client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type, token2, error, { items: [] });
              });
            };
            const middleware = this.client.clientOptions.middleware;
            return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics) : provideDiagnostics(resultIds, token, resultReporter);
          };
        }
        return result;
      }
      dispose() {
        this.isDisposed = true;
        this.workspaceCancellation?.cancel();
        this.workspaceTimeout?.dispose();
        for (const [key, request] of this.openRequests) {
          if (request.state === RequestStateKind.active) {
            request.tokenSource.cancel();
          }
          this.openRequests.set(key, { state: RequestStateKind.outDated, textDocument: request.textDocument });
        }
      }
    };
    var BackgroundScheduler = class {
      constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new vscode_languageserver_protocol_1.LinkedMap();
      }
      add(textDocument) {
        const key = textDocument.uri.toString();
        if (this.documents.has(key)) {
          return;
        }
        this.documents.set(textDocument.uri.toString(), textDocument, vscode_languageserver_protocol_1.Touch.Last);
        this.trigger();
      }
      remove(textDocument) {
        const key = textDocument.uri.toString();
        if (this.documents.has(key)) {
          this.documents.delete(key);
          this.diagnosticRequestor.pull(textDocument);
        }
        if (this.documents.size === 0) {
          this.stop();
        } else if (textDocument === this.endDocument) {
          this.endDocument = this.documents.last;
        }
      }
      trigger() {
        if (this.intervalHandle !== void 0) {
          this.endDocument = this.documents.last;
          return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
          const document = this.documents.first;
          if (document !== void 0) {
            this.diagnosticRequestor.pull(document);
            this.documents.set(document.uri.toString(), document, vscode_languageserver_protocol_1.Touch.Last);
            if (document === this.endDocument) {
              this.stop();
            }
          }
        }, 200);
      }
      dispose() {
        this.stop();
        this.documents.clear();
      }
      stop() {
        this.intervalHandle?.dispose();
        this.intervalHandle = void 0;
        this.endDocument = void 0;
      }
    };
    var DiagnosticFeatureProviderImpl = class {
      constructor(client, editorTracker, options) {
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
        const documentSelector = options.documentSelector;
        const disposables = [];
        const matches = (textDocument) => {
          return client_1.$DocumentSelector.matchForProvider(documentSelector, textDocument) && editorTracker.isVisible(textDocument);
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, editorTracker, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (textDocument) => {
          if (!matches(textDocument) || !options.interFileDependencies || this.activeTextDocument === textDocument) {
            return;
          }
          this.backgroundScheduler.add(textDocument);
        };
        this.activeTextDocument = vscode_1.window.activeTextEditor?.document;
        vscode_1.window.onDidChangeActiveTextEditor((editor) => {
          const oldActive = this.activeTextDocument;
          this.activeTextDocument = editor?.document;
          if (oldActive !== void 0) {
            addToBackgroundIfNeeded(oldActive);
          }
          if (this.activeTextDocument !== void 0) {
            this.backgroundScheduler.remove(this.activeTextDocument);
          }
        });
        const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
          const textDocument = event.original;
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }));
        for (const textDocument of vscode_1.workspace.textDocuments) {
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }
        if (diagnosticPullOptions.onChange) {
          const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
          disposables.push(changeFeature.onNotificationSent(async (event) => {
            const textDocument = event.original.document;
            if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, client_1.DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument) && event.original.contentChanges.length > 0) {
              this.diagnosticRequestor.pull(textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        if (diagnosticPullOptions.onSave) {
          const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
          disposables.push(saveFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if ((diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, client_1.DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
              this.diagnosticRequestor.pull(event.original, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
          const textDocument = event.original;
          this.diagnosticRequestor.cleanupPull(textDocument);
          this.backgroundScheduler.remove(textDocument);
        }));
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
          for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument);
            }
          }
        });
        if (options.workspaceDiagnostics === true && options.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
          this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
      }
      get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
      }
      get diagnostics() {
        return this.diagnosticRequestor.provider;
      }
    };
    var DiagnosticFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type);
        this.editorTracker = new EditorTracker();
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
        capability.dynamicRegistration = true;
        capability.relatedDocumentSupport = false;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.Proposed.DiagnosticRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeDiagnosticsEmitter.fire();
          }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      dispose() {
        this.editorTracker.dispose();
        super.dispose();
      }
      registerLanguageProvider(options) {
        const provider = new DiagnosticFeatureProviderImpl(this._client, this.editorTracker, options);
        return [provider.disposable, provider];
      }
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/proposed.typeHierarchy.js
var require_proposed_typeHierarchy2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/proposed.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var TypeHierarchyProvider = class {
      constructor(client, options) {
        this.client = client;
        this.options = options;
        this.middleware = client.clientOptions.middleware;
      }
      prepareTypeHierarchy(document, position, token) {
        if (client_1.$DocumentSelector.skipCellTextDocument(this.options.documentSelector, document)) {
          return void 0;
        }
        const client = this.client;
        const middleware = this.middleware;
        const prepareTypeHierarchy = (document2, position2, token2) => {
          const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document2, position2);
          return client.sendRequest(vscode_languageserver_protocol_1.Proposed.TypeHierarchyPrepareRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asTypeHierarchyItems(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.TypeHierarchyPrepareRequest.type, token2, error, null);
          });
        };
        return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document, position, token);
      }
      provideTypeHierarchySupertypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySupertypes = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.Proposed.TypeHierarchySupertypesRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asTypeHierarchyItems(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.TypeHierarchySupertypesRequest.type, token2, error, null);
          });
        };
        return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
      }
      provideTypeHierarchySubtypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySubtypes = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asTypeHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.Proposed.TypeHierarchySubtypesRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asTypeHierarchyItems(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.TypeHierarchySubtypesRequest.type, token2, error, null);
          });
        };
        return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
      }
    };
    var TypeHierarchyFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.Proposed.TypeHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure(ensure(capabilities, "textDocument"), "typeHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const client = this._client;
        const provider = new TypeHierarchyProvider(client, options);
        return [vscode_1.languages.registerTypeHierarchyProvider(client_1.$DocumentSelector.asTextDocumentFilters(options.documentSelector), provider), provider];
      }
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/proposed.inlineValues.js
var require_proposed_inlineValues = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/proposed.inlineValues.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_1 = require("vscode");
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = /* @__PURE__ */ Object.create(null);
      }
      return target[key];
    }
    var InlineValueFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.Proposed.InlineValuesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "inlineValues").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.Proposed.InlineValuesRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlineValues.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlineValuesProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
          onDidChangeInlineValues: eventEmitter.event,
          provideInlineValues: (document, viewPort, context, token) => {
            if (client_1.$DocumentSelector.skipCellTextDocument(selector, document)) {
              return void 0;
            }
            const client = this._client;
            const provideInlineValues = (document2, viewPort2, context2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document2),
                viewPort: client.code2ProtocolConverter.asRange(viewPort2),
                context: client.code2ProtocolConverter.asInlineValuesContext(context2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.Proposed.InlineValuesRequest.type, requestParams, token2).then((values) => client.protocol2CodeConverter.asInlineValues(values), (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.InlineValuesRequest.type, token2, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideInlineValues ? middleware.provideInlineValues(document, viewPort, context, token, provideInlineValues) : provideInlineValues(document, viewPort, context, token);
          }
        };
        return [vscode_1.languages.registerInlineValuesProvider(client_1.$DocumentSelector.asTextDocumentFilters(selector), provider), { provider, onDidChangeInlineValues: eventEmitter }];
      }
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/proposed.notebooks.js
var require_proposed_notebooks2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/proposed.notebooks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocumentSyncFeature = void 0;
    var vscode2 = require("vscode");
    var minimatch = require_minimatch();
    var proto = require_main2();
    var vscode_languageserver_protocol_1 = require_main2();
    var client_1 = require_client();
    var UUID = require_uuid();
    var Is3 = require_is();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var Converter;
    (function(Converter2) {
      let c2p;
      (function(c2p2) {
        function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
          return {
            version: notebookDocument.version,
            uri: base.asUri(notebookDocument.uri)
          };
        }
        c2p2.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
        function asNotebookDocument(notebookDocument, cells, base) {
          const result = proto.Proposed.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
          if (Object.keys(notebookDocument.metadata).length > 0) {
            result.metadata = asMetadata(notebookDocument.metadata);
          }
          return result;
        }
        c2p2.asNotebookDocument = asNotebookDocument;
        function asNotebookCells(cells, base) {
          return cells.map((cell) => asNotebookCell(cell, base));
        }
        c2p2.asNotebookCells = asNotebookCells;
        function asMetadata(metadata) {
          const seen = /* @__PURE__ */ new Set();
          return deepCopy(seen, metadata);
        }
        c2p2.asMetadata = asMetadata;
        function asNotebookCell(cell, base) {
          const result = proto.Proposed.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
          if (Object.keys(cell.metadata).length > 0) {
            result.metadata = asMetadata(cell.metadata);
          }
          if (cell.executionSummary !== void 0 && (Is3.number(cell.executionSummary.executionOrder) && Is3.boolean(cell.executionSummary.success))) {
            result.executionSummary = {
              executionOrder: cell.executionSummary.executionOrder,
              success: cell.executionSummary.success
            };
          }
          return result;
        }
        c2p2.asNotebookCell = asNotebookCell;
        function asNotebookCellKind(kind) {
          switch (kind) {
            case vscode2.NotebookCellKind.Markup:
              return proto.Proposed.NotebookCellKind.Markup;
            case vscode2.NotebookCellKind.Code:
              return proto.Proposed.NotebookCellKind.Code;
          }
        }
        function deepCopy(seen, value) {
          if (seen.has(value)) {
            throw new Error(`Can't deep copy cyclic structures.`);
          }
          if (Array.isArray(value)) {
            const result = [];
            for (const elem of value) {
              if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                result.push(deepCopy(seen, elem));
              } else {
                if (elem instanceof RegExp) {
                  throw new Error(`Can't transfer regular expressions to the server`);
                }
                result.push(elem);
              }
            }
            return result;
          } else {
            const props = Object.keys(value);
            const result = /* @__PURE__ */ Object.create(null);
            for (const prop of props) {
              const elem = value[prop];
              if (elem !== null && typeof elem === "object" || Array.isArray(elem)) {
                result[prop] = deepCopy(seen, elem);
              } else {
                if (elem instanceof RegExp) {
                  throw new Error(`Can't transfer regular expressions to the server`);
                }
                result[prop] = elem;
              }
            }
            return result;
          }
        }
        function asTextContentChange(event, base) {
          const params = base.asChangeTextDocumentParams(event);
          return { document: params.textDocument, changes: params.contentChanges };
        }
        c2p2.asTextContentChange = asTextContentChange;
      })(c2p = Converter2.c2p || (Converter2.c2p = {}));
    })(Converter || (Converter = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function computeDiff(originalCells, modifiedCells, compareMetadata) {
        const originalLength = originalCells.length;
        const modifiedLength = modifiedCells.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && proto.Proposed.NotebookCell.equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && proto.Proposed.NotebookCell.equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          const deleteCount = originalEndIndex + 1 - startIndex;
          const newCells = startIndex === modifiedEndIndex + 1 ? void 0 : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
          return newCells !== void 0 ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
        } else if (startIndex < modifiedLength) {
          return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
        } else if (startIndex < originalLength) {
          return { start: startIndex, deleteCount: originalLength - startIndex };
        } else {
          return void 0;
        }
      }
      NotebookCell2.computeDiff = computeDiff;
    })(NotebookCell || (NotebookCell = {}));
    var $NotebookDocumentFilter;
    (function($NotebookDocumentFilter2) {
      function matchNotebook(filter, notebookDocument) {
        if (filter.notebookType !== void 0 && notebookDocument.notebookType !== filter.notebookType) {
          return false;
        }
        const uri = notebookDocument.uri;
        if (filter.scheme !== void 0 && uri.scheme !== filter.scheme) {
          return false;
        }
        if (filter.pattern !== void 0) {
          const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
          if (!matcher.makeRe()) {
            return false;
          }
          if (!matcher.match(uri.fsPath)) {
            return false;
          }
        }
        return true;
      }
      $NotebookDocumentFilter2.matchNotebook = matchNotebook;
    })($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
    var $NotebookDocumentSyncOptions;
    (function($NotebookDocumentSyncOptions2) {
      function match(options, cell, mode) {
        if (mode === "cellContent" && !client_1.$DocumentSelector.matchForDocumentSync(options.cellDocumentSelector, cell.document)) {
          return false;
        }
        if (mode === "notebook" && !client_1.$DocumentSelector.matchForProvider(options.cellDocumentSelector, cell.document)) {
          return false;
        }
        const notebook = cell.notebook;
        for (const filter of options.notebookDocumentSelector) {
          if (filter.notebookDocumentFilter !== void 0 && $NotebookDocumentFilter.matchNotebook(filter.notebookDocumentFilter, notebook)) {
            return true;
          }
        }
        return false;
      }
      $NotebookDocumentSyncOptions2.match = match;
    })($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
    var SyncInfo;
    (function(SyncInfo2) {
      function create(proto2, code) {
        return {
          cells: proto2,
          uris: new Set(code.map((cell) => cell.document.uri.toString()))
        };
      }
      SyncInfo2.create = create;
    })(SyncInfo || (SyncInfo = {}));
    var NotebookDocumentSyncFeatureProvider = class {
      constructor(client, options) {
        this.client = client;
        this.options = options;
        this.notebookSyncInfo = /* @__PURE__ */ new Map();
        this.cellExecutionState = /* @__PURE__ */ new Map();
        this.notebookDidOpen = /* @__PURE__ */ new Set();
        this.disposables = [];
        vscode2.workspace.onDidOpenNotebookDocument((notebookDocument) => {
          this.notebookDidOpen.add(notebookDocument.uri.toString());
          this.didOpen(notebookDocument);
        }, void 0, this.disposables);
        for (const notebookDocument of vscode2.workspace.notebookDocuments) {
          this.notebookDidOpen.add(notebookDocument.uri.toString());
          this.didOpen(notebookDocument);
        }
        vscode2.notebooks.onDidChangeNotebookDocumentMetadata((event) => this.notebookDocumentMetadataChanged(event.document), void 0, this.disposables);
        vscode2.notebooks.onDidChangeNotebookCells((event) => this.cellStructureChanged(event.document), void 0, this.disposables);
        vscode2.notebooks.onDidChangeCellMetadata((event) => this.cellMetaDataChanged(event.cell.notebook, event.cell), void 0, this.disposables);
        vscode2.notebooks.onDidChangeNotebookCellExecutionState((event) => this.cellExecutionStateChanged(event), void 0, this.disposables);
        if (this.options.save === true) {
          vscode2.notebooks.onDidSaveNotebookDocument((notebookDocument) => this.didSave(notebookDocument), void 0, this.disposables);
        }
        vscode2.workspace.onDidCloseNotebookDocument((notebookDocument) => {
          this.didClose(notebookDocument);
          this.notebookDidOpen.delete(notebookDocument.uri.toString());
        }, void 0, this.disposables);
      }
      get mode() {
        return "notebook";
      }
      handles(notebookCell) {
        return $NotebookDocumentSyncOptions.match(this.options, notebookCell, this.mode);
      }
      didOpenNotebookCellDocument(notebookDocument, cell) {
        if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
          return;
        }
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        const cells = this.getMatchingCells(notebookDocument, [cell]);
        const cellMatches = cells !== void 0 && cells[0] === cell;
        if (syncInfo !== void 0) {
          const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
          if (cellMatches && cellIsSynced) {
            return;
          }
          this.cellStructureChanged(notebookDocument, syncInfo);
        } else {
          if (!cellMatches) {
            return;
          }
          this.cellStructureChanged(notebookDocument, syncInfo);
        }
      }
      didChangeCellTextDocument(notebookDocument, event) {
        if (!client_1.$DocumentSelector.matchForProvider(this.options.cellDocumentSelector, event.document)) {
          return;
        }
        this.doSendChange(notebookDocument, {
          cells: { textContent: [Converter.c2p.asTextContentChange(event, this.client.code2ProtocolConverter)] }
        }).catch(() => {
        });
      }
      dispose() {
        for (const disposable of this.disposables) {
          disposable.dispose();
        }
      }
      didOpen(notebookDocument, optionalCells = null, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo !== void 0) {
          this.cellStructureChanged(notebookDocument, syncInfo);
        } else {
          const cells = optionalCells ?? this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            return;
          }
          this.doSendOpen(notebookDocument, cells, (nb) => {
            this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(nb.cells, cells));
          }).catch(() => {
          });
        }
      }
      notebookDocumentMetadataChanged(notebookDocument) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          return;
        }
        this.doSendChange(notebookDocument, {
          metadata: Converter.c2p.asMetadata(notebookDocument.metadata)
        }).catch(() => {
        });
      }
      cellStructureChanged(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo === void 0) {
          const cells = this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            return;
          }
          this.didOpen(notebookDocument, cells, syncInfo);
        } else {
          const cells = this.getMatchingCells(notebookDocument);
          if (cells === void 0) {
            this.didClose(notebookDocument, syncInfo);
            return;
          }
          const oldCells = syncInfo.cells;
          const newCells = Converter.c2p.asNotebookCells(cells, this.client.code2ProtocolConverter);
          const diff = NotebookCell.computeDiff(syncInfo.cells, newCells, false);
          if (diff === void 0) {
            return;
          }
          const deletedCells = diff.deleteCount === 0 ? /* @__PURE__ */ new Set() : new Set(oldCells.slice(diff.start, diff.start + diff.deleteCount).map((cell) => cell.document));
          const insertedCells = diff.cells === void 0 ? /* @__PURE__ */ new Set() : new Set(diff.cells.map((cell) => cell.document));
          for (const key of Array.from(deletedCells.values())) {
            if (insertedCells.has(key)) {
              deletedCells.delete(key);
              insertedCells.delete(key);
            }
          }
          const didOpen = [];
          const didClose = [];
          if (deletedCells.size > 0 || insertedCells.size > 0) {
            const codeCells = new Map(cells.map((cell) => [this.client.code2ProtocolConverter.asUri(cell.document.uri), cell]));
            for (const document of insertedCells.values()) {
              const cell = codeCells.get(document);
              if (cell !== void 0) {
                didOpen.push(this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
              }
            }
            for (const document of deletedCells.values()) {
              didClose.push({ uri: document });
            }
          }
          this.doSendChange(notebookDocument, { cells: { structure: {
            array: diff,
            didClose: didClose.length > 0 ? didClose : void 0,
            didOpen: didOpen.length > 0 ? didOpen : void 0
          } } }).catch(() => {
          });
          this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(newCells, cells));
        }
      }
      cellMetaDataChanged(notebookDocument, cell) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          return;
        }
        if (!syncInfo.uris.has(cell.document.uri.toString())) {
          return;
        }
        const pc = Converter.c2p.asNotebookCell(cell, this.client.code2ProtocolConverter);
        this.doSendChange(notebookDocument, { cells: { data: [pc] } }).catch(() => {
        });
      }
      cellExecutionStateChanged(event) {
        if (event.state === vscode2.NotebookCellExecutionState.Pending) {
          return;
        }
        const notebookDocument = event.cell.notebook;
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          return;
        }
        const cellUri = event.cell.document.uri.toString();
        if (!syncInfo.uris.has(cellUri)) {
          return;
        }
        if (event.state === vscode2.NotebookCellExecutionState.Executing) {
          this.cellExecutionState.set(event.cell.document.uri.toString(), event.state);
        }
        if (event.state === vscode2.NotebookCellExecutionState.Idle) {
          if (this.cellExecutionState.has(cellUri)) {
            this.cellExecutionState.delete(cellUri);
            this.doSendChange(notebookDocument, { cells: { data: [Converter.c2p.asNotebookCell(event.cell, this.client.code2ProtocolConverter)] } }).catch(() => {
            });
          }
        }
      }
      didSave(notebookDocument) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === void 0) {
          return;
        }
        this.doSendSave(notebookDocument).catch(() => {
        });
      }
      didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo === void 0) {
          return;
        }
        const syncedCells = notebookDocument.getCells().filter((cell) => syncInfo.uris.has(cell.document.uri.toString()));
        this.doSendClose(notebookDocument, syncedCells).catch(() => {
        });
        this.notebookSyncInfo.delete(notebookDocument.uri.toString());
      }
      getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
        if (this.options.notebookDocumentSelector === void 0) {
          return void 0;
        }
        for (const item of this.options.notebookDocumentSelector) {
          if (item.notebookDocumentFilter === void 0) {
            if (item.cellSelector === void 0) {
              return void 0;
            }
            const filtered = this.filterCells(cells, item.cellSelector);
            return filtered.length === 0 ? void 0 : filtered;
          } else if ($NotebookDocumentFilter.matchNotebook(item.notebookDocumentFilter, notebookDocument)) {
            return item.cellSelector === void 0 ? cells : this.filterCells(cells, item.cellSelector);
          }
        }
        return void 0;
      }
      filterCells(cells, cellSelector) {
        return cells.filter((cell) => {
          const cellLanguage = cell.document.languageId;
          return cellSelector.some((filter) => cellLanguage === filter.language);
        });
      }
      async sendDidOpenNotebookDocument(notebookDocument) {
        const cells = this.getMatchingCells(notebookDocument);
        if (cells === void 0) {
          return;
        }
        return this.doSendOpen(notebookDocument, cells);
      }
      async doSendOpen(notebookDocument, cells, cb) {
        const send = (notebookDocument2, cells2) => {
          const nb = Converter.c2p.asNotebookDocument(notebookDocument2, cells2, this.client.code2ProtocolConverter);
          const cellDocuments = cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
          const result = this.client.sendNotification(proto.Proposed.DidOpenNotebookDocumentNotification.type, {
            notebookDocument: nb,
            cellTextDocuments: cellDocuments
          }).catch((error) => {
            this.client.error("Sending DidOpenNotebookDocumentNotification failed", error);
            throw error;
          });
          cb && cb(nb);
          return result;
        };
        const middleware = this.client.clientOptions.middleware?.notebooks;
        return middleware?.didOpen !== void 0 ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
      }
      async sendDidChangeNotebookDocument(notebookDocument, changeData) {
        const changeEvent = /* @__PURE__ */ Object.create(null);
        if (changeData.metadata) {
          changeEvent.metadata = Converter.c2p.asMetadata(notebookDocument.metadata);
        }
        if (changeData.cells !== void 0) {
          const cells = /* @__PURE__ */ Object.create(null);
          const changedCells = changeData.cells;
          if (changedCells.structure) {
            cells.structure = {
              array: {
                start: changedCells.structure.array.start,
                deleteCount: changedCells.structure.array.deleteCount,
                cells: changedCells.structure.array.cells !== void 0 ? changedCells.structure.array.cells.map((cell) => Converter.c2p.asNotebookCell(cell, this.client.code2ProtocolConverter)) : void 0
              },
              didOpen: changedCells.structure.didOpen !== void 0 ? changedCells.structure.didOpen.map((cell) => this.client.code2ProtocolConverter.asOpenTextDocumentParams(cell.document).textDocument) : void 0,
              didClose: changedCells.structure.didClose !== void 0 ? changedCells.structure.didClose.map((cell) => this.client.code2ProtocolConverter.asCloseTextDocumentParams(cell.document).textDocument) : void 0
            };
          }
          if (changedCells.data !== void 0) {
            cells.data = changedCells.data.map((cell) => Converter.c2p.asNotebookCell(cell, this.client.code2ProtocolConverter));
          }
          if (changedCells.textContent !== void 0) {
            cells.textContent = changedCells.textContent.map((event) => Converter.c2p.asTextContentChange(event, this.client.code2ProtocolConverter));
          }
          if (Object.keys(cells).length > 0) {
            changeEvent.cells = cells;
          }
        }
        if (Object.keys(changeEvent).length > 0) {
          return this.doSendChange(notebookDocument, changeEvent);
        }
      }
      async doSendChange(notebookDocument, change) {
        const send = (notebookDocument2, change2) => {
          return this.client.sendNotification(proto.Proposed.DidChangeNotebookDocumentNotification.type, {
            notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(notebookDocument2, this.client.code2ProtocolConverter),
            change: change2
          }).catch((error) => {
            this.client.error("Sending DidChangeNotebookDocumentNotification failed", error);
          });
        };
        const middleware = this.client.clientOptions.middleware?.notebooks;
        return middleware?.didChange !== void 0 ? middleware?.didChange(notebookDocument, change, send) : send(notebookDocument, change);
      }
      async sendDidSaveNotebookDocument(notebookDocument) {
        return this.doSendSave(notebookDocument);
      }
      async doSendSave(notebookDocument) {
        const send = (notebookDocument2) => {
          return this.client.sendNotification(proto.Proposed.DidSaveNotebookDocumentNotification.type, {
            notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) }
          }).catch((error) => {
            this.client.error("Sending DidSaveNotebookDocumentNotification failed", error);
            throw error;
          });
        };
        const middleware = this.client.clientOptions.middleware?.notebooks;
        return middleware?.didSave !== void 0 ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
      }
      async sendDidSelectNotebookController(notebookDocument, controller, selected) {
        const send = (notebookDocument2, controller2, selected2) => {
          return this.client.sendNotification(proto.Proposed.DidSelectNotebookControllerNotification.type, {
            notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) },
            controller: controller2,
            selected: selected2
          }).catch((error) => {
            this.client.error("Sending DidSelectNotebookControllerNotification failed", error);
            throw error;
          });
        };
        const middleware = this.client.clientOptions.middleware?.notebooks;
        return middleware?.didSelectNotebookController !== void 0 ? middleware.didSelectNotebookController(notebookDocument, controller, selected, send) : send(notebookDocument, controller, selected);
      }
      async sendDidCloseNotebookDocument(notebookDocument) {
        return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
      }
      async doSendClose(notebookDocument, cells) {
        const send = (notebookDocument2, cells2) => {
          return this.client.sendNotification(proto.Proposed.DidCloseNotebookDocumentNotification.type, {
            notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument2.uri) },
            cellTextDocuments: cells2.map((cell) => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
          }).catch((error) => {
            this.client.error("Sending DidCloseNotebookDocumentNotification failed", error);
            throw error;
          });
        };
        const middleware = this.client.clientOptions.middleware?.notebooks;
        return middleware?.didClose !== void 0 ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
      }
    };
    var NotebookCellTextDocumentSyncFeatureProvider = class {
      constructor(client, options) {
        this.client = client;
        this.options = options;
        if (options.cellDocumentSelector.length > 0) {
          const openId = UUID.generateUuid();
          this.client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method).register({
            id: openId,
            registerOptions: { documentSelector: options.cellDocumentSelector }
          });
          const changeId = UUID.generateUuid();
          this.client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method).register({
            id: changeId,
            registerOptions: { documentSelector: options.cellDocumentSelector, syncKind: vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental }
          });
          const closeId = UUID.generateUuid();
          this.client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method).register({
            id: closeId,
            registerOptions: { documentSelector: options.cellDocumentSelector }
          });
          this.registrations = { open: openId, change: changeId, close: closeId };
        }
      }
      get mode() {
        return "cellContent";
      }
      handles(notebookCell) {
        return $NotebookDocumentSyncOptions.match(this.options, notebookCell, this.mode);
      }
      dispose() {
        if (this.registrations !== void 0) {
          this.client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method).unregister(this.registrations.open);
          this.client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method).unregister(this.registrations.change);
          this.client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method).unregister(this.registrations.close);
        }
      }
      async sendDidOpenTextDocument(textDocument) {
        const provider = this.client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method).getProvider(textDocument);
        return provider !== void 0 ? provider.send(textDocument) : Promise.reject(new Error(`No open provider found for notebook cell document ${textDocument.uri.toString()}`));
      }
      async sendDidChangeTextDocument(event) {
        const provider = this.client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method).getProvider(event.document);
        return provider !== void 0 ? provider.send(event) : Promise.reject(new Error(`No change provider found for notebook cell document ${event.document.uri.toString()}`));
      }
      async sendDidCloseTextDocument(textDocument) {
        const provider = this.client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method).getProvider(textDocument);
        return provider !== void 0 ? provider.send(textDocument) : Promise.reject(new Error(`No close provider found for notebook cell document ${textDocument.uri.toString()}`));
      }
    };
    var NotebookDocumentSyncFeature = class {
      constructor(client) {
        this.client = client;
        this.registrations = /* @__PURE__ */ new Map();
        this.registrationType = proto.Proposed.NotebookDocumentSyncRegistrationType.type;
        vscode2.workspace.onDidOpenTextDocument((textDocument) => {
          if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return;
          }
          const [notebookDocument, notebookCell] = this.getNotebookDocument(textDocument);
          if (notebookDocument === void 0 || notebookCell === void 0) {
            return;
          }
          for (const provider of this.registrations.values()) {
            if (provider instanceof NotebookDocumentSyncFeatureProvider) {
              provider.didOpenNotebookCellDocument(notebookDocument, notebookCell);
            }
          }
        });
        vscode2.workspace.onDidChangeTextDocument((event) => {
          if (event.contentChanges.length === 0) {
            return;
          }
          const textDocument = event.document;
          if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return;
          }
          const [notebookDocument] = this.getNotebookDocument(textDocument);
          if (notebookDocument === void 0) {
            return;
          }
          for (const provider of this.registrations.values()) {
            if (provider instanceof NotebookDocumentSyncFeatureProvider) {
              provider.didChangeCellTextDocument(notebookDocument, event);
            }
          }
        });
      }
      fillClientCapabilities(capabilities) {
        const synchronization = ensure(ensure(capabilities, "notebookDocument"), "synchronization");
        synchronization.dynamicRegistration = true;
      }
      initialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === void 0) {
          return;
        }
        const id = options.id ?? UUID.generateUuid();
        this.register({ id, registerOptions: options });
      }
      register(data) {
        if (data.registerOptions.mode === "cellContent") {
          const options = Object.assign({}, data.registerOptions, { cellDocumentSelector: this.getNotebookCellTextDocumentFilter(data.registerOptions, true) });
          const provider = new NotebookCellTextDocumentSyncFeatureProvider(this.client, options);
          this.registrations.set(data.id, provider);
        } else {
          const options = Object.assign({}, data.registerOptions, { cellDocumentSelector: this.getNotebookCellTextDocumentFilter(data.registerOptions) });
          const provider = new NotebookDocumentSyncFeatureProvider(this.client, options);
          this.registrations.set(data.id, provider);
        }
      }
      unregister(id) {
        const provider = this.registrations.get(id);
        provider && provider.dispose();
      }
      dispose() {
        for (const provider of this.registrations.values()) {
          provider.dispose();
        }
        this.registrations.clear();
      }
      getProvider(notebookCell) {
        for (const provider of this.registrations.values()) {
          if (provider.handles(notebookCell)) {
            return provider;
          }
        }
        return void 0;
      }
      getNotebookDocument(textDocument) {
        const uri = textDocument.uri.toString();
        for (const notebookDocument of vscode2.workspace.notebookDocuments) {
          for (const cell of notebookDocument.getCells()) {
            if (cell.document.uri.toString() === uri) {
              return [notebookDocument, cell];
            }
          }
        }
        return [void 0, void 0];
      }
      getNotebookCellTextDocumentFilter(options, sync) {
        const documentSelector = [];
        for (const item of options.notebookDocumentSelector) {
          let nf;
          if (item.notebookDocumentFilter !== void 0) {
            nf = sync === true ? { notebookDocument: Object.assign({}, item.notebookDocumentFilter, { sync: true }) } : { notebookDocument: Object.assign({}, item.notebookDocumentFilter) };
          }
          if (item.cellSelector !== void 0) {
            for (const cell of item.cellSelector) {
              if (nf === void 0) {
                documentSelector.push(sync === true ? { cellLanguage: cell.language, sync: true } : { cellLanguage: cell.language });
              } else {
                documentSelector.push(Object.assign({}, nf, { cellLanguage: cell.language }));
              }
            }
            nf = void 0;
          } else if (nf !== void 0) {
            documentSelector.push(nf);
          }
        }
        return documentSelector;
      }
    };
    exports2.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
    NotebookDocumentSyncFeature.CellScheme = "vscode-notebook-cell";
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/commonClient.js
var require_commonClient = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/commonClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.CommonLanguageClient = void 0;
    var client_1 = require_client();
    var colorProvider_1 = require_colorProvider();
    var configuration_1 = require_configuration();
    var implementation_1 = require_implementation();
    var typeDefinition_1 = require_typeDefinition();
    var workspaceFolders_1 = require_workspaceFolders();
    var foldingRange_1 = require_foldingRange();
    var declaration_1 = require_declaration();
    var selectionRange_1 = require_selectionRange();
    var progress_1 = require_progress();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var CommonLanguageClient = class extends client_1.BaseLanguageClient {
      constructor(id, name, clientOptions) {
        super(id, name, clientOptions);
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        if (this.clientOptions.workspaceFolder === void 0) {
          this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
        }
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
      }
    };
    exports2.CommonLanguageClient = CommonLanguageClient;
    var pd = require_proposed_diagnostic2();
    var pt = require_proposed_typeHierarchy2();
    var iv = require_proposed_inlineValues();
    var nb = require_proposed_notebooks2();
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      function createAll(client) {
        let result = [
          new pd.DiagnosticFeature(client),
          new pt.TypeHierarchyFeature(client),
          new iv.InlineValueFeature(client),
          new nb.NotebookDocumentSyncFeature(client)
        ];
        return result;
      }
      ProposedFeatures2.createAll = createAll;
      function createDiagnosticFeature(client) {
        return new pd.DiagnosticFeature(client);
      }
      ProposedFeatures2.createDiagnosticFeature = createDiagnosticFeature;
      function createTypeHierarchyFeature(client) {
        return new pt.TypeHierarchyFeature(client);
      }
      ProposedFeatures2.createTypeHierarchyFeature = createTypeHierarchyFeature;
      function createInlineValueFeature(client) {
        return new iv.InlineValueFeature(client);
      }
      ProposedFeatures2.createInlineValueFeature = createInlineValueFeature;
      function createNotebookDocumentSyncFeature(client) {
        return new nb.NotebookDocumentSyncFeature(client);
      }
      ProposedFeatures2.createNotebookDocumentSyncFeature = createNotebookDocumentSyncFeature;
    })(ProposedFeatures = exports2.ProposedFeatures || (exports2.ProposedFeatures = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/node/processes.js
var require_processes = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/node/processes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.terminate = void 0;
    var cp = require("child_process");
    var path_1 = require("path");
    var isWindows = process.platform === "win32";
    var isMacintosh = process.platform === "darwin";
    var isLinux = process.platform === "linux";
    function terminate(process2, cwd) {
      if (isWindows) {
        try {
          let options = {
            stdio: ["pipe", "pipe", "ignore"]
          };
          if (cwd) {
            options.cwd = cwd;
          }
          cp.execFileSync("taskkill", ["/T", "/F", "/PID", process2.pid.toString()], options);
          return true;
        } catch (err) {
          return false;
        }
      } else if (isLinux || isMacintosh) {
        try {
          var cmd = (0, path_1.join)(__dirname, "terminateProcess.sh");
          var result = cp.spawnSync(cmd, [process2.pid.toString()]);
          return result.error ? false : true;
        } catch (err) {
          return false;
        }
      } else {
        process2.kill("SIGKILL");
        return true;
      }
    }
    exports2.terminate = terminate;
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageserver-protocol@3.17.0-next.14/node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main2();
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/api.js
var require_api3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_main2(), exports2);
    __exportStar(require_client(), exports2);
    __exportStar(require_commonClient(), exports2);
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/node/main.js
var require_main3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SettingMonitor = exports2.LanguageClient = exports2.TransportKind = void 0;
    var cp = require("child_process");
    var fs = require("fs");
    var path = require("path");
    var SemVer = require_semver2();
    var vscode_1 = require("vscode");
    var Is3 = require_is();
    var commonClient_1 = require_commonClient();
    var client_1 = require_client();
    var processes_1 = require_processes();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var REQUIRED_VSCODE_VERSION = "^1.63.0";
    var TransportKind;
    (function(TransportKind2) {
      TransportKind2[TransportKind2["stdio"] = 0] = "stdio";
      TransportKind2[TransportKind2["ipc"] = 1] = "ipc";
      TransportKind2[TransportKind2["pipe"] = 2] = "pipe";
      TransportKind2[TransportKind2["socket"] = 3] = "socket";
    })(TransportKind = exports2.TransportKind || (exports2.TransportKind = {}));
    var Transport;
    (function(Transport2) {
      function isSocket(value) {
        const candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is3.number(candidate.port);
      }
      Transport2.isSocket = isSocket;
    })(Transport || (Transport = {}));
    var Executable;
    (function(Executable2) {
      function is(value) {
        return Is3.string(value.command);
      }
      Executable2.is = is;
    })(Executable || (Executable = {}));
    var NodeModule;
    (function(NodeModule2) {
      function is(value) {
        return Is3.string(value.module);
      }
      NodeModule2.is = is;
    })(NodeModule || (NodeModule = {}));
    var StreamInfo;
    (function(StreamInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
      }
      StreamInfo2.is = is;
    })(StreamInfo || (StreamInfo = {}));
    var ChildProcessInfo;
    (function(ChildProcessInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
      }
      ChildProcessInfo2.is = is;
    })(ChildProcessInfo || (ChildProcessInfo = {}));
    var LanguageClient = class extends commonClient_1.CommonLanguageClient {
      constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is3.string(arg2)) {
          id = arg1;
          name = arg2;
          serverOptions = arg3;
          clientOptions = arg4;
          forceDebug = !!arg5;
        } else {
          id = arg1.toLowerCase();
          name = arg1;
          serverOptions = arg2;
          clientOptions = arg3;
          forceDebug = arg4;
        }
        if (forceDebug === void 0) {
          forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this._isInDebugMode = forceDebug;
        try {
          this.checkVersion();
        } catch (error) {
          if (Is3.string(error.message)) {
            this.outputChannel.appendLine(error.message);
          }
          throw error;
        }
      }
      checkVersion() {
        const codeVersion = SemVer.parse(vscode_1.version);
        if (!codeVersion) {
          throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
          codeVersion.prerelease = [];
        }
        if (!SemVer.satisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
          throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
      }
      get isInDebugMode() {
        return this._isInDebugMode;
      }
      async restart() {
        await this.stop();
        if (this.isInDebugMode) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          this.start();
        } else {
          this.start();
        }
      }
      stop(timeout = 2e3) {
        return super.stop(timeout).finally(() => {
          if (this._serverProcess) {
            const toCheck = this._serverProcess;
            this._serverProcess = void 0;
            if (this._isDetached === void 0 || !this._isDetached) {
              this.checkProcessDied(toCheck);
            }
            this._isDetached = void 0;
          }
        });
      }
      checkProcessDied(childProcess) {
        if (!childProcess) {
          return;
        }
        setTimeout(() => {
          try {
            process.kill(childProcess.pid, 0);
            (0, processes_1.terminate)(childProcess);
          } catch (error) {
          }
        }, 2e3);
      }
      handleConnectionClosed() {
        this._serverProcess = void 0;
        super.handleConnectionClosed();
      }
      fillInitializeParams(params) {
        super.fillInitializeParams(params);
        if (params.processId === null) {
          params.processId = process.pid;
        }
      }
      createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
          if (!env && !fork) {
            return void 0;
          }
          const result = /* @__PURE__ */ Object.create(null);
          Object.keys(process.env).forEach((key) => result[key] = process.env[key]);
          if (fork) {
            result["ELECTRON_RUN_AS_NODE"] = "1";
            result["ELECTRON_NO_ASAR"] = "1";
          }
          if (env) {
            Object.keys(env).forEach((key) => result[key] = env[key]);
          }
          return result;
        }
        const debugStartWith = ["--debug=", "--debug-brk=", "--inspect=", "--inspect-brk="];
        const debugEquals = ["--debug", "--debug-brk", "--inspect", "--inspect-brk"];
        function startedInDebugMode() {
          let args = process.execArgv;
          if (args) {
            return args.some((arg) => {
              return debugStartWith.some((value) => arg.startsWith(value)) || debugEquals.some((value) => arg === value);
            });
          }
          return false;
        }
        function assertStdio(process2) {
          if (process2.stdin === null || process2.stdout === null || process2.stderr === null) {
            throw new Error("Process created without stdio streams");
          }
        }
        const server = this._serverOptions;
        if (Is3.func(server)) {
          return server().then((result) => {
            if (client_1.MessageTransports.is(result)) {
              this._isDetached = !!result.detached;
              return result;
            } else if (StreamInfo.is(result)) {
              this._isDetached = !!result.detached;
              return { reader: new node_1.StreamMessageReader(result.reader), writer: new node_1.StreamMessageWriter(result.writer) };
            } else {
              let cp2;
              if (ChildProcessInfo.is(result)) {
                cp2 = result.process;
                this._isDetached = result.detached;
              } else {
                cp2 = result;
                this._isDetached = false;
              }
              cp2.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
              return { reader: new node_1.StreamMessageReader(cp2.stdout), writer: new node_1.StreamMessageWriter(cp2.stdin) };
            }
          });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
          if (this._forceDebug || startedInDebugMode()) {
            json = runDebug.debug;
            this._isInDebugMode = true;
          } else {
            json = runDebug.run;
            this._isInDebugMode = false;
          }
        } else {
          json = server;
        }
        return this._getServerWorkingDir(json.options).then((serverWorkingDir) => {
          if (NodeModule.is(json) && json.module) {
            let node = json;
            let transport = node.transport || TransportKind.stdio;
            if (node.runtime) {
              const args = [];
              const options = node.options ?? /* @__PURE__ */ Object.create(null);
              if (options.execArgv) {
                options.execArgv.forEach((element) => args.push(element));
              }
              args.push(node.module);
              if (node.args) {
                node.args.forEach((element) => args.push(element));
              }
              const execOptions = /* @__PURE__ */ Object.create(null);
              execOptions.cwd = serverWorkingDir;
              execOptions.env = getEnvironment(options.env, false);
              const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
              let pipeName = void 0;
              if (transport === TransportKind.ipc) {
                execOptions.stdio = [null, null, null, "ipc"];
                args.push("--node-ipc");
              } else if (transport === TransportKind.stdio) {
                args.push("--stdio");
              } else if (transport === TransportKind.pipe) {
                pipeName = (0, node_1.generateRandomPipeName)();
                args.push(`--pipe=${pipeName}`);
              } else if (Transport.isSocket(transport)) {
                args.push(`--socket=${transport.port}`);
              }
              args.push(`--clientProcessId=${process.pid.toString()}`);
              if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                const serverProcess = cp.spawn(runtime, args, execOptions);
                if (!serverProcess || !serverProcess.pid) {
                  return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                }
                this._serverProcess = serverProcess;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                if (transport === TransportKind.ipc) {
                  serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                  return Promise.resolve({ reader: new node_1.IPCMessageReader(serverProcess), writer: new node_1.IPCMessageWriter(serverProcess) });
                } else {
                  return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                }
              } else if (transport === TransportKind.pipe) {
                return (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                  const process2 = cp.spawn(runtime, args, execOptions);
                  if (!process2 || !process2.pid) {
                    return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                  }
                  this._serverProcess = process2;
                  process2.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                  process2.stdout.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                  return transport2.onConnected().then((protocol) => {
                    return { reader: protocol[0], writer: protocol[1] };
                  });
                });
              } else if (Transport.isSocket(transport)) {
                return (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                  const process2 = cp.spawn(runtime, args, execOptions);
                  if (!process2 || !process2.pid) {
                    return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                  }
                  this._serverProcess = process2;
                  process2.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                  process2.stdout.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                  return transport2.onConnected().then((protocol) => {
                    return { reader: protocol[0], writer: protocol[1] };
                  });
                });
              }
            } else {
              let pipeName = void 0;
              return new Promise((resolve, reject) => {
                const args = (node.args && node.args.slice()) ?? [];
                if (transport === TransportKind.ipc) {
                  args.push("--node-ipc");
                } else if (transport === TransportKind.stdio) {
                  args.push("--stdio");
                } else if (transport === TransportKind.pipe) {
                  pipeName = (0, node_1.generateRandomPipeName)();
                  args.push(`--pipe=${pipeName}`);
                } else if (Transport.isSocket(transport)) {
                  args.push(`--socket=${transport.port}`);
                }
                args.push(`--clientProcessId=${process.pid.toString()}`);
                const options = node.options ?? /* @__PURE__ */ Object.create(null);
                options.env = getEnvironment(options.env, true);
                options.execArgv = options.execArgv || [];
                options.cwd = serverWorkingDir;
                options.silent = true;
                if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                  const sp = cp.fork(node.module, args || [], options);
                  assertStdio(sp);
                  this._serverProcess = sp;
                  sp.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                  if (transport === TransportKind.ipc) {
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                    resolve({ reader: new node_1.IPCMessageReader(this._serverProcess), writer: new node_1.IPCMessageWriter(this._serverProcess) });
                  } else {
                    resolve({ reader: new node_1.StreamMessageReader(sp.stdout), writer: new node_1.StreamMessageWriter(sp.stdin) });
                  }
                } else if (transport === TransportKind.pipe) {
                  (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                    const sp = cp.fork(node.module, args || [], options);
                    assertStdio(sp);
                    this._serverProcess = sp;
                    sp.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                    transport2.onConnected().then((protocol) => {
                      resolve({ reader: protocol[0], writer: protocol[1] });
                    }, reject);
                  }, reject);
                } else if (Transport.isSocket(transport)) {
                  (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                    const sp = cp.fork(node.module, args || [], options);
                    assertStdio(sp);
                    this._serverProcess = sp;
                    sp.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                    sp.stdout.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                    transport2.onConnected().then((protocol) => {
                      resolve({ reader: protocol[0], writer: protocol[1] });
                    }, reject);
                  }, reject);
                }
              });
            }
          } else if (Executable.is(json) && json.command) {
            const command = json;
            const args = json.args !== void 0 ? json.args.slice(0) : [];
            let pipeName = void 0;
            const transport = json.transport;
            if (transport === TransportKind.stdio) {
              args.push("--stdio");
            } else if (transport === TransportKind.pipe) {
              pipeName = (0, node_1.generateRandomPipeName)();
              args.push(`--pipe=${pipeName}`);
            } else if (Transport.isSocket(transport)) {
              args.push(`--socket=${transport.port}`);
            } else if (transport === TransportKind.ipc) {
              throw new Error(`Transport kind ipc is not support for command executable`);
            }
            const options = Object.assign({}, command.options);
            options.cwd = options.cwd || serverWorkingDir;
            if (transport === void 0 || transport === TransportKind.stdio) {
              const serverProcess = cp.spawn(command.command, args, options);
              if (!serverProcess || !serverProcess.pid) {
                return Promise.reject(`Launching server using command ${command.command} failed.`);
              }
              serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
              this._serverProcess = serverProcess;
              this._isDetached = !!options.detached;
              return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
            } else if (transport === TransportKind.pipe) {
              return (0, node_1.createClientPipeTransport)(pipeName).then((transport2) => {
                const serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                  throw new Error(`Launching server using command ${command.command} failed.`);
                }
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                return transport2.onConnected().then((protocol) => {
                  return { reader: protocol[0], writer: protocol[1] };
                });
              });
            } else if (Transport.isSocket(transport)) {
              return (0, node_1.createClientSocketTransport)(transport.port).then((transport2) => {
                const serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                  throw new Error(`Launching server using command ${command.command} failed.`);
                }
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                serverProcess.stderr.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                serverProcess.stdout.on("data", (data) => this.outputChannel.append(Is3.string(data) ? data : data.toString(encoding)));
                return transport2.onConnected().then((protocol) => {
                  return { reader: protocol[0], writer: protocol[1] };
                });
              });
            }
          }
          return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        });
      }
      _getRuntimePath(runtime, serverWorkingDirectory) {
        if (path.isAbsolute(runtime)) {
          return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== void 0) {
          const result = path.join(mainRootPath, runtime);
          if (fs.existsSync(result)) {
            return result;
          }
        }
        if (serverWorkingDirectory !== void 0) {
          const result = path.join(serverWorkingDirectory, runtime);
          if (fs.existsSync(result)) {
            return result;
          }
        }
        return runtime;
      }
      _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        if (folder.uri.scheme === "file") {
          return folder.uri.fsPath;
        }
        return void 0;
      }
      _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
          cwd = this.clientOptions.workspaceFolder ? this.clientOptions.workspaceFolder.uri.fsPath : this._mainGetRootPath();
        }
        if (cwd) {
          return new Promise((s) => {
            fs.lstat(cwd, (err, stats) => {
              s(!err && stats.isDirectory() ? cwd : void 0);
            });
          });
        }
        return Promise.resolve(void 0);
      }
      getLocale() {
        const envValue = process.env["VSCODE_NLS_CONFIG"];
        if (envValue === void 0) {
          return "en";
        }
        let config = void 0;
        try {
          config = JSON.parse(envValue);
        } catch (err) {
        }
        if (config === void 0 || typeof config.locale !== "string") {
          return "en";
        }
        return config.locale;
      }
    };
    exports2.LanguageClient = LanguageClient;
    var SettingMonitor = class {
      constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
      }
      start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
          if (this._client.needsStop()) {
            void this._client.stop();
          }
        });
      }
      onDidChangeConfiguration() {
        let index = this._setting.indexOf(".");
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
          this._client.start();
        } else if (!enabled && this._client.needsStop()) {
          void this._client.stop();
        }
      }
    };
    exports2.SettingMonitor = SettingMonitor;
  }
});

// ../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/node.js
var require_node3 = __commonJS({
  "../../node_modules/.pnpm/vscode-languageclient@8.0.0-next.12/node_modules/vscode-languageclient/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// ../../packages/shared/out/common.js
var require_common = __commonJS({
  "../../packages/shared/out/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLineText = exports2.eqSet = exports2.getOverlapRange = exports2.getWordRange = exports2.isInsideRange = exports2.notEmpty = exports2.languageIdToSyntax = exports2.syntaxToLanguageId = exports2.sleep = void 0;
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    exports2.sleep = sleep;
    function syntaxToLanguageId(syntax) {
      switch (syntax) {
        case "js":
          return "javascript";
        case "ts":
          return "typescript";
        case "jsx":
          return "javascriptreact";
        case "tsx":
          return "typescriptreact";
        case "pug":
          return "jade";
      }
      return syntax;
    }
    exports2.syntaxToLanguageId = syntaxToLanguageId;
    function languageIdToSyntax(languageId) {
      switch (languageId) {
        case "javascript":
          return "js";
        case "typescript":
          return "ts";
        case "javascriptreact":
          return "jsx";
        case "typescriptreact":
          return "tsx";
        case "jade":
          return "pug";
      }
      return languageId;
    }
    exports2.languageIdToSyntax = languageIdToSyntax;
    function notEmpty(value) {
      return value !== null && value !== void 0;
    }
    exports2.notEmpty = notEmpty;
    function isInsideRange(parent, child) {
      if (child.start.line < parent.start.line)
        return false;
      if (child.end.line > parent.end.line)
        return false;
      if (child.start.line === parent.start.line && child.start.character < parent.start.character)
        return false;
      if (child.end.line === parent.end.line && child.end.character > parent.end.character)
        return false;
      return true;
    }
    exports2.isInsideRange = isInsideRange;
    function getWordRange(wordPattern, position, document) {
      const lineStart = {
        line: position.line,
        character: 0
      };
      const lineEnd = {
        line: position.line + 1,
        character: 0
      };
      const offset = document.offsetAt(position);
      const lineStartOffset = document.offsetAt(lineStart);
      const lineText = document.getText({ start: lineStart, end: lineEnd });
      for (const match of lineText.matchAll(wordPattern)) {
        if (match.index === void 0)
          continue;
        const matchStart = match.index + lineStartOffset;
        const matchEnd = matchStart + match[0].length;
        if (offset >= matchStart && offset <= matchEnd) {
          return {
            start: document.positionAt(matchStart),
            end: document.positionAt(matchEnd)
          };
        }
      }
      return void 0;
    }
    exports2.getWordRange = getWordRange;
    function getOverlapRange(range1, range2) {
      const start = {
        line: Math.max(range1.start.line, range2.start.line),
        character: range1.start.line === range2.start.line ? Math.max(range1.start.character, range2.start.character) : range1.start.line > range2.start.line ? range1.start.character : range2.start.character
      };
      const end = {
        line: Math.min(range1.end.line, range2.end.line),
        character: range1.end.line === range2.end.line ? Math.min(range1.end.character, range2.end.character) : range1.end.line < range2.end.line ? range1.end.character : range2.end.character
      };
      if (start.line > end.line || start.line === end.line && start.character > end.character)
        return void 0;
      return {
        start,
        end
      };
    }
    exports2.getOverlapRange = getOverlapRange;
    function eqSet(as, bs) {
      if (as.size !== bs.size)
        return false;
      for (const a of as)
        if (!bs.has(a))
          return false;
      return true;
    }
    exports2.eqSet = eqSet;
    function getLineText(document, line) {
      const text = document.getText({
        start: { line, character: 0 },
        end: { line: line + 1, character: 0 }
      });
      return text.substr(0, text.length - 1);
    }
    exports2.getLineText = getLineText;
  }
});

// ../../node_modules/.pnpm/upath@2.0.1/node_modules/upath/build/code/upath.js
var require_upath = __commonJS({
  "../../node_modules/.pnpm/upath@2.0.1/node_modules/upath/build/code/upath.js"(exports2) {
    var VERSION = "2.0.1";
    var extraFn;
    var extraFunctions;
    var isFunction;
    var isString;
    var isValidExt;
    var name;
    var path;
    var propName;
    var propValue;
    var toUnix;
    var upath;
    var slice = [].slice;
    var indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
    var hasProp = {}.hasOwnProperty;
    path = require("path");
    isFunction = function(val) {
      return typeof val === "function";
    };
    isString = function(val) {
      return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
    };
    upath = exports2;
    upath.VERSION = typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "NO-VERSION";
    toUnix = function(p) {
      p = p.replace(/\\/g, "/");
      p = p.replace(/(?<!^)\/+/g, "/");
      return p;
    };
    for (propName in path) {
      propValue = path[propName];
      if (isFunction(propValue)) {
        upath[propName] = function(propName2) {
          return function() {
            var args, result;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            args = args.map(function(p) {
              if (isString(p)) {
                return toUnix(p);
              } else {
                return p;
              }
            });
            result = path[propName2].apply(path, args);
            if (isString(result)) {
              return toUnix(result);
            } else {
              return result;
            }
          };
        }(propName);
      } else {
        upath[propName] = propValue;
      }
    }
    upath.sep = "/";
    extraFunctions = {
      toUnix,
      normalizeSafe: function(p) {
        var result;
        p = toUnix(p);
        result = upath.normalize(p);
        if (p.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
          result = "./" + result;
        } else if (p.startsWith("//") && !result.startsWith("//")) {
          if (p.startsWith("//./")) {
            result = "//." + result;
          } else {
            result = "/" + result;
          }
        }
        return result;
      },
      normalizeTrim: function(p) {
        p = upath.normalizeSafe(p);
        if (p.endsWith("/")) {
          return p.slice(0, +(p.length - 2) + 1 || 9e9);
        } else {
          return p;
        }
      },
      joinSafe: function() {
        var p, p0, result;
        p = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        result = upath.join.apply(null, p);
        if (p.length > 0) {
          p0 = toUnix(p[0]);
          if (p0.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
            result = "./" + result;
          } else if (p0.startsWith("//") && !result.startsWith("//")) {
            if (p0.startsWith("//./")) {
              result = "//." + result;
            } else {
              result = "/" + result;
            }
          }
        }
        return result;
      },
      addExt: function(file, ext) {
        if (!ext) {
          return file;
        } else {
          if (ext[0] !== ".") {
            ext = "." + ext;
          }
          return file + (file.endsWith(ext) ? "" : ext);
        }
      },
      trimExt: function(filename, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9e9);
        } else {
          return filename;
        }
      },
      removeExt: function(filename, ext) {
        if (!ext) {
          return filename;
        } else {
          ext = ext[0] === "." ? ext : "." + ext;
          if (upath.extname(filename) === ext) {
            return upath.trimExt(filename, [], ext.length);
          } else {
            return filename;
          }
        }
      },
      changeExt: function(filename, ext, ignoreExts, maxSize) {
        if (maxSize == null) {
          maxSize = 7;
        }
        return upath.trimExt(filename, ignoreExts, maxSize) + (!ext ? "" : ext[0] === "." ? ext : "." + ext);
      },
      defaultExt: function(filename, ext, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename;
        } else {
          return upath.addExt(filename, ext);
        }
      }
    };
    isValidExt = function(ext, ignoreExts, maxSize) {
      if (ignoreExts == null) {
        ignoreExts = [];
      }
      return ext && ext.length <= maxSize && indexOf.call(ignoreExts.map(function(e) {
        return (e && e[0] !== "." ? "." : "") + e;
      }), ext) < 0;
    };
    for (name in extraFunctions) {
      if (!hasProp.call(extraFunctions, name))
        continue;
      extraFn = extraFunctions[name];
      if (upath[name] !== void 0) {
        throw new Error("path." + name + " already exists.");
      } else {
        upath[name] = extraFn;
      }
    }
  }
});

// ../../node_modules/.pnpm/vscode-uri@3.0.3/node_modules/vscode-uri/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  URI: () => URI2,
  Utils: () => Utils
});
var LIB, URI2, Utils;
var init_esm = __esm({
  "../../node_modules/.pnpm/vscode-uri@3.0.3/node_modules/vscode-uri/lib/esm/index.js"() {
    LIB = (() => {
      "use strict";
      var t = { 470: (t2) => {
        function e2(t3) {
          if (typeof t3 != "string")
            throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n2 = "", o = 0, i = -1, a = 0, h = 0; h <= t3.length; ++h) {
            if (h < t3.length)
              r3 = t3.charCodeAt(h);
            else {
              if (r3 === 47)
                break;
              r3 = 47;
            }
            if (r3 === 47) {
              if (i === h - 1 || a === 1)
                ;
              else if (i !== h - 1 && a === 2) {
                if (n2.length < 2 || o !== 2 || n2.charCodeAt(n2.length - 1) !== 46 || n2.charCodeAt(n2.length - 2) !== 46) {
                  if (n2.length > 2) {
                    var s = n2.lastIndexOf("/");
                    if (s !== n2.length - 1) {
                      s === -1 ? (n2 = "", o = 0) : o = (n2 = n2.slice(0, s)).length - 1 - n2.lastIndexOf("/"), i = h, a = 0;
                      continue;
                    }
                  } else if (n2.length === 2 || n2.length === 1) {
                    n2 = "", o = 0, i = h, a = 0;
                    continue;
                  }
                }
                e3 && (n2.length > 0 ? n2 += "/.." : n2 = "..", o = 2);
              } else
                n2.length > 0 ? n2 += "/" + t3.slice(i + 1, h) : n2 = t3.slice(i + 1, h), o = h - i - 1;
              i = h, a = 0;
            } else
              r3 === 46 && a !== -1 ? ++a : a = -1;
          }
          return n2;
        }
        var n = { resolve: function() {
          for (var t3, n2 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
            var a;
            i >= 0 ? a = arguments[i] : (t3 === void 0 && (t3 = process.cwd()), a = t3), e2(a), a.length !== 0 && (n2 = a + "/" + n2, o = a.charCodeAt(0) === 47);
          }
          return n2 = r2(n2, !o), o ? n2.length > 0 ? "/" + n2 : "/" : n2.length > 0 ? n2 : ".";
        }, normalize: function(t3) {
          if (e2(t3), t3.length === 0)
            return ".";
          var n2 = t3.charCodeAt(0) === 47, o = t3.charCodeAt(t3.length - 1) === 47;
          return (t3 = r2(t3, !n2)).length !== 0 || n2 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n2 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && t3.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0)
            return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var o = arguments[r3];
            e2(o), o.length > 0 && (t3 === void 0 ? t3 = o : t3 += "/" + o);
          }
          return t3 === void 0 ? "." : n.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3)
            return "";
          if ((t3 = n.resolve(t3)) === (r3 = n.resolve(r3)))
            return "";
          for (var o = 1; o < t3.length && t3.charCodeAt(o) === 47; ++o)
            ;
          for (var i = t3.length, a = i - o, h = 1; h < r3.length && r3.charCodeAt(h) === 47; ++h)
            ;
          for (var s = r3.length - h, c = a < s ? a : s, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (s > c) {
                if (r3.charCodeAt(h + u) === 47)
                  return r3.slice(h + u + 1);
                if (u === 0)
                  return r3.slice(h + u);
              } else
                a > c && (t3.charCodeAt(o + u) === 47 ? f = u : u === 0 && (f = 0));
              break;
            }
            var l = t3.charCodeAt(o + u);
            if (l !== r3.charCodeAt(h + u))
              break;
            l === 47 && (f = u);
          }
          var p = "";
          for (u = o + f + 1; u <= i; ++u)
            u !== i && t3.charCodeAt(u) !== 47 || (p.length === 0 ? p += ".." : p += "/..");
          return p.length > 0 ? p + r3.slice(h + f) : (h += f, r3.charCodeAt(h) === 47 && ++h, r3.slice(h));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), t3.length === 0)
            return ".";
          for (var r3 = t3.charCodeAt(0), n2 = r3 === 47, o = -1, i = true, a = t3.length - 1; a >= 1; --a)
            if ((r3 = t3.charCodeAt(a)) === 47) {
              if (!i) {
                o = a;
                break;
              }
            } else
              i = false;
          return o === -1 ? n2 ? "/" : "." : n2 && o === 1 ? "//" : t3.slice(0, o);
        }, basename: function(t3, r3) {
          if (r3 !== void 0 && typeof r3 != "string")
            throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n2, o = 0, i = -1, a = true;
          if (r3 !== void 0 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3)
              return "";
            var h = r3.length - 1, s = -1;
            for (n2 = t3.length - 1; n2 >= 0; --n2) {
              var c = t3.charCodeAt(n2);
              if (c === 47) {
                if (!a) {
                  o = n2 + 1;
                  break;
                }
              } else
                s === -1 && (a = false, s = n2 + 1), h >= 0 && (c === r3.charCodeAt(h) ? --h == -1 && (i = n2) : (h = -1, i = s));
            }
            return o === i ? i = s : i === -1 && (i = t3.length), t3.slice(o, i);
          }
          for (n2 = t3.length - 1; n2 >= 0; --n2)
            if (t3.charCodeAt(n2) === 47) {
              if (!a) {
                o = n2 + 1;
                break;
              }
            } else
              i === -1 && (a = false, i = n2 + 1);
          return i === -1 ? "" : t3.slice(o, i);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n2 = 0, o = -1, i = true, a = 0, h = t3.length - 1; h >= 0; --h) {
            var s = t3.charCodeAt(h);
            if (s !== 47)
              o === -1 && (i = false, o = h + 1), s === 46 ? r3 === -1 ? r3 = h : a !== 1 && (a = 1) : r3 !== -1 && (a = -1);
            else if (!i) {
              n2 = h + 1;
              break;
            }
          }
          return r3 === -1 || o === -1 || a === 0 || a === 1 && r3 === o - 1 && r3 === n2 + 1 ? "" : t3.slice(r3, o);
        }, format: function(t3) {
          if (t3 === null || typeof t3 != "object")
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return function(t4, e3) {
            var r3 = e3.dir || e3.root, n2 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n2 : r3 + "/" + n2 : n2;
          }(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (t3.length === 0)
            return r3;
          var n2, o = t3.charCodeAt(0), i = o === 47;
          i ? (r3.root = "/", n2 = 1) : n2 = 0;
          for (var a = -1, h = 0, s = -1, c = true, f = t3.length - 1, u = 0; f >= n2; --f)
            if ((o = t3.charCodeAt(f)) !== 47)
              s === -1 && (c = false, s = f + 1), o === 46 ? a === -1 ? a = f : u !== 1 && (u = 1) : a !== -1 && (u = -1);
            else if (!c) {
              h = f + 1;
              break;
            }
          return a === -1 || s === -1 || u === 0 || u === 1 && a === s - 1 && a === h + 1 ? s !== -1 && (r3.base = r3.name = h === 0 && i ? t3.slice(1, s) : t3.slice(h, s)) : (h === 0 && i ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, s)) : (r3.name = t3.slice(h, a), r3.base = t3.slice(h, s)), r3.ext = t3.slice(a, s)), h > 0 ? r3.dir = t3.slice(0, h - 1) : i && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n.posix = n, t2.exports = n;
      }, 447: (t2, e2, r2) => {
        var n;
        if (r2.r(e2), r2.d(e2, { URI: () => d, Utils: () => P }), typeof process == "object")
          n = process.platform === "win32";
        else if (typeof navigator == "object") {
          var o = navigator.userAgent;
          n = o.indexOf("Windows") >= 0;
        }
        var i, a, h = (i = function(t3, e3) {
          return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
            t4.__proto__ = e4;
          } || function(t4, e4) {
            for (var r3 in e4)
              Object.prototype.hasOwnProperty.call(e4, r3) && (t4[r3] = e4[r3]);
          })(t3, e3);
        }, function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
          function r3() {
            this.constructor = t3;
          }
          i(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());
        }), s = /^\w[\w\d+.-]*$/, c = /^\//, f = /^\/\//;
        function u(t3, e3) {
          if (!t3.scheme && e3)
            throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
          if (t3.scheme && !s.test(t3.scheme))
            throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!c.test(t3.path))
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (f.test(t3.path))
              throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        var l = "", p = "/", g = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, d = function() {
          function t3(t4, e3, r3, n2, o2, i2) {
            i2 === void 0 && (i2 = false), typeof t4 == "object" ? (this.scheme = t4.scheme || l, this.authority = t4.authority || l, this.path = t4.path || l, this.query = t4.query || l, this.fragment = t4.fragment || l) : (this.scheme = function(t5, e4) {
              return t5 || e4 ? t5 : "file";
            }(t4, i2), this.authority = e3 || l, this.path = function(t5, e4) {
              switch (t5) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== p && (e4 = p + e4) : e4 = p;
              }
              return e4;
            }(this.scheme, r3 || l), this.query = n2 || l, this.fragment = o2 || l, u(this, i2));
          }
          return t3.isUri = function(e3) {
            return e3 instanceof t3 || !!e3 && typeof e3.authority == "string" && typeof e3.fragment == "string" && typeof e3.path == "string" && typeof e3.query == "string" && typeof e3.scheme == "string" && typeof e3.fsPath == "string" && typeof e3.with == "function" && typeof e3.toString == "function";
          }, Object.defineProperty(t3.prototype, "fsPath", { get: function() {
            return A(this, false);
          }, enumerable: false, configurable: true }), t3.prototype.with = function(t4) {
            if (!t4)
              return this;
            var e3 = t4.scheme, r3 = t4.authority, n2 = t4.path, o2 = t4.query, i2 = t4.fragment;
            return e3 === void 0 ? e3 = this.scheme : e3 === null && (e3 = l), r3 === void 0 ? r3 = this.authority : r3 === null && (r3 = l), n2 === void 0 ? n2 = this.path : n2 === null && (n2 = l), o2 === void 0 ? o2 = this.query : o2 === null && (o2 = l), i2 === void 0 ? i2 = this.fragment : i2 === null && (i2 = l), e3 === this.scheme && r3 === this.authority && n2 === this.path && o2 === this.query && i2 === this.fragment ? this : new y(e3, r3, n2, o2, i2);
          }, t3.parse = function(t4, e3) {
            e3 === void 0 && (e3 = false);
            var r3 = g.exec(t4);
            return r3 ? new y(r3[2] || l, O(r3[4] || l), O(r3[5] || l), O(r3[7] || l), O(r3[9] || l), e3) : new y(l, l, l, l, l);
          }, t3.file = function(t4) {
            var e3 = l;
            if (n && (t4 = t4.replace(/\\/g, p)), t4[0] === p && t4[1] === p) {
              var r3 = t4.indexOf(p, 2);
              r3 === -1 ? (e3 = t4.substring(2), t4 = p) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || p);
            }
            return new y("file", e3, t4, l, l);
          }, t3.from = function(t4) {
            var e3 = new y(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);
            return u(e3, true), e3;
          }, t3.prototype.toString = function(t4) {
            return t4 === void 0 && (t4 = false), w(this, t4);
          }, t3.prototype.toJSON = function() {
            return this;
          }, t3.revive = function(e3) {
            if (e3) {
              if (e3 instanceof t3)
                return e3;
              var r3 = new y(e3);
              return r3._formatted = e3.external, r3._fsPath = e3._sep === v ? e3.fsPath : null, r3;
            }
            return e3;
          }, t3;
        }(), v = n ? 1 : void 0, y = function(t3) {
          function e3() {
            var e4 = t3 !== null && t3.apply(this, arguments) || this;
            return e4._formatted = null, e4._fsPath = null, e4;
          }
          return h(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
            return this._fsPath || (this._fsPath = A(this, false)), this._fsPath;
          }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
            return t4 === void 0 && (t4 = false), t4 ? w(this, true) : (this._formatted || (this._formatted = w(this, false)), this._formatted);
          }, e3.prototype.toJSON = function() {
            var t4 = { $mid: 1 };
            return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = v), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
          }, e3;
        }(d), m = ((a = {})[58] = "%3A", a[47] = "%2F", a[63] = "%3F", a[35] = "%23", a[91] = "%5B", a[93] = "%5D", a[64] = "%40", a[33] = "%21", a[36] = "%24", a[38] = "%26", a[39] = "%27", a[40] = "%28", a[41] = "%29", a[42] = "%2A", a[43] = "%2B", a[44] = "%2C", a[59] = "%3B", a[61] = "%3D", a[32] = "%20", a);
        function b(t3, e3) {
          for (var r3 = void 0, n2 = -1, o2 = 0; o2 < t3.length; o2++) {
            var i2 = t3.charCodeAt(o2);
            if (i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 45 || i2 === 46 || i2 === 95 || i2 === 126 || e3 && i2 === 47)
              n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2, o2)), n2 = -1), r3 !== void 0 && (r3 += t3.charAt(o2));
            else {
              r3 === void 0 && (r3 = t3.substr(0, o2));
              var a2 = m[i2];
              a2 !== void 0 ? (n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2, o2)), n2 = -1), r3 += a2) : n2 === -1 && (n2 = o2);
            }
          }
          return n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2))), r3 !== void 0 ? r3 : t3;
        }
        function C(t3) {
          for (var e3 = void 0, r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3.charCodeAt(r3);
            n2 === 35 || n2 === 63 ? (e3 === void 0 && (e3 = t3.substr(0, r3)), e3 += m[n2]) : e3 !== void 0 && (e3 += t3[r3]);
          }
          return e3 !== void 0 ? e3 : t3;
        }
        function A(t3, e3) {
          var r3;
          return r3 = t3.authority && t3.path.length > 1 && t3.scheme === "file" ? "//".concat(t3.authority).concat(t3.path) : t3.path.charCodeAt(0) === 47 && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && t3.path.charCodeAt(2) === 58 ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function w(t3, e3) {
          var r3 = e3 ? C : b, n2 = "", o2 = t3.scheme, i2 = t3.authority, a2 = t3.path, h2 = t3.query, s2 = t3.fragment;
          if (o2 && (n2 += o2, n2 += ":"), (i2 || o2 === "file") && (n2 += p, n2 += p), i2) {
            var c2 = i2.indexOf("@");
            if (c2 !== -1) {
              var f2 = i2.substr(0, c2);
              i2 = i2.substr(c2 + 1), (c2 = f2.indexOf(":")) === -1 ? n2 += r3(f2, false) : (n2 += r3(f2.substr(0, c2), false), n2 += ":", n2 += r3(f2.substr(c2 + 1), false)), n2 += "@";
            }
            (c2 = (i2 = i2.toLowerCase()).indexOf(":")) === -1 ? n2 += r3(i2, false) : (n2 += r3(i2.substr(0, c2), false), n2 += i2.substr(c2));
          }
          if (a2) {
            if (a2.length >= 3 && a2.charCodeAt(0) === 47 && a2.charCodeAt(2) === 58)
              (u2 = a2.charCodeAt(1)) >= 65 && u2 <= 90 && (a2 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(3)));
            else if (a2.length >= 2 && a2.charCodeAt(1) === 58) {
              var u2;
              (u2 = a2.charCodeAt(0)) >= 65 && u2 <= 90 && (a2 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(2)));
            }
            n2 += r3(a2, true);
          }
          return h2 && (n2 += "?", n2 += r3(h2, false)), s2 && (n2 += "#", n2 += e3 ? s2 : b(s2, false)), n2;
        }
        function x(t3) {
          try {
            return decodeURIComponent(t3);
          } catch (e3) {
            return t3.length > 3 ? t3.substr(0, 3) + x(t3.substr(3)) : t3;
          }
        }
        var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function O(t3) {
          return t3.match(_) ? t3.replace(_, function(t4) {
            return x(t4);
          }) : t3;
        }
        var P, j = r2(470), U = function(t3, e3, r3) {
          if (r3 || arguments.length === 2)
            for (var n2, o2 = 0, i2 = e3.length; o2 < i2; o2++)
              !n2 && o2 in e3 || (n2 || (n2 = Array.prototype.slice.call(e3, 0, o2)), n2[o2] = e3[o2]);
          return t3.concat(n2 || Array.prototype.slice.call(e3));
        }, I = j.posix || j;
        !function(t3) {
          t3.joinPath = function(t4) {
            for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
              e3[r3 - 1] = arguments[r3];
            return t4.with({ path: I.join.apply(I, U([t4.path], e3, false)) });
          }, t3.resolvePath = function(t4) {
            for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
              e3[r3 - 1] = arguments[r3];
            var n2 = t4.path || "/";
            return t4.with({ path: I.resolve.apply(I, U([n2], e3, false)) });
          }, t3.dirname = function(t4) {
            var e3 = I.dirname(t4.path);
            return e3.length === 1 && e3.charCodeAt(0) === 46 ? t4 : t4.with({ path: e3 });
          }, t3.basename = function(t4) {
            return I.basename(t4.path);
          }, t3.extname = function(t4) {
            return I.extname(t4.path);
          };
        }(P || (P = {}));
      } }, e = {};
      function r(n) {
        if (e[n])
          return e[n].exports;
        var o = e[n] = { exports: {} };
        return t[n](o, o.exports, r), o.exports;
      }
      return r.d = (t2, e2) => {
        for (var n in e2)
          r.o(e2, n) && !r.o(t2, n) && Object.defineProperty(t2, n, { enumerable: true, get: e2[n] });
      }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, r(447);
    })();
    ({ URI: URI2, Utils } = LIB);
  }
});

// ../../packages/shared/out/path.js
var require_path = __commonJS({
  "../../packages/shared/out/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFileInDir = exports2.normalizeUri = exports2.normalizeFileName = exports2.fsPathToUri = exports2.uriToFsPath = void 0;
    var vscode_uri_1 = (init_esm(), __toCommonJS(esm_exports));
    var upath = require_upath();
    function uriToFsPath(uri) {
      return upath.toUnix(vscode_uri_1.URI.parse(uri).fsPath);
    }
    exports2.uriToFsPath = uriToFsPath;
    function fsPathToUri(fsPath) {
      return vscode_uri_1.URI.file(fsPath).toString();
    }
    exports2.fsPathToUri = fsPathToUri;
    function normalizeFileName(fsPath) {
      return upath.toUnix(vscode_uri_1.URI.file(fsPath).fsPath);
    }
    exports2.normalizeFileName = normalizeFileName;
    function normalizeUri(uri) {
      return vscode_uri_1.URI.parse(uri).toString();
    }
    exports2.normalizeUri = normalizeUri;
    function isFileInDir(fileName, dir) {
      const relative = upath.relative(dir, fileName);
      return relative && !relative.startsWith("..") && !upath.isAbsolute(relative);
    }
    exports2.isFileInDir = isFileInDir;
  }
});

// ../../packages/shared/out/moduleSpecifierCache.js
var require_moduleSpecifierCache = __commonJS({
  "../../packages/shared/out/moduleSpecifierCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createModuleSpecifierCache = void 0;
    function createModuleSpecifierCache() {
      let cache;
      let currentKey;
      const result = {
        get(fromFileName, toFileName, preferences) {
          if (!cache || currentKey !== key(fromFileName, preferences))
            return void 0;
          return cache.get(toFileName);
        },
        set(fromFileName, toFileName, preferences, modulePaths, moduleSpecifiers) {
          ensureCache(fromFileName, preferences).set(toFileName, createInfo(modulePaths, moduleSpecifiers, true));
          if (moduleSpecifiers) {
            for (const p of modulePaths) {
              if (p.isInNodeModules) {
              }
            }
          }
        },
        setModulePaths(fromFileName, toFileName, preferences, modulePaths) {
          const cache2 = ensureCache(fromFileName, preferences);
          const info = cache2.get(toFileName);
          if (info) {
            info.modulePaths = modulePaths;
          } else {
            cache2.set(toFileName, createInfo(modulePaths, void 0, void 0));
          }
        },
        setIsAutoImportable(fromFileName, toFileName, preferences, isAutoImportable) {
          const cache2 = ensureCache(fromFileName, preferences);
          const info = cache2.get(toFileName);
          if (info) {
            info.isAutoImportable = isAutoImportable;
          } else {
            cache2.set(toFileName, createInfo(void 0, void 0, isAutoImportable));
          }
        },
        clear() {
          cache === null || cache === void 0 ? void 0 : cache.clear();
          currentKey = void 0;
        },
        count() {
          return cache ? cache.size : 0;
        }
      };
      return result;
      function ensureCache(fromFileName, preferences) {
        const newKey = key(fromFileName, preferences);
        if (cache && currentKey !== newKey) {
          result.clear();
        }
        currentKey = newKey;
        return cache || (cache = /* @__PURE__ */ new Map());
      }
      function key(fromFileName, preferences) {
        return `${fromFileName},${preferences.importModuleSpecifierEnding},${preferences.importModuleSpecifierPreference}`;
      }
      function createInfo(modulePaths, moduleSpecifiers, isAutoImportable) {
        return { modulePaths, moduleSpecifiers, isAutoImportable };
      }
    }
    exports2.createModuleSpecifierCache = createModuleSpecifierCache;
  }
});

// ../../packages/shared/out/packageJsonCache.js
var require_packageJsonCache = __commonJS({
  "../../packages/shared/out/packageJsonCache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPackageJsonCache = exports2.canCreatePackageJsonCache = void 0;
    function canCreatePackageJsonCache(ts) {
      return "createPackageJsonInfo" in ts && "getDirectoryPath" in ts && "combinePaths" in ts && "tryFileExists" in ts && "forEachAncestorDirectory" in ts;
    }
    exports2.canCreatePackageJsonCache = canCreatePackageJsonCache;
    function createPackageJsonCache(ts, host) {
      const { createPackageJsonInfo, getDirectoryPath, combinePaths, tryFileExists, forEachAncestorDirectory } = ts;
      const packageJsons = /* @__PURE__ */ new Map();
      const directoriesWithoutPackageJson = /* @__PURE__ */ new Map();
      return {
        addOrUpdate,
        forEach: packageJsons.forEach.bind(packageJsons),
        get: packageJsons.get.bind(packageJsons),
        delete: (fileName) => {
          packageJsons.delete(fileName);
          directoriesWithoutPackageJson.set(getDirectoryPath(fileName), true);
        },
        getInDirectory: (directory) => {
          return packageJsons.get(combinePaths(directory, "package.json")) || void 0;
        },
        directoryHasPackageJson,
        searchDirectoryAndAncestors: (directory) => {
          forEachAncestorDirectory(directory, (ancestor) => {
            if (directoryHasPackageJson(ancestor) !== 3) {
              return true;
            }
            const packageJsonFileName = host.toPath(combinePaths(ancestor, "package.json"));
            if (tryFileExists(host, packageJsonFileName)) {
              addOrUpdate(packageJsonFileName);
            } else {
              directoriesWithoutPackageJson.set(ancestor, true);
            }
          });
        }
      };
      function addOrUpdate(fileName) {
        const packageJsonInfo = createPackageJsonInfo(fileName, host.host);
        packageJsons.set(fileName, packageJsonInfo);
        directoriesWithoutPackageJson.delete(getDirectoryPath(fileName));
      }
      function directoryHasPackageJson(directory) {
        return packageJsons.has(combinePaths(directory, "package.json")) ? -1 : directoriesWithoutPackageJson.has(directory) ? 0 : 3;
      }
    }
    exports2.createPackageJsonCache = createPackageJsonCache;
  }
});

// ../../packages/shared/out/ts.js
var require_ts = __commonJS({
  "../../packages/shared/out/ts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createParsedCommandLine = exports2.injectCacheLogicToLanguageServiceHost = void 0;
    var path = require_upath();
    var path_1 = require_path();
    var moduleSpecifierCache_1 = require_moduleSpecifierCache();
    var packageJsonCache_1 = require_packageJsonCache();
    function injectCacheLogicToLanguageServiceHost(ts, host, service) {
      const _createCacheableExportInfoMap = ts.createCacheableExportInfoMap;
      const _combinePaths = ts.combinePaths;
      const _forEachAncestorDirectory = ts.forEachAncestorDirectory;
      const _getDirectoryPath = ts.getDirectoryPath;
      const _toPath = ts.toPath;
      const _createGetCanonicalFileName = ts.createGetCanonicalFileName;
      if (!_createCacheableExportInfoMap || !_combinePaths || !_forEachAncestorDirectory || !_getDirectoryPath || !_toPath || !_createGetCanonicalFileName || !(0, packageJsonCache_1.canCreatePackageJsonCache)(ts))
        return;
      const moduleSpecifierCache = (0, moduleSpecifierCache_1.createModuleSpecifierCache)();
      const exportMapCache = _createCacheableExportInfoMap({
        getCurrentProgram() {
          return service.getProgram();
        },
        getPackageJsonAutoImportProvider() {
          return service.getProgram();
        }
      });
      const packageJsonCache = (0, packageJsonCache_1.createPackageJsonCache)(ts, {
        ...host,
        host: { ...host },
        toPath
      });
      host.getCachedExportInfoMap = () => exportMapCache;
      host.getModuleSpecifierCache = () => moduleSpecifierCache;
      host.getPackageJsonsVisibleToFile = (fileName, rootDir) => {
        const rootPath = rootDir && toPath(rootDir);
        const filePath = toPath(fileName);
        const result = [];
        const processDirectory = (directory) => {
          switch (packageJsonCache.directoryHasPackageJson(directory)) {
            case 3:
              packageJsonCache.searchDirectoryAndAncestors(directory);
              return processDirectory(directory);
            case -1:
              const packageJsonFileName = _combinePaths(directory, "package.json");
              const info = packageJsonCache.getInDirectory(directory);
              if (info)
                result.push(info);
          }
          if (rootPath && rootPath === directory) {
            return true;
          }
        };
        _forEachAncestorDirectory(_getDirectoryPath(filePath), processDirectory);
        return result;
      };
      function toPath(fileName) {
        var _a2;
        return _toPath(fileName, host.getCurrentDirectory(), _createGetCanonicalFileName((_a2 = host.useCaseSensitiveFileNames) === null || _a2 === void 0 ? void 0 : _a2.call(host)));
      }
    }
    exports2.injectCacheLogicToLanguageServiceHost = injectCacheLogicToLanguageServiceHost;
    function createParsedCommandLine(ts, parseConfigHost, tsConfig, extendsSet = /* @__PURE__ */ new Set()) {
      var _a2;
      const tsConfigPath = ts.sys.resolvePath(tsConfig);
      const config = ts.readJsonConfigFile(tsConfigPath, ts.sys.readFile);
      const content = ts.parseJsonSourceFileConfigFileContent(config, parseConfigHost, path.dirname(tsConfigPath), {}, path.basename(tsConfigPath));
      content.options.outDir = void 0;
      content.fileNames = content.fileNames.map(path_1.normalizeFileName);
      let baseVueOptions = {};
      const folder = path.dirname(tsConfig);
      extendsSet.add(tsConfig);
      if (content.raw.extends) {
        try {
          const extendsPath = require.resolve(content.raw.extends, { paths: [folder] });
          if (!extendsSet.has(extendsPath)) {
            baseVueOptions = createParsedCommandLine(ts, parseConfigHost, extendsPath, extendsSet).vueOptions;
          }
        } catch (error) {
          console.error(error);
        }
      }
      return {
        ...content,
        vueOptions: {
          ...baseVueOptions,
          ...resolveVueCompilerOptions((_a2 = content.raw.vueCompilerOptions) !== null && _a2 !== void 0 ? _a2 : {}, folder)
        }
      };
    }
    exports2.createParsedCommandLine = createParsedCommandLine;
    function resolveVueCompilerOptions(rawOptions, rootPath) {
      const result = { ...rawOptions };
      let templateOptionsPath = rawOptions.experimentalTemplateCompilerOptionsRequirePath;
      if (templateOptionsPath) {
        if (!path.isAbsolute(templateOptionsPath)) {
          templateOptionsPath = require.resolve(templateOptionsPath, { paths: [rootPath] });
        }
        try {
          result.experimentalTemplateCompilerOptions = require(templateOptionsPath).default;
        } catch (error) {
          console.log('Failed to require "experimentalTemplateCompilerOptionsRequirePath":', templateOptionsPath);
          console.error(error);
        }
      }
      return result;
    }
  }
});

// ../../packages/shared/out/requests.js
var require_requests = __commonJS({
  "../../packages/shared/out/requests.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DetectDocumentNameCasesRequest = exports2.WriteVirtualFilesNotification = exports2.VerifyAllScriptsNotification = exports2.GetRefCompleteEditsRequest = exports2.GetWrapParenthesesEditsRequest = exports2.GetTagCloseEditsRequest = exports2.GetAutoQuoteEditsRequest = exports2.D3Request = exports2.GetMatchTsConfigRequest = exports2.InitDoneRequest = exports2.GetEditorSelectionRequest = exports2.GetDocumentPrintWidthRequest = exports2.GetDocumentNameCasesRequest = exports2.ShowReferencesNotification = exports2.GetDocumentVersionRequest = exports2.GetDocumentContentRequest = void 0;
    var rpc = require_main();
    var GetDocumentContentRequest;
    (function(GetDocumentContentRequest2) {
      GetDocumentContentRequest2.type = new rpc.RequestType("vscode/content");
    })(GetDocumentContentRequest = exports2.GetDocumentContentRequest || (exports2.GetDocumentContentRequest = {}));
    var GetDocumentVersionRequest;
    (function(GetDocumentVersionRequest2) {
      GetDocumentVersionRequest2.type = new rpc.RequestType("vue/docVersion");
    })(GetDocumentVersionRequest = exports2.GetDocumentVersionRequest || (exports2.GetDocumentVersionRequest = {}));
    var ShowReferencesNotification;
    (function(ShowReferencesNotification2) {
      ShowReferencesNotification2.type = new rpc.NotificationType("vue.findReferences");
    })(ShowReferencesNotification = exports2.ShowReferencesNotification || (exports2.ShowReferencesNotification = {}));
    var GetDocumentNameCasesRequest;
    (function(GetDocumentNameCasesRequest2) {
      GetDocumentNameCasesRequest2.type = new rpc.RequestType("volar/getAttrNameCaseClient");
    })(GetDocumentNameCasesRequest = exports2.GetDocumentNameCasesRequest || (exports2.GetDocumentNameCasesRequest = {}));
    var GetDocumentPrintWidthRequest;
    (function(GetDocumentPrintWidthRequest2) {
      GetDocumentPrintWidthRequest2.type = new rpc.RequestType("vue/getDocumentWordWrapColumn");
    })(GetDocumentPrintWidthRequest = exports2.GetDocumentPrintWidthRequest || (exports2.GetDocumentPrintWidthRequest = {}));
    var GetEditorSelectionRequest;
    (function(GetEditorSelectionRequest2) {
      GetEditorSelectionRequest2.type = new rpc.RequestType0("vue/activeSelection");
    })(GetEditorSelectionRequest = exports2.GetEditorSelectionRequest || (exports2.GetEditorSelectionRequest = {}));
    var InitDoneRequest;
    (function(InitDoneRequest2) {
      InitDoneRequest2.type = new rpc.RequestType0("volar/init");
    })(InitDoneRequest = exports2.InitDoneRequest || (exports2.InitDoneRequest = {}));
    var GetMatchTsConfigRequest;
    (function(GetMatchTsConfigRequest2) {
      GetMatchTsConfigRequest2.type = new rpc.RequestType("volar/tsconfig");
    })(GetMatchTsConfigRequest = exports2.GetMatchTsConfigRequest || (exports2.GetMatchTsConfigRequest = {}));
    var D3Request;
    (function(D3Request2) {
      D3Request2.type = new rpc.RequestType("volar/d3");
    })(D3Request = exports2.D3Request || (exports2.D3Request = {}));
    var GetAutoQuoteEditsRequest;
    (function(GetAutoQuoteEditsRequest2) {
      GetAutoQuoteEditsRequest2.type = new rpc.RequestType("html/autoCreateQuote");
    })(GetAutoQuoteEditsRequest = exports2.GetAutoQuoteEditsRequest || (exports2.GetAutoQuoteEditsRequest = {}));
    var GetTagCloseEditsRequest;
    (function(GetTagCloseEditsRequest2) {
      GetTagCloseEditsRequest2.type = new rpc.RequestType("html/autoCloseTag");
    })(GetTagCloseEditsRequest = exports2.GetTagCloseEditsRequest || (exports2.GetTagCloseEditsRequest = {}));
    var GetWrapParenthesesEditsRequest;
    (function(GetWrapParenthesesEditsRequest2) {
      GetWrapParenthesesEditsRequest2.type = new rpc.RequestType("html/autoWrapParentheses");
    })(GetWrapParenthesesEditsRequest = exports2.GetWrapParenthesesEditsRequest || (exports2.GetWrapParenthesesEditsRequest = {}));
    var GetRefCompleteEditsRequest;
    (function(GetRefCompleteEditsRequest2) {
      GetRefCompleteEditsRequest2.type = new rpc.RequestType("volar/autoCompleteRef");
    })(GetRefCompleteEditsRequest = exports2.GetRefCompleteEditsRequest || (exports2.GetRefCompleteEditsRequest = {}));
    var VerifyAllScriptsNotification;
    (function(VerifyAllScriptsNotification2) {
      VerifyAllScriptsNotification2.type = new rpc.NotificationType0("volar.action.verifyAllScripts");
    })(VerifyAllScriptsNotification = exports2.VerifyAllScriptsNotification || (exports2.VerifyAllScriptsNotification = {}));
    var WriteVirtualFilesNotification;
    (function(WriteVirtualFilesNotification2) {
      WriteVirtualFilesNotification2.type = new rpc.NotificationType("volar.action.writeVirtualFiles");
    })(WriteVirtualFilesNotification = exports2.WriteVirtualFilesNotification || (exports2.WriteVirtualFilesNotification = {}));
    var DetectDocumentNameCasesRequest;
    (function(DetectDocumentNameCasesRequest2) {
      DetectDocumentNameCasesRequest2.type = new rpc.RequestType("volar/getTagNameCaseServer");
    })(DetectDocumentNameCasesRequest = exports2.DetectDocumentNameCasesRequest || (exports2.DetectDocumentNameCasesRequest = {}));
  }
});

// ../../packages/shared/out/types.js
var require_types = __commonJS({
  "../../packages/shared/out/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../packages/shared/out/uriMap.js
var require_uriMap = __commonJS({
  "../../packages/shared/out/uriMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createPathMap = void 0;
    var vscode_uri_1 = (init_esm(), __toCommonJS(esm_exports));
    var path_1 = require_path();
    function createPathMap(map = /* @__PURE__ */ new Map()) {
      const uriToUriKeys = {};
      const fsPathToUriKeys = {};
      return {
        clear,
        values,
        uriDelete,
        uriGet,
        uriHas,
        uriSet,
        fsPathDelete,
        fsPathGet,
        fsPathHas,
        fsPathSet
      };
      function getUriByUri(uri) {
        if (uriToUriKeys[uri] === void 0)
          uriToUriKeys[uri] = normalizeUri(uri).toLowerCase();
        return uriToUriKeys[uri];
      }
      function getUriByFsPath(fsPath) {
        if (fsPathToUriKeys[fsPath] === void 0)
          fsPathToUriKeys[fsPath] = (0, path_1.fsPathToUri)(fsPath).toLowerCase();
        return fsPathToUriKeys[fsPath];
      }
      function clear() {
        return map.clear();
      }
      function values() {
        return map.values();
      }
      function uriDelete(_uri) {
        return map.delete(getUriByUri(_uri));
      }
      function uriGet(_uri) {
        return map.get(getUriByUri(_uri));
      }
      function uriHas(_uri) {
        return map.has(getUriByUri(_uri));
      }
      function uriSet(_uri, item) {
        return map.set(getUriByUri(_uri), item);
      }
      function fsPathDelete(_fsPath) {
        return map.delete(getUriByFsPath(_fsPath));
      }
      function fsPathGet(_fsPath) {
        return map.get(getUriByFsPath(_fsPath));
      }
      function fsPathHas(_fsPath) {
        return map.has(getUriByFsPath(_fsPath));
      }
      function fsPathSet(_fsPath, item) {
        return map.set(getUriByFsPath(_fsPath), item);
      }
    }
    exports2.createPathMap = createPathMap;
    function normalizeUri(uri) {
      try {
        return vscode_uri_1.URI.parse(uri).toString();
      } catch {
        return "";
      }
    }
  }
});

// ../../packages/shared/out/vue.js
var require_vue = __commonJS({
  "../../packages/shared/out/vue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseSfc = exports2.defaultLanguages = void 0;
    exports2.defaultLanguages = {
      template: "html",
      script: "js",
      style: "css"
    };
    var validScriptSyntaxs = ["js", "jsx", "ts", "tsx"];
    function getValidScriptSyntax(syntax) {
      if (validScriptSyntaxs.includes(syntax)) {
        return syntax;
      }
      return "js";
    }
    function parseSfc(text, doc) {
      var _a2, _b, _c, _d, _e, _f, _g;
      const sfc = {
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: []
      };
      for (const node of doc.roots) {
        let parseAttrs = function(attrs) {
          const obj = {};
          if (attrs) {
            for (let key in attrs) {
              obj[key] = parseAttr(attrs[key], "");
            }
          }
          return obj;
        };
        const lang = (_a2 = node.attributes) === null || _a2 === void 0 ? void 0 : _a2["lang"];
        if (node.tag === "template" && node.startTagEnd !== void 0) {
          sfc.template = {
            lang: lang !== void 0 ? parseAttr(lang, exports2.defaultLanguages.template) : exports2.defaultLanguages.template,
            content: text.substring(node.startTagEnd, node.endTagStart),
            startTagEnd: node.startTagEnd,
            start: node.start,
            end: node.end,
            attrs: parseAttrs(node.attributes)
          };
        } else if (node.tag === "script" && node.startTagEnd !== void 0) {
          if (((_b = node.attributes) === null || _b === void 0 ? void 0 : _b["setup"]) === void 0) {
            const src = (_c = node.attributes) === null || _c === void 0 ? void 0 : _c["src"];
            sfc.script = {
              src: src !== void 0 ? parseAttr(src, "") : void 0,
              lang: lang !== void 0 ? getValidScriptSyntax(parseAttr(lang, exports2.defaultLanguages.script)) : exports2.defaultLanguages.script,
              content: text.substring(node.startTagEnd, node.endTagStart),
              startTagEnd: node.startTagEnd,
              start: node.start,
              end: node.end,
              attrs: parseAttrs(node.attributes)
            };
          } else {
            sfc.scriptSetup = {
              lang: lang !== void 0 ? getValidScriptSyntax(parseAttr(lang, exports2.defaultLanguages.script)) : exports2.defaultLanguages.script,
              content: text.substring(node.startTagEnd, node.endTagStart),
              startTagEnd: node.startTagEnd,
              start: node.start,
              end: node.end,
              attrs: parseAttrs(node.attributes)
            };
          }
        } else if (node.tag === "style" && node.startTagEnd !== void 0) {
          const module3 = (_d = node.attributes) === null || _d === void 0 ? void 0 : _d["module"];
          const scoped = (_e = node.attributes) === null || _e === void 0 ? void 0 : _e["scoped"];
          sfc.styles.push({
            lang: lang !== void 0 ? parseAttr(lang, exports2.defaultLanguages.style) : exports2.defaultLanguages.style,
            content: text.substring(node.startTagEnd, node.endTagStart),
            startTagEnd: node.startTagEnd,
            start: node.start,
            end: node.end,
            module: module3 !== void 0 ? parseAttr(module3, "$style") : void 0,
            scoped: scoped !== void 0,
            attrs: parseAttrs(node.attributes)
          });
        } else {
          sfc.customBlocks.push({
            type: (_f = node.tag) !== null && _f !== void 0 ? _f : "",
            lang: lang !== void 0 ? parseAttr(lang, "") : "",
            content: node.startTagEnd !== void 0 ? text.substring(node.startTagEnd, node.endTagStart) : "",
            startTagEnd: (_g = node.startTagEnd) !== null && _g !== void 0 ? _g : node.end,
            start: node.start,
            end: node.end,
            attrs: parseAttrs(node.attributes)
          });
        }
      }
      return sfc;
    }
    exports2.parseSfc = parseSfc;
    function parseAttr(attr, _default) {
      if (attr === null) {
        return _default;
      }
      if (attr.startsWith('"') && attr.endsWith('"') || attr.startsWith("'") && attr.endsWith("'")) {
        return attr.substring(1, attr.length - 1);
      }
      return attr;
    }
  }
});

// ../../packages/shared/out/browser.js
var require_browser = __commonJS({
  "../../packages/shared/out/browser.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_common(), exports2);
    __exportStar(require_ts(), exports2);
    __exportStar(require_path(), exports2);
    __exportStar(require_requests(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_uriMap(), exports2);
    __exportStar(require_browser(), exports2);
    __exportStar(require_vue(), exports2);
  }
});

// ../../packages/shared/out/ts_node.js
var require_ts_node = __commonJS({
  "../../packages/shared/out/ts_node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTypeScriptVersion = exports2.getVscodeTypescriptLocalizedPath = exports2.getVscodeTypescriptPath = exports2.findTypescriptLocalizedPathInLib = exports2.findTypescriptModulePathInLib = exports2.getWorkspaceTypescriptLocalizedPath = exports2.getWorkspaceTypescriptPath = void 0;
    var fs = require("fs");
    var path = require_upath();
    function getWorkspaceTypescriptPath(tsdk, workspaceFolderFsPaths) {
      if (path.isAbsolute(tsdk)) {
        const tsPath = findTypescriptModulePathInLib(tsdk);
        if (tsPath) {
          return tsPath;
        }
      } else {
        for (const folder of workspaceFolderFsPaths) {
          const tsPath = findTypescriptModulePathInLib(path.join(folder, tsdk));
          if (tsPath) {
            return tsPath;
          }
        }
      }
    }
    exports2.getWorkspaceTypescriptPath = getWorkspaceTypescriptPath;
    function getWorkspaceTypescriptLocalizedPath(tsdk, lang, workspaceFolderFsPaths) {
      if (path.isAbsolute(tsdk)) {
        const tsPath = findTypescriptLocalizedPathInLib(tsdk, lang);
        if (tsPath) {
          return tsPath;
        }
      } else {
        for (const folder of workspaceFolderFsPaths) {
          const tsPath = findTypescriptLocalizedPathInLib(path.join(folder, tsdk), lang);
          if (tsPath) {
            return tsPath;
          }
        }
      }
    }
    exports2.getWorkspaceTypescriptLocalizedPath = getWorkspaceTypescriptLocalizedPath;
    function findTypescriptModulePathInLib(lib) {
      const tsserverlibrary = path.join(lib, "tsserverlibrary.js");
      const typescript = path.join(lib, "typescript.js");
      const tsserver = path.join(lib, "tsserver.js");
      if (fs.existsSync(tsserverlibrary)) {
        return tsserverlibrary;
      }
      if (fs.existsSync(typescript)) {
        return typescript;
      }
      if (fs.existsSync(tsserver)) {
        return tsserver;
      }
    }
    exports2.findTypescriptModulePathInLib = findTypescriptModulePathInLib;
    function findTypescriptLocalizedPathInLib(lib, lang) {
      const localized = path.join(lib, lang, "diagnosticMessages.generated.json");
      if (fs.existsSync(localized)) {
        return localized;
      }
    }
    exports2.findTypescriptLocalizedPathInLib = findTypescriptLocalizedPathInLib;
    function getVscodeTypescriptPath(appRoot) {
      return path.join(appRoot, "extensions", "node_modules", "typescript", "lib", "typescript.js");
    }
    exports2.getVscodeTypescriptPath = getVscodeTypescriptPath;
    function getVscodeTypescriptLocalizedPath(appRoot, lang) {
      const tsPath = path.join(appRoot, "extensions", "node_modules", "typescript", "lib", lang, "diagnosticMessages.generated.json");
      if (fs.existsSync(tsPath)) {
        return tsPath;
      }
    }
    exports2.getVscodeTypescriptLocalizedPath = getVscodeTypescriptLocalizedPath;
    function getTypeScriptVersion(serverPath) {
      if (!fs.existsSync(serverPath)) {
        return void 0;
      }
      const p = serverPath.split(path.sep);
      if (p.length <= 2) {
        return void 0;
      }
      const p2 = p.slice(0, -2);
      const modulePath = p2.join(path.sep);
      let fileName = path.join(modulePath, "package.json");
      if (!fs.existsSync(fileName)) {
        if (path.basename(modulePath) === "built") {
          fileName = path.join(modulePath, "..", "package.json");
        }
      }
      if (!fs.existsSync(fileName)) {
        return void 0;
      }
      const contents = fs.readFileSync(fileName).toString();
      let desc = null;
      try {
        desc = JSON.parse(contents);
      } catch (err) {
        return void 0;
      }
      if (!desc || !desc.version) {
        return void 0;
      }
      return desc.version;
    }
    exports2.getTypeScriptVersion = getTypeScriptVersion;
  }
});

// ../../packages/shared/out/http.js
var require_http = __commonJS({
  "../../packages/shared/out/http.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLocalHostAvaliablePort = exports2.isLocalHostPortUsing = void 0;
    var http = require("http");
    function isLocalHostPortUsing(port) {
      return new Promise((resolve) => {
        http.get(`http://localhost:${port}/`, {
          headers: {
            accept: "*/*"
          }
        }, (res) => {
          resolve(res.statusCode === 200);
        }).on("error", () => resolve(false)).end();
      });
    }
    exports2.isLocalHostPortUsing = isLocalHostPortUsing;
    async function getLocalHostAvaliablePort(port) {
      if (await isLocalHostPortUsing(port)) {
        port++;
      }
      return port;
    }
    exports2.getLocalHostAvaliablePort = getLocalHostAvaliablePort;
  }
});

// ../../packages/shared/out/node.js
var require_node4 = __commonJS({
  "../../packages/shared/out/node.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_browser(), exports2);
    __exportStar(require_ts_node(), exports2);
    __exportStar(require_http(), exports2);
  }
});

// ../../packages/client/out/features/activeSelection.js
var require_activeSelection = __commonJS({
  "../../packages/client/out/features/activeSelection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      context.subscriptions.push(languageClient.onRequest(shared.GetEditorSelectionRequest.type, () => {
        const editor = vscode2.window.activeTextEditor;
        if (editor) {
          return {
            textDocument: {
              uri: languageClient.code2ProtocolConverter.asUri(editor.document.uri)
            },
            position: editor.selection.end
          };
        }
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../node_modules/.pnpm/@vue+shared@3.2.31/node_modules/@vue/shared/dist/shared.cjs.prod.js
var require_shared_cjs_prod = __commonJS({
  "../../node_modules/.pnpm/@vue+shared@3.2.31/node_modules/@vue/shared/dist/shared.cjs.prod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function makeMap(str, expectsLowerCase) {
      const map = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
      }
      return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
    }
    var PatchFlagNames = {
      [1]: `TEXT`,
      [2]: `CLASS`,
      [4]: `STYLE`,
      [8]: `PROPS`,
      [16]: `FULL_PROPS`,
      [32]: `HYDRATE_EVENTS`,
      [64]: `STABLE_FRAGMENT`,
      [128]: `KEYED_FRAGMENT`,
      [256]: `UNKEYED_FRAGMENT`,
      [512]: `NEED_PATCH`,
      [1024]: `DYNAMIC_SLOTS`,
      [2048]: `DEV_ROOT_FRAGMENT`,
      [-1]: `HOISTED`,
      [-2]: `BAIL`
    };
    var slotFlagsText = {
      [1]: "STABLE",
      [2]: "DYNAMIC",
      [3]: "FORWARDED"
    };
    var GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
    var isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
    var range = 2;
    function generateCodeFrame(source, start = 0, end = source.length) {
      let lines = source.split(/(\r?\n)/);
      const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
      lines = lines.filter((_, idx) => idx % 2 === 0);
      let count = 0;
      const res = [];
      for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
        if (count >= start) {
          for (let j = i - range; j <= i + range || end > count; j++) {
            if (j < 0 || j >= lines.length)
              continue;
            const line = j + 1;
            res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
            const lineLength = lines[j].length;
            const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
            if (j === i) {
              const pad = start - (count - (lineLength + newLineSeqLength));
              const length = Math.max(1, end > count ? lineLength - pad : end - start);
              res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
            } else if (j > i) {
              if (end > count) {
                const length = Math.max(Math.min(end - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + newLineSeqLength;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    var isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
    var attrValidationCache = {};
    function isSSRSafeAttrName(name) {
      if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
      }
      const isUnsafe = unsafeAttrCharRE.test(name);
      if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
      }
      return attrValidationCache[name] = !isUnsafe;
    }
    var propsToAttrMap = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv"
    };
    var isNoUnitNumericStyleProp = /* @__PURE__ */ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width`);
    var isKnownHtmlAttr = /* @__PURE__ */ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`);
    var isKnownSvgAttr = /* @__PURE__ */ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);
    function normalizeStyle(value) {
      if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString(value)) {
        return value;
      } else if (isObject(value)) {
        return value;
      }
    }
    var listDelimiterRE = /;(?![^(]*\))/g;
    var propertyDelimiterRE = /:(.+)/;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function stringifyStyle(styles) {
      let ret = "";
      if (!styles || isString(styles)) {
        return ret;
      }
      for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) || typeof value === "number" && isNoUnitNumericStyleProp(normalizedKey)) {
          ret += `${normalizedKey}:${value};`;
        }
      }
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString(value)) {
        res = value;
      } else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
    var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
    var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
    var isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
    var escapeRE = /["'&<>]/;
    function escapeHtml(string) {
      const str = "" + string;
      const match = escapeRE.exec(str);
      if (!match) {
        return str;
      }
      let html = "";
      let escaped;
      let index;
      let lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escaped = "&quot;";
            break;
          case 38:
            escaped = "&amp;";
            break;
          case 39:
            escaped = "&#39;";
            break;
          case 60:
            escaped = "&lt;";
            break;
          case 62:
            escaped = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.slice(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
      }
      return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
    }
    var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
    function escapeHtmlComment(src) {
      return src.replace(commentStripRE, "");
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isArray(a);
      bValidType = isArray(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject(a);
      bValidType = isObject(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    var toDisplayString = (val) => {
      return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    var replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
      }
      return val;
    };
    var EMPTY_OBJ = {};
    var EMPTY_ARR = [];
    var NOOP = () => {
    };
    var NO = () => false;
    var onRE = /^on[^a-z]/;
    var isOn = (key) => onRE.test(key);
    var isModelListener = (key) => key.startsWith("onUpdate:");
    var extend = Object.assign;
    var remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var hasOwn = (val, key) => hasOwnProperty.call(val, key);
    var isArray = Array.isArray;
    var isMap = (val) => toTypeString(val) === "[object Map]";
    var isSet = (val) => toTypeString(val) === "[object Set]";
    var isDate = (val) => val instanceof Date;
    var isFunction = (val) => typeof val === "function";
    var isString = (val) => typeof val === "string";
    var isSymbol = (val) => typeof val === "symbol";
    var isObject = (val) => val !== null && typeof val === "object";
    var isPromise = (val) => {
      return isObject(val) && isFunction(val.then) && isFunction(val.catch);
    };
    var objectToString = Object.prototype.toString;
    var toTypeString = (value) => objectToString.call(value);
    var toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    var isPlainObject = (val) => toTypeString(val) === "[object Object]";
    var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    var isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
    var isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
    var cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    var hyphenateRE = /\B([A-Z])/g;
    var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
    var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
    var toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
    var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    var invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    var def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    var toNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    var _globalThis;
    var getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    exports2.EMPTY_ARR = EMPTY_ARR;
    exports2.EMPTY_OBJ = EMPTY_OBJ;
    exports2.NO = NO;
    exports2.NOOP = NOOP;
    exports2.PatchFlagNames = PatchFlagNames;
    exports2.camelize = camelize;
    exports2.capitalize = capitalize;
    exports2.def = def;
    exports2.escapeHtml = escapeHtml;
    exports2.escapeHtmlComment = escapeHtmlComment;
    exports2.extend = extend;
    exports2.generateCodeFrame = generateCodeFrame;
    exports2.getGlobalThis = getGlobalThis;
    exports2.hasChanged = hasChanged;
    exports2.hasOwn = hasOwn;
    exports2.hyphenate = hyphenate;
    exports2.includeBooleanAttr = includeBooleanAttr;
    exports2.invokeArrayFns = invokeArrayFns;
    exports2.isArray = isArray;
    exports2.isBooleanAttr = isBooleanAttr;
    exports2.isBuiltInDirective = isBuiltInDirective;
    exports2.isDate = isDate;
    exports2.isFunction = isFunction;
    exports2.isGloballyWhitelisted = isGloballyWhitelisted;
    exports2.isHTMLTag = isHTMLTag;
    exports2.isIntegerKey = isIntegerKey;
    exports2.isKnownHtmlAttr = isKnownHtmlAttr;
    exports2.isKnownSvgAttr = isKnownSvgAttr;
    exports2.isMap = isMap;
    exports2.isModelListener = isModelListener;
    exports2.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;
    exports2.isObject = isObject;
    exports2.isOn = isOn;
    exports2.isPlainObject = isPlainObject;
    exports2.isPromise = isPromise;
    exports2.isReservedProp = isReservedProp;
    exports2.isSSRSafeAttrName = isSSRSafeAttrName;
    exports2.isSVGTag = isSVGTag;
    exports2.isSet = isSet;
    exports2.isSpecialBooleanAttr = isSpecialBooleanAttr;
    exports2.isString = isString;
    exports2.isSymbol = isSymbol;
    exports2.isVoidTag = isVoidTag;
    exports2.looseEqual = looseEqual;
    exports2.looseIndexOf = looseIndexOf;
    exports2.makeMap = makeMap;
    exports2.normalizeClass = normalizeClass;
    exports2.normalizeProps = normalizeProps;
    exports2.normalizeStyle = normalizeStyle;
    exports2.objectToString = objectToString;
    exports2.parseStringStyle = parseStringStyle;
    exports2.propsToAttrMap = propsToAttrMap;
    exports2.remove = remove;
    exports2.slotFlagsText = slotFlagsText;
    exports2.stringifyStyle = stringifyStyle;
    exports2.toDisplayString = toDisplayString;
    exports2.toHandlerKey = toHandlerKey;
    exports2.toNumber = toNumber;
    exports2.toRawType = toRawType;
    exports2.toTypeString = toTypeString;
  }
});

// ../../node_modules/.pnpm/@vue+shared@3.2.31/node_modules/@vue/shared/index.js
var require_shared = __commonJS({
  "../../node_modules/.pnpm/@vue+shared@3.2.31/node_modules/@vue/shared/index.js"(exports2, module2) {
    "use strict";
    if (true) {
      module2.exports = require_shared_cjs_prod();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/.pnpm/@vue+reactivity@3.2.31/node_modules/@vue/reactivity/dist/reactivity.cjs.prod.js
var require_reactivity_cjs_prod = __commonJS({
  "../../node_modules/.pnpm/@vue+reactivity@3.2.31/node_modules/@vue/reactivity/dist/reactivity.cjs.prod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var shared = require_shared();
    var activeEffectScope;
    var EffectScope = class {
      constructor(detached = false) {
        this.active = true;
        this.effects = [];
        this.cleanups = [];
        if (!detached && activeEffectScope) {
          this.parent = activeEffectScope;
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
      }
      run(fn) {
        if (this.active) {
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = this.parent;
          }
        }
      }
      on() {
        activeEffectScope = this;
      }
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this.active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.active = false;
        }
      }
    };
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
      }
    }
    var createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
    };
    var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
    var newTracked = (dep) => (dep.n & trackOpBit) > 0;
    var initDepMarkers = ({ deps }) => {
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].w |= trackOpBit;
        }
      }
    };
    var finalizeDepMarkers = (effect2) => {
      const { deps } = effect2;
      if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
          const dep = deps[i];
          if (wasTracked(dep) && !newTracked(dep)) {
            dep.delete(effect2);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit;
          dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
      }
    };
    var targetMap = /* @__PURE__ */ new WeakMap();
    var effectTrackDepth = 0;
    var trackOpBit = 1;
    var maxMarkerBits = 30;
    var activeEffect;
    var ITERATE_KEY = Symbol("");
    var MAP_KEY_ITERATE_KEY = Symbol("");
    var ReactiveEffect = class {
      constructor(fn, scheduler2 = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler2;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
          if (parent === this) {
            return;
          }
          parent = parent.parent;
        }
        try {
          this.parent = activeEffect;
          activeEffect = this;
          shouldTrack = true;
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          activeEffect = this.parent;
          shouldTrack = lastShouldTrack;
          this.parent = void 0;
        }
      }
      stop() {
        if (this.active) {
          cleanupEffect(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    };
    function cleanupEffect(effect2) {
      const { deps } = effect2;
      if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
          deps[i].delete(effect2);
        }
        deps.length = 0;
      }
    }
    function effect(fn, options) {
      if (fn.effect) {
        fn = fn.effect.fn;
      }
      const _effect = new ReactiveEffect(fn);
      if (options) {
        shared.extend(_effect, options);
        if (options.scope)
          recordEffectScope(_effect, options.scope);
      }
      if (!options || !options.lazy) {
        _effect.run();
      }
      const runner = _effect.run.bind(_effect);
      runner.effect = _effect;
      return runner;
    }
    function stop(runner) {
      runner.effect.stop();
    }
    var shouldTrack = true;
    var trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function enableTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = true;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep());
        }
        trackEffects(dep);
      }
    }
    function trackEffects(dep, debuggerEventExtraInfo) {
      let shouldTrack2 = false;
      if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
          dep.n |= trackOpBit;
          shouldTrack2 = !wasTracked(dep);
        }
      } else {
        shouldTrack2 = !dep.has(activeEffect);
      }
      if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && shared.isArray(target)) {
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 >= newValue) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!shared.isArray(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (shared.isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (shared.isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!shared.isArray(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (shared.isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (shared.isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      if (deps.length === 1) {
        if (deps[0]) {
          {
            triggerEffects(deps[0]);
          }
        }
      } else {
        const effects = [];
        for (const dep of deps) {
          if (dep) {
            effects.push(...dep);
          }
        }
        {
          triggerEffects(createDep(effects));
        }
      }
    }
    function triggerEffects(dep, debuggerEventExtraInfo) {
      for (const effect2 of shared.isArray(dep) ? dep : [...dep]) {
        if (effect2 !== activeEffect || effect2.allowRecurse) {
          if (effect2.scheduler) {
            effect2.scheduler();
          } else {
            effect2.run();
          }
        }
      }
    }
    var isNonTrackableKeys = /* @__PURE__ */ shared.makeMap(`__proto__,__v_isRef,__isVue`);
    var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(shared.isSymbol));
    var get = /* @__PURE__ */ createGetter();
    var shallowGet = /* @__PURE__ */ createGetter(false, true);
    var readonlyGet = /* @__PURE__ */ createGetter(true);
    var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
    var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          const res = toRaw(this)[key].apply(this, args);
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function createGetter(isReadonly2 = false, shallow = false) {
      return function get2(target, key, receiver) {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
          return target;
        }
        const targetIsArray = shared.isArray(target);
        if (!isReadonly2 && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if (shared.isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          const shouldUnwrap = !targetIsArray || !shared.isIntegerKey(key);
          return shouldUnwrap ? res.value : res;
        }
        if (shared.isObject(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      };
    }
    var set = /* @__PURE__ */ createSetter();
    var shallowSet = /* @__PURE__ */ createSetter(true);
    function createSetter(shallow = false) {
      return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
          return false;
        }
        if (!shallow && !isReadonly(value)) {
          if (!isShallow(value)) {
            value = toRaw(value);
            oldValue = toRaw(oldValue);
          }
          if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          }
        }
        const hadKey = shared.isArray(target) && shared.isIntegerKey(key) ? Number(key) < target.length : shared.hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (shared.hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      };
    }
    function deleteProperty(target, key) {
      const hadKey = shared.hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function has(target, key) {
      const result = Reflect.has(target, key);
      if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    function ownKeys(target) {
      track(target, "iterate", shared.isArray(target) ? "length" : ITERATE_KEY);
      return Reflect.ownKeys(target);
    }
    var mutableHandlers = {
      get,
      set,
      deleteProperty,
      has,
      ownKeys
    };
    var readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
        return true;
      },
      deleteProperty(target, key) {
        return true;
      }
    };
    var shallowReactiveHandlers = /* @__PURE__ */ shared.extend({}, mutableHandlers, {
      get: shallowGet,
      set: shallowSet
    });
    var shallowReadonlyHandlers = /* @__PURE__ */ shared.extend({}, readonlyHandlers, {
      get: shallowReadonlyGet
    });
    var toShallow = (value) => value;
    var getProto = (v) => Reflect.getPrototypeOf(v);
    function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (key !== rawKey) {
        !isReadonly2 && track(rawTarget, "get", key);
      }
      !isReadonly2 && track(rawTarget, "get", rawKey);
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has$1(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (key !== rawKey) {
        !isReadonly2 && track(rawTarget, "has", key);
      }
      !isReadonly2 && track(rawTarget, "has", rawKey);
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$1(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (shared.hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = shared.isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        return {
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$1(this, key);
        },
        get size() {
          return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$1(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$1(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$1(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(shared.hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
      };
    }
    var mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    var shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    var readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    var shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    var reactiveMap = /* @__PURE__ */ new WeakMap();
    var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    var readonlyMap = /* @__PURE__ */ new WeakMap();
    var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(shared.toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
    }
    function shallowReactive(target) {
      return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
    }
    function readonly(target) {
      return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
    }
    function shallowReadonly(target) {
      return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!shared.isObject(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      shared.def(value, "__v_skip", true);
      return value;
    }
    var toReactive = (value) => shared.isObject(value) ? reactive(value) : value;
    var toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        {
          trackEffects(ref2.dep || (ref2.dep = createDep()));
        }
      }
    }
    function triggerRefValue(ref2, newVal) {
      ref2 = toRaw(ref2);
      if (ref2.dep) {
        {
          triggerEffects(ref2.dep);
        }
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    var RefImpl = class {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
        if (shared.hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = this.__v_isShallow ? newVal : toReactive(newVal);
          triggerRefValue(this);
        }
      }
    };
    function triggerRef(ref2) {
      triggerRefValue(ref2);
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    var shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    var CustomRefImpl = class {
      constructor(factory) {
        this.dep = void 0;
        this.__v_isRef = true;
        const { get: get2, set: set2 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = get2;
        this._set = set2;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    };
    function customRef(factory) {
      return new CustomRefImpl(factory);
    }
    function toRefs(object) {
      const ret = shared.isArray(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = toRef(object, key);
      }
      return ret;
    }
    var ObjectRefImpl = class {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
    };
    function toRef(object, key, defaultValue) {
      const val = object[key];
      return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
    }
    var ComputedRefImpl = class {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
          if (!this._dirty) {
            this._dirty = true;
            triggerRefValue(this);
          }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        trackRefValue(self2);
        if (self2._dirty || !self2._cacheable) {
          self2._dirty = false;
          self2._value = self2.effect.run();
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    };
    function computed(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = shared.isFunction(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = shared.NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    var _a2;
    var tick = Promise.resolve();
    var queue = [];
    var queued = false;
    var scheduler = (fn) => {
      queue.push(fn);
      if (!queued) {
        queued = true;
        tick.then(flush);
      }
    };
    var flush = () => {
      for (let i = 0; i < queue.length; i++) {
        queue[i]();
      }
      queue.length = 0;
      queued = false;
    };
    var DeferredComputedRefImpl = class {
      constructor(getter) {
        this.dep = void 0;
        this._dirty = true;
        this.__v_isRef = true;
        this[_a2] = true;
        let compareTarget;
        let hasCompareTarget = false;
        let scheduled = false;
        this.effect = new ReactiveEffect(getter, (computedTrigger) => {
          if (this.dep) {
            if (computedTrigger) {
              compareTarget = this._value;
              hasCompareTarget = true;
            } else if (!scheduled) {
              const valueToCompare = hasCompareTarget ? compareTarget : this._value;
              scheduled = true;
              hasCompareTarget = false;
              scheduler(() => {
                if (this.effect.active && this._get() !== valueToCompare) {
                  triggerRefValue(this);
                }
                scheduled = false;
              });
            }
            for (const e of this.dep) {
              if (e.computed instanceof DeferredComputedRefImpl) {
                e.scheduler(true);
              }
            }
          }
          this._dirty = true;
        });
        this.effect.computed = this;
      }
      _get() {
        if (this._dirty) {
          this._dirty = false;
          return this._value = this.effect.run();
        }
        return this._value;
      }
      get value() {
        trackRefValue(this);
        return toRaw(this)._get();
      }
    };
    _a2 = "__v_isReadonly";
    function deferredComputed(getter) {
      return new DeferredComputedRefImpl(getter);
    }
    exports2.EffectScope = EffectScope;
    exports2.ITERATE_KEY = ITERATE_KEY;
    exports2.ReactiveEffect = ReactiveEffect;
    exports2.computed = computed;
    exports2.customRef = customRef;
    exports2.deferredComputed = deferredComputed;
    exports2.effect = effect;
    exports2.effectScope = effectScope;
    exports2.enableTracking = enableTracking;
    exports2.getCurrentScope = getCurrentScope;
    exports2.isProxy = isProxy;
    exports2.isReactive = isReactive;
    exports2.isReadonly = isReadonly;
    exports2.isRef = isRef;
    exports2.isShallow = isShallow;
    exports2.markRaw = markRaw;
    exports2.onScopeDispose = onScopeDispose;
    exports2.pauseTracking = pauseTracking;
    exports2.proxyRefs = proxyRefs;
    exports2.reactive = reactive;
    exports2.readonly = readonly;
    exports2.ref = ref;
    exports2.resetTracking = resetTracking;
    exports2.shallowReactive = shallowReactive;
    exports2.shallowReadonly = shallowReadonly;
    exports2.shallowRef = shallowRef;
    exports2.stop = stop;
    exports2.toRaw = toRaw;
    exports2.toRef = toRef;
    exports2.toRefs = toRefs;
    exports2.track = track;
    exports2.trigger = trigger;
    exports2.triggerRef = triggerRef;
    exports2.unref = unref;
  }
});

// ../../node_modules/.pnpm/@vue+reactivity@3.2.31/node_modules/@vue/reactivity/index.js
var require_reactivity = __commonJS({
  "../../node_modules/.pnpm/@vue+reactivity@3.2.31/node_modules/@vue/reactivity/index.js"(exports2, module2) {
    "use strict";
    if (true) {
      module2.exports = require_reactivity_cjs_prod();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/.pnpm/vscode-nls@5.0.0/node_modules/vscode-nls/lib/common/ral.js
var require_ral2 = __commonJS({
  "../../node_modules/.pnpm/vscode-nls@5.0.0/node_modules/vscode-nls/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error("No runtime abstraction layer installed");
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error("No runtime abstraction layer provided");
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// ../../node_modules/.pnpm/vscode-nls@5.0.0/node_modules/vscode-nls/lib/common/common.js
var require_common2 = __commonJS({
  "../../node_modules/.pnpm/vscode-nls@5.0.0/node_modules/vscode-nls/lib/common/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = exports2.loadMessageBundle = exports2.localize = exports2.format = exports2.setPseudo = exports2.isPseudo = exports2.isDefined = exports2.BundleFormat = exports2.MessageFormat = void 0;
    var ral_1 = require_ral2();
    var MessageFormat;
    (function(MessageFormat2) {
      MessageFormat2["file"] = "file";
      MessageFormat2["bundle"] = "bundle";
      MessageFormat2["both"] = "both";
    })(MessageFormat = exports2.MessageFormat || (exports2.MessageFormat = {}));
    var BundleFormat;
    (function(BundleFormat2) {
      BundleFormat2["standalone"] = "standalone";
      BundleFormat2["languagePack"] = "languagePack";
    })(BundleFormat = exports2.BundleFormat || (exports2.BundleFormat = {}));
    var LocalizeInfo;
    (function(LocalizeInfo2) {
      function is(value) {
        var candidate = value;
        return candidate && isDefined2(candidate.key) && isDefined2(candidate.comment);
      }
      LocalizeInfo2.is = is;
    })(LocalizeInfo || (LocalizeInfo = {}));
    function isDefined2(value) {
      return typeof value !== "undefined";
    }
    exports2.isDefined = isDefined2;
    exports2.isPseudo = false;
    function setPseudo(pseudo) {
      exports2.isPseudo = pseudo;
    }
    exports2.setPseudo = setPseudo;
    function format2(message, args) {
      var result;
      if (exports2.isPseudo) {
        message = "\uFF3B" + message.replace(/[aouei]/g, "$&$&") + "\uFF3D";
      }
      if (args.length === 0) {
        result = message;
      } else {
        result = message.replace(/\{(\d+)\}/g, function(match, rest) {
          var index = rest[0];
          var arg = args[index];
          var replacement = match;
          if (typeof arg === "string") {
            replacement = arg;
          } else if (typeof arg === "number" || typeof arg === "boolean" || arg === void 0 || arg === null) {
            replacement = String(arg);
          }
          return replacement;
        });
      }
      return result;
    }
    exports2.format = format2;
    function localize4(_key, message) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      return format2(message, args);
    }
    exports2.localize = localize4;
    function loadMessageBundle4(file) {
      return ral_1.default().loadMessageBundle(file);
    }
    exports2.loadMessageBundle = loadMessageBundle4;
    function config(opts) {
      return ral_1.default().config(opts);
    }
    exports2.config = config;
  }
});

// ../../node_modules/.pnpm/vscode-nls@5.0.0/node_modules/vscode-nls/lib/node/main.js
var require_main4 = __commonJS({
  "../../node_modules/.pnpm/vscode-nls@5.0.0/node_modules/vscode-nls/lib/node/main.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = exports2.loadMessageBundle = void 0;
    var path = require("path");
    var fs = require("fs");
    var ral_1 = require_ral2();
    var common_12 = require_common2();
    var common_2 = require_common2();
    Object.defineProperty(exports2, "MessageFormat", { enumerable: true, get: function() {
      return common_2.MessageFormat;
    } });
    Object.defineProperty(exports2, "BundleFormat", { enumerable: true, get: function() {
      return common_2.BundleFormat;
    } });
    var toString = Object.prototype.toString;
    function isNumber(value) {
      return toString.call(value) === "[object Number]";
    }
    function isString(value) {
      return toString.call(value) === "[object String]";
    }
    function isBoolean(value) {
      return value === true || value === false;
    }
    function readJsonFileSync(filename) {
      return JSON.parse(fs.readFileSync(filename, "utf8"));
    }
    var resolvedBundles;
    var options;
    function initializeSettings() {
      options = { locale: void 0, language: void 0, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: common_12.MessageFormat.bundle };
      if (isString(process.env.VSCODE_NLS_CONFIG)) {
        try {
          var vscodeOptions_1 = JSON.parse(process.env.VSCODE_NLS_CONFIG);
          var language = void 0;
          if (vscodeOptions_1.availableLanguages) {
            var value = vscodeOptions_1.availableLanguages["*"];
            if (isString(value)) {
              language = value;
            }
          }
          if (isString(vscodeOptions_1.locale)) {
            options.locale = vscodeOptions_1.locale.toLowerCase();
          }
          if (language === void 0) {
            options.language = options.locale;
          } else if (language !== "en") {
            options.language = language;
          }
          if (isBoolean(vscodeOptions_1._languagePackSupport)) {
            options.languagePackSupport = vscodeOptions_1._languagePackSupport;
          }
          if (isString(vscodeOptions_1._cacheRoot)) {
            options.cacheRoot = vscodeOptions_1._cacheRoot;
          }
          if (isString(vscodeOptions_1._languagePackId)) {
            options.languagePackId = vscodeOptions_1._languagePackId;
          }
          if (isString(vscodeOptions_1._translationsConfigFile)) {
            options.translationsConfigFile = vscodeOptions_1._translationsConfigFile;
            try {
              options.translationsConfig = readJsonFileSync(options.translationsConfigFile);
            } catch (error) {
              if (vscodeOptions_1._corruptedFile) {
                var dirname = path.dirname(vscodeOptions_1._corruptedFile);
                fs.exists(dirname, function(exists) {
                  if (exists) {
                    fs.writeFile(vscodeOptions_1._corruptedFile, "corrupted", "utf8", function(err) {
                      console.error(err);
                    });
                  }
                });
              }
            }
          }
        } catch (_a2) {
        }
      }
      common_12.setPseudo(options.locale === "pseudo");
      resolvedBundles = /* @__PURE__ */ Object.create(null);
    }
    initializeSettings();
    function supportsLanguagePack() {
      return options.languagePackSupport === true && options.cacheRoot !== void 0 && options.languagePackId !== void 0 && options.translationsConfigFile !== void 0 && options.translationsConfig !== void 0;
    }
    function createScopedLocalizeFunction(messages) {
      return function(key, message) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        if (isNumber(key)) {
          if (key >= messages.length) {
            console.error("Broken localize call found. Index out of bounds. Stacktrace is\n: " + new Error("").stack);
            return;
          }
          return common_12.format(messages[key], args);
        } else {
          if (isString(message)) {
            console.warn("Message " + message + " didn't get externalized correctly.");
            return common_12.format(message, args);
          } else {
            console.error("Broken localize call found. Stacktrace is\n: " + new Error("").stack);
          }
        }
      };
    }
    function resolveLanguage(file) {
      var resolvedLanguage;
      if (options.cacheLanguageResolution && resolvedLanguage) {
        resolvedLanguage = resolvedLanguage;
      } else {
        if (common_12.isPseudo || !options.language) {
          resolvedLanguage = ".nls.json";
        } else {
          var locale = options.language;
          while (locale) {
            var candidate = ".nls." + locale + ".json";
            if (fs.existsSync(file + candidate)) {
              resolvedLanguage = candidate;
              break;
            } else {
              var index = locale.lastIndexOf("-");
              if (index > 0) {
                locale = locale.substring(0, index);
              } else {
                resolvedLanguage = ".nls.json";
                locale = null;
              }
            }
          }
        }
        if (options.cacheLanguageResolution) {
          resolvedLanguage = resolvedLanguage;
        }
      }
      return file + resolvedLanguage;
    }
    function findInTheBoxBundle(root) {
      var language = options.language;
      while (language) {
        var candidate = path.join(root, "nls.bundle." + language + ".json");
        if (fs.existsSync(candidate)) {
          return candidate;
        } else {
          var index = language.lastIndexOf("-");
          if (index > 0) {
            language = language.substring(0, index);
          } else {
            language = void 0;
          }
        }
      }
      if (language === void 0) {
        var candidate = path.join(root, "nls.bundle.json");
        if (fs.existsSync(candidate)) {
          return candidate;
        }
      }
      return void 0;
    }
    function createDefaultNlsBundle(folder) {
      var metaData = readJsonFileSync(path.join(folder, "nls.metadata.json"));
      var result = /* @__PURE__ */ Object.create(null);
      for (var module_1 in metaData) {
        var entry = metaData[module_1];
        result[module_1] = entry.messages;
      }
      return result;
    }
    function createNLSBundle(header, metaDataPath) {
      var languagePackLocation = options.translationsConfig[header.id];
      if (!languagePackLocation) {
        return void 0;
      }
      var languagePack = readJsonFileSync(languagePackLocation).contents;
      var metaData = readJsonFileSync(path.join(metaDataPath, "nls.metadata.json"));
      var result = /* @__PURE__ */ Object.create(null);
      for (var module_2 in metaData) {
        var entry = metaData[module_2];
        var translations = languagePack[header.outDir + "/" + module_2];
        if (translations) {
          var resultMessages = [];
          for (var i = 0; i < entry.keys.length; i++) {
            var messageKey = entry.keys[i];
            var key = isString(messageKey) ? messageKey : messageKey.key;
            var translatedMessage = translations[key];
            if (translatedMessage === void 0) {
              translatedMessage = entry.messages[i];
            }
            resultMessages.push(translatedMessage);
          }
          result[module_2] = resultMessages;
        } else {
          result[module_2] = entry.messages;
        }
      }
      return result;
    }
    function touch(file) {
      var d = new Date();
      fs.utimes(file, d, d, function() {
      });
    }
    function cacheBundle(key, bundle) {
      resolvedBundles[key] = bundle;
      return bundle;
    }
    function loadNlsBundleOrCreateFromI18n(header, bundlePath) {
      var result;
      var bundle = path.join(options.cacheRoot, header.id + "-" + header.hash + ".json");
      var useMemoryOnly = false;
      var writeBundle = false;
      try {
        result = JSON.parse(fs.readFileSync(bundle, { encoding: "utf8", flag: "r" }));
        touch(bundle);
        return result;
      } catch (err) {
        if (err.code === "ENOENT") {
          writeBundle = true;
        } else if (err instanceof SyntaxError) {
          console.log("Syntax error parsing message bundle: " + err.message + ".");
          fs.unlink(bundle, function(err2) {
            if (err2) {
              console.error("Deleting corrupted bundle " + bundle + " failed.");
            }
          });
          useMemoryOnly = true;
        } else {
          throw err;
        }
      }
      result = createNLSBundle(header, bundlePath);
      if (!result || useMemoryOnly) {
        return result;
      }
      if (writeBundle) {
        try {
          fs.writeFileSync(bundle, JSON.stringify(result), { encoding: "utf8", flag: "wx" });
        } catch (err) {
          if (err.code === "EEXIST") {
            return result;
          }
          throw err;
        }
      }
      return result;
    }
    function loadDefaultNlsBundle(bundlePath) {
      try {
        return createDefaultNlsBundle(bundlePath);
      } catch (err) {
        console.log("Generating default bundle from meta data failed.", err);
        return void 0;
      }
    }
    function loadNlsBundle(header, bundlePath) {
      var result;
      if (supportsLanguagePack()) {
        try {
          result = loadNlsBundleOrCreateFromI18n(header, bundlePath);
        } catch (err) {
          console.log("Load or create bundle failed ", err);
        }
      }
      if (!result) {
        if (options.languagePackSupport) {
          return loadDefaultNlsBundle(bundlePath);
        }
        var candidate = findInTheBoxBundle(bundlePath);
        if (candidate) {
          try {
            return readJsonFileSync(candidate);
          } catch (err) {
            console.log("Loading in the box message bundle failed.", err);
          }
        }
        result = loadDefaultNlsBundle(bundlePath);
      }
      return result;
    }
    function tryFindMetaDataHeaderFile(file) {
      var result;
      var dirname = path.dirname(file);
      while (true) {
        result = path.join(dirname, "nls.metadata.header.json");
        if (fs.existsSync(result)) {
          break;
        }
        var parent = path.dirname(dirname);
        if (parent === dirname) {
          result = void 0;
          break;
        } else {
          dirname = parent;
        }
      }
      return result;
    }
    function loadMessageBundle4(file) {
      if (!file) {
        return common_12.localize;
      }
      var ext = path.extname(file);
      if (ext) {
        file = file.substr(0, file.length - ext.length);
      }
      if (options.messageFormat === common_12.MessageFormat.both || options.messageFormat === common_12.MessageFormat.bundle) {
        var headerFile = tryFindMetaDataHeaderFile(file);
        if (headerFile) {
          var bundlePath = path.dirname(headerFile);
          var bundle = resolvedBundles[bundlePath];
          if (bundle === void 0) {
            try {
              var header = JSON.parse(fs.readFileSync(headerFile, "utf8"));
              try {
                var nlsBundle = loadNlsBundle(header, bundlePath);
                bundle = cacheBundle(bundlePath, nlsBundle ? { header, nlsBundle } : null);
              } catch (err) {
                console.error("Failed to load nls bundle", err);
                bundle = cacheBundle(bundlePath, null);
              }
            } catch (err) {
              console.error("Failed to read header file", err);
              bundle = cacheBundle(bundlePath, null);
            }
          }
          if (bundle) {
            var module_3 = file.substr(bundlePath.length + 1).replace(/\\/g, "/");
            var messages = bundle.nlsBundle[module_3];
            if (messages === void 0) {
              console.error("Messages for file " + file + " not found. See console for details.");
              return function() {
                return "Messages not found.";
              };
            }
            return createScopedLocalizeFunction(messages);
          }
        }
      }
      if (options.messageFormat === common_12.MessageFormat.both || options.messageFormat === common_12.MessageFormat.file) {
        try {
          var json = readJsonFileSync(resolveLanguage(file));
          if (Array.isArray(json)) {
            return createScopedLocalizeFunction(json);
          } else {
            if (common_12.isDefined(json.messages) && common_12.isDefined(json.keys)) {
              return createScopedLocalizeFunction(json.messages);
            } else {
              console.error("String bundle '" + file + "' uses an unsupported format.");
              return function() {
                return "File bundle has unsupported format. See console for details";
              };
            }
          }
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.error("Failed to load single file bundle", err);
          }
        }
      }
      console.error("Failed to load message bundle for file " + file);
      return function() {
        return "Failed to load message bundle. See console for details.";
      };
    }
    exports2.loadMessageBundle = loadMessageBundle4;
    function config(opts) {
      if (opts) {
        if (isString(opts.locale)) {
          options.locale = opts.locale.toLowerCase();
          options.language = options.locale;
          resolvedBundles = /* @__PURE__ */ Object.create(null);
        }
        if (opts.messageFormat !== void 0) {
          options.messageFormat = opts.messageFormat;
        }
        if (opts.bundleFormat === common_12.BundleFormat.standalone && options.languagePackSupport === true) {
          options.languagePackSupport = false;
        }
      }
      common_12.setPseudo(options.locale === "pseudo");
      return loadMessageBundle4;
    }
    exports2.config = config;
    ral_1.default.install(Object.freeze({
      loadMessageBundle: loadMessageBundle4,
      config
    }));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-types@3.16.0/node_modules/vscode-languageserver-types/lib/esm/main.js
var integer2, uinteger2, Position2, Range2, Location2, LocationLink2, Color2, ColorInformation2, ColorPresentation2, FoldingRangeKind2, FoldingRange2, DiagnosticRelatedInformation2, DiagnosticSeverity2, DiagnosticTag2, CodeDescription2, Diagnostic2, Command2, TextEdit2, ChangeAnnotation2, ChangeAnnotationIdentifier2, AnnotatedTextEdit2, TextDocumentEdit2, CreateFile2, RenameFile2, DeleteFile2, WorkspaceEdit2, TextEditChangeImpl2, ChangeAnnotations2, WorkspaceChange2, TextDocumentIdentifier2, VersionedTextDocumentIdentifier2, OptionalVersionedTextDocumentIdentifier2, TextDocumentItem2, MarkupKind2, MarkupContent2, CompletionItemKind2, InsertTextFormat2, CompletionItemTag2, InsertReplaceEdit2, InsertTextMode2, CompletionItem2, CompletionList2, MarkedString2, Hover2, ParameterInformation2, SignatureInformation2, DocumentHighlightKind2, DocumentHighlight2, SymbolKind2, SymbolTag2, SymbolInformation2, DocumentSymbol2, CodeActionKind2, CodeActionContext2, CodeAction2, CodeLens2, FormattingOptions2, DocumentLink2, SelectionRange2, TextDocument2, FullTextDocument2, Is2;
var init_main2 = __esm({
  "../../node_modules/.pnpm/vscode-languageserver-types@3.16.0/node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(integer3) {
      integer3.MIN_VALUE = -2147483648;
      integer3.MAX_VALUE = 2147483647;
    })(integer2 || (integer2 = {}));
    (function(uinteger3) {
      uinteger3.MIN_VALUE = 0;
      uinteger3.MAX_VALUE = 2147483647;
    })(uinteger2 || (uinteger2 = {}));
    (function(Position3) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger2.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger2.MAX_VALUE;
        }
        return { line, character };
      }
      Position3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.line) && Is2.uinteger(candidate.character);
      }
      Position3.is = is;
    })(Position2 || (Position2 = {}));
    (function(Range3) {
      function create(one, two, three, four) {
        if (Is2.uinteger(one) && Is2.uinteger(two) && Is2.uinteger(three) && Is2.uinteger(four)) {
          return { start: Position2.create(one, two), end: Position2.create(three, four) };
        } else if (Position2.is(one) && Position2.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
      }
      Range3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
      }
      Range3.is = is;
    })(Range2 || (Range2 = {}));
    (function(Location3) {
      function create(uri, range) {
        return { uri, range };
      }
      Location3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Range2.is(candidate.range) && (Is2.string(candidate.uri) || Is2.undefined(candidate.uri));
      }
      Location3.is = is;
    })(Location2 || (Location2 = {}));
    (function(LocationLink3) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Range2.is(candidate.targetRange) && Is2.string(candidate.targetUri) && (Range2.is(candidate.targetSelectionRange) || Is2.undefined(candidate.targetSelectionRange)) && (Range2.is(candidate.originSelectionRange) || Is2.undefined(candidate.originSelectionRange));
      }
      LocationLink3.is = is;
    })(LocationLink2 || (LocationLink2 = {}));
    (function(Color3) {
      function create(red, green, blue, alpha) {
        return {
          red,
          green,
          blue,
          alpha
        };
      }
      Color3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.numberRange(candidate.red, 0, 1) && Is2.numberRange(candidate.green, 0, 1) && Is2.numberRange(candidate.blue, 0, 1) && Is2.numberRange(candidate.alpha, 0, 1);
      }
      Color3.is = is;
    })(Color2 || (Color2 = {}));
    (function(ColorInformation3) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation3.create = create;
      function is(value) {
        var candidate = value;
        return Range2.is(candidate.range) && Color2.is(candidate.color);
      }
      ColorInformation3.is = is;
    })(ColorInformation2 || (ColorInformation2 = {}));
    (function(ColorPresentation3) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.string(candidate.label) && (Is2.undefined(candidate.textEdit) || TextEdit2.is(candidate)) && (Is2.undefined(candidate.additionalTextEdits) || Is2.typedArray(candidate.additionalTextEdits, TextEdit2.is));
      }
      ColorPresentation3.is = is;
    })(ColorPresentation2 || (ColorPresentation2 = {}));
    (function(FoldingRangeKind3) {
      FoldingRangeKind3["Comment"] = "comment";
      FoldingRangeKind3["Imports"] = "imports";
      FoldingRangeKind3["Region"] = "region";
    })(FoldingRangeKind2 || (FoldingRangeKind2 = {}));
    (function(FoldingRange3) {
      function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
          startLine,
          endLine
        };
        if (Is2.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is2.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is2.defined(kind)) {
          result.kind = kind;
        }
        return result;
      }
      FoldingRange3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.uinteger(candidate.startLine) && Is2.uinteger(candidate.startLine) && (Is2.undefined(candidate.startCharacter) || Is2.uinteger(candidate.startCharacter)) && (Is2.undefined(candidate.endCharacter) || Is2.uinteger(candidate.endCharacter)) && (Is2.undefined(candidate.kind) || Is2.string(candidate.kind));
      }
      FoldingRange3.is = is;
    })(FoldingRange2 || (FoldingRange2 = {}));
    (function(DiagnosticRelatedInformation3) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Location2.is(candidate.location) && Is2.string(candidate.message);
      }
      DiagnosticRelatedInformation3.is = is;
    })(DiagnosticRelatedInformation2 || (DiagnosticRelatedInformation2 = {}));
    (function(DiagnosticSeverity3) {
      DiagnosticSeverity3.Error = 1;
      DiagnosticSeverity3.Warning = 2;
      DiagnosticSeverity3.Information = 3;
      DiagnosticSeverity3.Hint = 4;
    })(DiagnosticSeverity2 || (DiagnosticSeverity2 = {}));
    (function(DiagnosticTag3) {
      DiagnosticTag3.Unnecessary = 1;
      DiagnosticTag3.Deprecated = 2;
    })(DiagnosticTag2 || (DiagnosticTag2 = {}));
    (function(CodeDescription3) {
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Is2.string(candidate.href);
      }
      CodeDescription3.is = is;
    })(CodeDescription2 || (CodeDescription2 = {}));
    (function(Diagnostic3) {
      function create(range, message, severity, code, source, relatedInformation) {
        var result = { range, message };
        if (Is2.defined(severity)) {
          result.severity = severity;
        }
        if (Is2.defined(code)) {
          result.code = code;
        }
        if (Is2.defined(source)) {
          result.source = source;
        }
        if (Is2.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic3.create = create;
      function is(value) {
        var _a2;
        var candidate = value;
        return Is2.defined(candidate) && Range2.is(candidate.range) && Is2.string(candidate.message) && (Is2.number(candidate.severity) || Is2.undefined(candidate.severity)) && (Is2.integer(candidate.code) || Is2.string(candidate.code) || Is2.undefined(candidate.code)) && (Is2.undefined(candidate.codeDescription) || Is2.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is2.string(candidate.source) || Is2.undefined(candidate.source)) && (Is2.undefined(candidate.relatedInformation) || Is2.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation2.is));
      }
      Diagnostic3.is = is;
    })(Diagnostic2 || (Diagnostic2 = {}));
    (function(Command3) {
      function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is2.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Is2.string(candidate.title) && Is2.string(candidate.command);
      }
      Command3.is = is;
    })(Command2 || (Command2 = {}));
    (function(TextEdit3) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit3.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit3.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit3.del = del;
      function is(value) {
        var candidate = value;
        return Is2.objectLiteral(candidate) && Is2.string(candidate.newText) && Range2.is(candidate.range);
      }
      TextEdit3.is = is;
    })(TextEdit2 || (TextEdit2 = {}));
    (function(ChangeAnnotation3) {
      function create(label, needsConfirmation, description) {
        var result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation3.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation3.is = is;
    })(ChangeAnnotation2 || (ChangeAnnotation2 = {}));
    (function(ChangeAnnotationIdentifier3) {
      function is(value) {
        var candidate = value;
        return typeof candidate === "string";
      }
      ChangeAnnotationIdentifier3.is = is;
    })(ChangeAnnotationIdentifier2 || (ChangeAnnotationIdentifier2 = {}));
    (function(AnnotatedTextEdit3) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit3.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit3.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit3.del = del;
      function is(value) {
        var candidate = value;
        return TextEdit2.is(candidate) && (ChangeAnnotation2.is(candidate.annotationId) || ChangeAnnotationIdentifier2.is(candidate.annotationId));
      }
      AnnotatedTextEdit3.is = is;
    })(AnnotatedTextEdit2 || (AnnotatedTextEdit2 = {}));
    (function(TextDocumentEdit3) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && OptionalVersionedTextDocumentIdentifier2.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit3.is = is;
    })(TextDocumentEdit2 || (TextDocumentEdit2 = {}));
    (function(CreateFile3) {
      function create(uri, options, annotation) {
        var result = {
          kind: "create",
          uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
      }
      CreateFile3.is = is;
    })(CreateFile2 || (CreateFile2 = {}));
    (function(RenameFile3) {
      function create(oldUri, newUri, options, annotation) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is2.string(candidate.oldUri) && Is2.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
      }
      RenameFile3.is = is;
    })(RenameFile2 || (RenameFile2 = {}));
    (function(DeleteFile3) {
      function create(uri, options, annotation) {
        var result = {
          kind: "delete",
          uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is2.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is2.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
      }
      DeleteFile3.is = is;
    })(DeleteFile2 || (DeleteFile2 = {}));
    (function(WorkspaceEdit3) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
          if (Is2.string(change.kind)) {
            return CreateFile2.is(change) || RenameFile2.is(change) || DeleteFile2.is(change);
          } else {
            return TextDocumentEdit2.is(change);
          }
        }));
      }
      WorkspaceEdit3.is = is;
    })(WorkspaceEdit2 || (WorkspaceEdit2 = {}));
    TextEditChangeImpl2 = function() {
      function TextEditChangeImpl3(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl3.prototype.insert = function(position, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit2.insert(position, newText);
        } else if (ChangeAnnotationIdentifier2.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit2.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit2.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl3.prototype.replace = function(range, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit2.replace(range, newText);
        } else if (ChangeAnnotationIdentifier2.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit2.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit2.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl3.prototype.delete = function(range, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit2.del(range);
        } else if (ChangeAnnotationIdentifier2.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit2.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit2.del(range, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl3.prototype.add = function(edit) {
        this.edits.push(edit);
      };
      TextEditChangeImpl3.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl3.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl3.prototype.assertChangeAnnotations = function(value) {
        if (value === void 0) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl3;
    }();
    ChangeAnnotations2 = function() {
      function ChangeAnnotations3(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations3.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations3.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations3.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier2.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === void 0) {
          throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations3.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations3;
    }();
    WorkspaceChange2 = function() {
      function WorkspaceChange3(workspaceEdit) {
        var _this = this;
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations2(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit2.is(change)) {
                var textEditChange = new TextEditChangeImpl2(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl2(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange3.prototype, "edit", {
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange3.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier2.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl2(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl2(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange3.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations2();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange3.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      };
      WorkspaceChange3.prototype.createFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = CreateFile2.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile2.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange3.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = RenameFile2.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile2.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange3.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation2.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = DeleteFile2.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile2.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      return WorkspaceChange3;
    }();
    (function(TextDocumentIdentifier3) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Is2.string(candidate.uri);
      }
      TextDocumentIdentifier3.is = is;
    })(TextDocumentIdentifier2 || (TextDocumentIdentifier2 = {}));
    (function(VersionedTextDocumentIdentifier3) {
      function create(uri, version) {
        return { uri, version };
      }
      VersionedTextDocumentIdentifier3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier3.is = is;
    })(VersionedTextDocumentIdentifier2 || (VersionedTextDocumentIdentifier2 = {}));
    (function(OptionalVersionedTextDocumentIdentifier3) {
      function create(uri, version) {
        return { uri, version };
      }
      OptionalVersionedTextDocumentIdentifier3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Is2.string(candidate.uri) && (candidate.version === null || Is2.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier3.is = is;
    })(OptionalVersionedTextDocumentIdentifier2 || (OptionalVersionedTextDocumentIdentifier2 = {}));
    (function(TextDocumentItem3) {
      function create(uri, languageId, version, text) {
        return { uri, languageId, version, text };
      }
      TextDocumentItem3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.string(candidate.languageId) && Is2.integer(candidate.version) && Is2.string(candidate.text);
      }
      TextDocumentItem3.is = is;
    })(TextDocumentItem2 || (TextDocumentItem2 = {}));
    (function(MarkupKind3) {
      MarkupKind3.PlainText = "plaintext";
      MarkupKind3.Markdown = "markdown";
    })(MarkupKind2 || (MarkupKind2 = {}));
    (function(MarkupKind3) {
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind3.PlainText || candidate === MarkupKind3.Markdown;
      }
      MarkupKind3.is = is;
    })(MarkupKind2 || (MarkupKind2 = {}));
    (function(MarkupContent3) {
      function is(value) {
        var candidate = value;
        return Is2.objectLiteral(value) && MarkupKind2.is(candidate.kind) && Is2.string(candidate.value);
      }
      MarkupContent3.is = is;
    })(MarkupContent2 || (MarkupContent2 = {}));
    (function(CompletionItemKind3) {
      CompletionItemKind3.Text = 1;
      CompletionItemKind3.Method = 2;
      CompletionItemKind3.Function = 3;
      CompletionItemKind3.Constructor = 4;
      CompletionItemKind3.Field = 5;
      CompletionItemKind3.Variable = 6;
      CompletionItemKind3.Class = 7;
      CompletionItemKind3.Interface = 8;
      CompletionItemKind3.Module = 9;
      CompletionItemKind3.Property = 10;
      CompletionItemKind3.Unit = 11;
      CompletionItemKind3.Value = 12;
      CompletionItemKind3.Enum = 13;
      CompletionItemKind3.Keyword = 14;
      CompletionItemKind3.Snippet = 15;
      CompletionItemKind3.Color = 16;
      CompletionItemKind3.File = 17;
      CompletionItemKind3.Reference = 18;
      CompletionItemKind3.Folder = 19;
      CompletionItemKind3.EnumMember = 20;
      CompletionItemKind3.Constant = 21;
      CompletionItemKind3.Struct = 22;
      CompletionItemKind3.Event = 23;
      CompletionItemKind3.Operator = 24;
      CompletionItemKind3.TypeParameter = 25;
    })(CompletionItemKind2 || (CompletionItemKind2 = {}));
    (function(InsertTextFormat3) {
      InsertTextFormat3.PlainText = 1;
      InsertTextFormat3.Snippet = 2;
    })(InsertTextFormat2 || (InsertTextFormat2 = {}));
    (function(CompletionItemTag3) {
      CompletionItemTag3.Deprecated = 1;
    })(CompletionItemTag2 || (CompletionItemTag2 = {}));
    (function(InsertReplaceEdit3) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is2.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
      }
      InsertReplaceEdit3.is = is;
    })(InsertReplaceEdit2 || (InsertReplaceEdit2 = {}));
    (function(InsertTextMode3) {
      InsertTextMode3.asIs = 1;
      InsertTextMode3.adjustIndentation = 2;
    })(InsertTextMode2 || (InsertTextMode2 = {}));
    (function(CompletionItem3) {
      function create(label) {
        return { label };
      }
      CompletionItem3.create = create;
    })(CompletionItem2 || (CompletionItem2 = {}));
    (function(CompletionList3) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList3.create = create;
    })(CompletionList2 || (CompletionList2 = {}));
    (function(MarkedString3) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString3.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is2.string(candidate) || Is2.objectLiteral(candidate) && Is2.string(candidate.language) && Is2.string(candidate.value);
      }
      MarkedString3.is = is;
    })(MarkedString2 || (MarkedString2 = {}));
    (function(Hover3) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is2.objectLiteral(candidate) && (MarkupContent2.is(candidate.contents) || MarkedString2.is(candidate.contents) || Is2.typedArray(candidate.contents, MarkedString2.is)) && (value.range === void 0 || Range2.is(value.range));
      }
      Hover3.is = is;
    })(Hover2 || (Hover2 = {}));
    (function(ParameterInformation3) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation3.create = create;
    })(ParameterInformation2 || (ParameterInformation2 = {}));
    (function(SignatureInformation3) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is2.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is2.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation3.create = create;
    })(SignatureInformation2 || (SignatureInformation2 = {}));
    (function(DocumentHighlightKind3) {
      DocumentHighlightKind3.Text = 1;
      DocumentHighlightKind3.Read = 2;
      DocumentHighlightKind3.Write = 3;
    })(DocumentHighlightKind2 || (DocumentHighlightKind2 = {}));
    (function(DocumentHighlight3) {
      function create(range, kind) {
        var result = { range };
        if (Is2.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight3.create = create;
    })(DocumentHighlight2 || (DocumentHighlight2 = {}));
    (function(SymbolKind3) {
      SymbolKind3.File = 1;
      SymbolKind3.Module = 2;
      SymbolKind3.Namespace = 3;
      SymbolKind3.Package = 4;
      SymbolKind3.Class = 5;
      SymbolKind3.Method = 6;
      SymbolKind3.Property = 7;
      SymbolKind3.Field = 8;
      SymbolKind3.Constructor = 9;
      SymbolKind3.Enum = 10;
      SymbolKind3.Interface = 11;
      SymbolKind3.Function = 12;
      SymbolKind3.Variable = 13;
      SymbolKind3.Constant = 14;
      SymbolKind3.String = 15;
      SymbolKind3.Number = 16;
      SymbolKind3.Boolean = 17;
      SymbolKind3.Array = 18;
      SymbolKind3.Object = 19;
      SymbolKind3.Key = 20;
      SymbolKind3.Null = 21;
      SymbolKind3.EnumMember = 22;
      SymbolKind3.Struct = 23;
      SymbolKind3.Event = 24;
      SymbolKind3.Operator = 25;
      SymbolKind3.TypeParameter = 26;
    })(SymbolKind2 || (SymbolKind2 = {}));
    (function(SymbolTag3) {
      SymbolTag3.Deprecated = 1;
    })(SymbolTag2 || (SymbolTag2 = {}));
    (function(SymbolInformation3) {
      function create(name, kind, range, uri, containerName) {
        var result = {
          name,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation3.create = create;
    })(SymbolInformation2 || (SymbolInformation2 = {}));
    (function(DocumentSymbol3) {
      function create(name, detail, kind, range, selectionRange, children) {
        var result = {
          name,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is2.string(candidate.name) && Is2.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is2.string(candidate.detail)) && (candidate.deprecated === void 0 || Is2.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol3.is = is;
    })(DocumentSymbol2 || (DocumentSymbol2 = {}));
    (function(CodeActionKind3) {
      CodeActionKind3.Empty = "";
      CodeActionKind3.QuickFix = "quickfix";
      CodeActionKind3.Refactor = "refactor";
      CodeActionKind3.RefactorExtract = "refactor.extract";
      CodeActionKind3.RefactorInline = "refactor.inline";
      CodeActionKind3.RefactorRewrite = "refactor.rewrite";
      CodeActionKind3.Source = "source";
      CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind3.SourceFixAll = "source.fixAll";
    })(CodeActionKind2 || (CodeActionKind2 = {}));
    (function(CodeActionContext3) {
      function create(diagnostics, only) {
        var result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        return result;
      }
      CodeActionContext3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Is2.typedArray(candidate.diagnostics, Diagnostic2.is) && (candidate.only === void 0 || Is2.typedArray(candidate.only, Is2.string));
      }
      CodeActionContext3.is = is;
    })(CodeActionContext2 || (CodeActionContext2 = {}));
    (function(CodeAction3) {
      function create(title, kindOrCommandOrEdit, kind) {
        var result = { title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command2.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is2.string(candidate.title) && (candidate.diagnostics === void 0 || Is2.typedArray(candidate.diagnostics, Diagnostic2.is)) && (candidate.kind === void 0 || Is2.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command2.is(candidate.command)) && (candidate.isPreferred === void 0 || Is2.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit2.is(candidate.edit));
      }
      CodeAction3.is = is;
    })(CodeAction2 || (CodeAction2 = {}));
    (function(CodeLens3) {
      function create(range, data) {
        var result = { range };
        if (Is2.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Range2.is(candidate.range) && (Is2.undefined(candidate.command) || Command2.is(candidate.command));
      }
      CodeLens3.is = is;
    })(CodeLens2 || (CodeLens2 = {}));
    (function(FormattingOptions3) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Is2.uinteger(candidate.tabSize) && Is2.boolean(candidate.insertSpaces);
      }
      FormattingOptions3.is = is;
    })(FormattingOptions2 || (FormattingOptions2 = {}));
    (function(DocumentLink3) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink3.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Range2.is(candidate.range) && (Is2.undefined(candidate.target) || Is2.string(candidate.target));
      }
      DocumentLink3.is = is;
    })(DocumentLink2 || (DocumentLink2 = {}));
    (function(SelectionRange3) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange3.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange3.is(candidate.parent));
      }
      SelectionRange3.is = is;
    })(SelectionRange2 || (SelectionRange2 = {}));
    (function(TextDocument4) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument2(uri, languageId, version, content);
      }
      TextDocument4.create = create;
      function is(value) {
        var candidate = value;
        return Is2.defined(candidate) && Is2.string(candidate.uri) && (Is2.undefined(candidate.languageId) || Is2.string(candidate.languageId)) && Is2.uinteger(candidate.lineCount) && Is2.func(candidate.getText) && Is2.func(candidate.positionAt) && Is2.func(candidate.offsetAt) ? true : false;
      }
      TextDocument4.is = is;
      function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort2(edits, function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document.offsetAt(e.range.start);
          var endOffset = document.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument4.applyEdits = applyEdits;
      function mergeSort2(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort2(left, compare);
        mergeSort2(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument2 || (TextDocument2 = {}));
    FullTextDocument2 = function() {
      function FullTextDocument4(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument4.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument4.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument4.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument4.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument4.prototype.update = function(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = void 0;
      };
      FullTextDocument4.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument4.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position2.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position2.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument4.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument4.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument4;
    }();
    (function(Is3) {
      var toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is3.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is3.undefined = undefined2;
      function boolean(value) {
        return value === true || value === false;
      }
      Is3.boolean = boolean;
      function string(value) {
        return toString.call(value) === "[object String]";
      }
      Is3.string = string;
      function number(value) {
        return toString.call(value) === "[object Number]";
      }
      Is3.number = number;
      function numberRange(value, min, max) {
        return toString.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is3.numberRange = numberRange;
      function integer3(value) {
        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is3.integer = integer3;
      function uinteger3(value) {
        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is3.uinteger = uinteger3;
      function func(value) {
        return toString.call(value) === "[object Function]";
      }
      Is3.func = func;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      Is3.objectLiteral = objectLiteral;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is3.typedArray = typedArray;
    })(Is2 || (Is2 = {}));
  }
});

// ../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.4/node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var main_exports2 = {};
__export(main_exports2, {
  TextDocument: () => TextDocument3
});
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var FullTextDocument3, TextDocument3;
var init_main3 = __esm({
  "../../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.4/node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument3 = class {
      constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          const start = this.offsetAt(range.start);
          const end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(changes, version) {
        for (let change of changes) {
          if (FullTextDocument3.isIncremental(change)) {
            const range = getWellformedRange(change.range);
            const startOffset = this.offsetAt(range.start);
            const endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            const startLine = Math.max(range.start.line, 0);
            const endLine = Math.max(range.end.line, 0);
            let lineOffsets = this._lineOffsets;
            const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            const diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (FullTextDocument3.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
      static isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      static isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
    };
    (function(TextDocument4) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument3(uri, languageId, version, content);
      }
      TextDocument4.create = create;
      function update(document, changes, version) {
        if (document instanceof FullTextDocument3) {
          document.update(changes, version);
          return document;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument4.update = update;
      function applyEdits(document, edits) {
        let text = document.getText();
        let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
          let diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
          let startOffset = document.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument4.applyEdits = applyEdits;
    })(TextDocument3 || (TextDocument3 = {}));
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/htmlLanguageTypes.js
var TokenType, ScannerState, ClientCapabilities, FileType;
var init_htmlLanguageTypes = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/htmlLanguageTypes.js"() {
    init_main2();
    init_main3();
    (function(TokenType2) {
      TokenType2[TokenType2["StartCommentTag"] = 0] = "StartCommentTag";
      TokenType2[TokenType2["Comment"] = 1] = "Comment";
      TokenType2[TokenType2["EndCommentTag"] = 2] = "EndCommentTag";
      TokenType2[TokenType2["StartTagOpen"] = 3] = "StartTagOpen";
      TokenType2[TokenType2["StartTagClose"] = 4] = "StartTagClose";
      TokenType2[TokenType2["StartTagSelfClose"] = 5] = "StartTagSelfClose";
      TokenType2[TokenType2["StartTag"] = 6] = "StartTag";
      TokenType2[TokenType2["EndTagOpen"] = 7] = "EndTagOpen";
      TokenType2[TokenType2["EndTagClose"] = 8] = "EndTagClose";
      TokenType2[TokenType2["EndTag"] = 9] = "EndTag";
      TokenType2[TokenType2["DelimiterAssign"] = 10] = "DelimiterAssign";
      TokenType2[TokenType2["AttributeName"] = 11] = "AttributeName";
      TokenType2[TokenType2["AttributeValue"] = 12] = "AttributeValue";
      TokenType2[TokenType2["StartDoctypeTag"] = 13] = "StartDoctypeTag";
      TokenType2[TokenType2["Doctype"] = 14] = "Doctype";
      TokenType2[TokenType2["EndDoctypeTag"] = 15] = "EndDoctypeTag";
      TokenType2[TokenType2["Content"] = 16] = "Content";
      TokenType2[TokenType2["Whitespace"] = 17] = "Whitespace";
      TokenType2[TokenType2["Unknown"] = 18] = "Unknown";
      TokenType2[TokenType2["Script"] = 19] = "Script";
      TokenType2[TokenType2["Styles"] = 20] = "Styles";
      TokenType2[TokenType2["EOS"] = 21] = "EOS";
    })(TokenType || (TokenType = {}));
    (function(ScannerState2) {
      ScannerState2[ScannerState2["WithinContent"] = 0] = "WithinContent";
      ScannerState2[ScannerState2["AfterOpeningStartTag"] = 1] = "AfterOpeningStartTag";
      ScannerState2[ScannerState2["AfterOpeningEndTag"] = 2] = "AfterOpeningEndTag";
      ScannerState2[ScannerState2["WithinDoctype"] = 3] = "WithinDoctype";
      ScannerState2[ScannerState2["WithinTag"] = 4] = "WithinTag";
      ScannerState2[ScannerState2["WithinEndTag"] = 5] = "WithinEndTag";
      ScannerState2[ScannerState2["WithinComment"] = 6] = "WithinComment";
      ScannerState2[ScannerState2["WithinScriptContent"] = 7] = "WithinScriptContent";
      ScannerState2[ScannerState2["WithinStyleContent"] = 8] = "WithinStyleContent";
      ScannerState2[ScannerState2["AfterAttributeName"] = 9] = "AfterAttributeName";
      ScannerState2[ScannerState2["BeforeAttributeValue"] = 10] = "BeforeAttributeValue";
    })(ScannerState || (ScannerState = {}));
    (function(ClientCapabilities2) {
      ClientCapabilities2.LATEST = {
        textDocument: {
          completion: {
            completionItem: {
              documentationFormat: [MarkupKind2.Markdown, MarkupKind2.PlainText]
            }
          },
          hover: {
            contentFormat: [MarkupKind2.Markdown, MarkupKind2.PlainText]
          }
        }
      };
    })(ClientCapabilities || (ClientCapabilities = {}));
    (function(FileType2) {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType || (FileType = {}));
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/parser/htmlScanner.js
function createScanner(input, initialOffset, initialState, emitPseudoCloseTags) {
  if (initialOffset === void 0) {
    initialOffset = 0;
  }
  if (initialState === void 0) {
    initialState = ScannerState.WithinContent;
  }
  if (emitPseudoCloseTags === void 0) {
    emitPseudoCloseTags = false;
  }
  var stream = new MultiLineStream(input, initialOffset);
  var state = initialState;
  var tokenOffset = 0;
  var tokenType = TokenType.Unknown;
  var tokenError;
  var hasSpaceAfterTag;
  var lastTag;
  var lastAttributeName;
  var lastTypeValue;
  function nextElementName() {
    return stream.advanceIfRegExp(/^[_:\w][_:\w-.\d]*/).toLowerCase();
  }
  function nextAttributeName() {
    return stream.advanceIfRegExp(/^[^\s"'></=\x00-\x0F\x7F\x80-\x9F]*/).toLowerCase();
  }
  function finishToken(offset, type, errorMessage) {
    tokenType = type;
    tokenOffset = offset;
    tokenError = errorMessage;
    return type;
  }
  function scan() {
    var offset = stream.pos();
    var oldState = state;
    var token = internalScan();
    if (token !== TokenType.EOS && offset === stream.pos() && !(emitPseudoCloseTags && (token === TokenType.StartTagClose || token === TokenType.EndTagClose))) {
      console.log("Scanner.scan has not advanced at offset " + offset + ", state before: " + oldState + " after: " + state);
      stream.advance(1);
      return finishToken(offset, TokenType.Unknown);
    }
    return token;
  }
  function internalScan() {
    var offset = stream.pos();
    if (stream.eos()) {
      return finishToken(offset, TokenType.EOS);
    }
    var errorMessage;
    switch (state) {
      case ScannerState.WithinComment:
        if (stream.advanceIfChars([_MIN, _MIN, _RAN])) {
          state = ScannerState.WithinContent;
          return finishToken(offset, TokenType.EndCommentTag);
        }
        stream.advanceUntilChars([_MIN, _MIN, _RAN]);
        return finishToken(offset, TokenType.Comment);
      case ScannerState.WithinDoctype:
        if (stream.advanceIfChar(_RAN)) {
          state = ScannerState.WithinContent;
          return finishToken(offset, TokenType.EndDoctypeTag);
        }
        stream.advanceUntilChar(_RAN);
        return finishToken(offset, TokenType.Doctype);
      case ScannerState.WithinContent:
        if (stream.advanceIfChar(_LAN)) {
          if (!stream.eos() && stream.peekChar() === _BNG) {
            if (stream.advanceIfChars([_BNG, _MIN, _MIN])) {
              state = ScannerState.WithinComment;
              return finishToken(offset, TokenType.StartCommentTag);
            }
            if (stream.advanceIfRegExp(/^!doctype/i)) {
              state = ScannerState.WithinDoctype;
              return finishToken(offset, TokenType.StartDoctypeTag);
            }
          }
          if (stream.advanceIfChar(_FSL)) {
            state = ScannerState.AfterOpeningEndTag;
            return finishToken(offset, TokenType.EndTagOpen);
          }
          state = ScannerState.AfterOpeningStartTag;
          return finishToken(offset, TokenType.StartTagOpen);
        }
        stream.advanceUntilChar(_LAN);
        return finishToken(offset, TokenType.Content);
      case ScannerState.AfterOpeningEndTag:
        var tagName = nextElementName();
        if (tagName.length > 0) {
          state = ScannerState.WithinEndTag;
          return finishToken(offset, TokenType.EndTag);
        }
        if (stream.skipWhitespace()) {
          return finishToken(offset, TokenType.Whitespace, localize("error.unexpectedWhitespace", "Tag name must directly follow the open bracket."));
        }
        state = ScannerState.WithinEndTag;
        stream.advanceUntilChar(_RAN);
        if (offset < stream.pos()) {
          return finishToken(offset, TokenType.Unknown, localize("error.endTagNameExpected", "End tag name expected."));
        }
        return internalScan();
      case ScannerState.WithinEndTag:
        if (stream.skipWhitespace()) {
          return finishToken(offset, TokenType.Whitespace);
        }
        if (stream.advanceIfChar(_RAN)) {
          state = ScannerState.WithinContent;
          return finishToken(offset, TokenType.EndTagClose);
        }
        if (emitPseudoCloseTags && stream.peekChar() === _LAN) {
          state = ScannerState.WithinContent;
          return finishToken(offset, TokenType.EndTagClose, localize("error.closingBracketMissing", "Closing bracket missing."));
        }
        errorMessage = localize("error.closingBracketExpected", "Closing bracket expected.");
        break;
      case ScannerState.AfterOpeningStartTag:
        lastTag = nextElementName();
        lastTypeValue = void 0;
        lastAttributeName = void 0;
        if (lastTag.length > 0) {
          hasSpaceAfterTag = false;
          state = ScannerState.WithinTag;
          return finishToken(offset, TokenType.StartTag);
        }
        if (stream.skipWhitespace()) {
          return finishToken(offset, TokenType.Whitespace, localize("error.unexpectedWhitespace", "Tag name must directly follow the open bracket."));
        }
        state = ScannerState.WithinTag;
        stream.advanceUntilChar(_RAN);
        if (offset < stream.pos()) {
          return finishToken(offset, TokenType.Unknown, localize("error.startTagNameExpected", "Start tag name expected."));
        }
        return internalScan();
      case ScannerState.WithinTag:
        if (stream.skipWhitespace()) {
          hasSpaceAfterTag = true;
          return finishToken(offset, TokenType.Whitespace);
        }
        if (hasSpaceAfterTag) {
          lastAttributeName = nextAttributeName();
          if (lastAttributeName.length > 0) {
            state = ScannerState.AfterAttributeName;
            hasSpaceAfterTag = false;
            return finishToken(offset, TokenType.AttributeName);
          }
        }
        if (stream.advanceIfChars([_FSL, _RAN])) {
          state = ScannerState.WithinContent;
          return finishToken(offset, TokenType.StartTagSelfClose);
        }
        if (stream.advanceIfChar(_RAN)) {
          if (lastTag === "script") {
            if (lastTypeValue && htmlScriptContents[lastTypeValue]) {
              state = ScannerState.WithinContent;
            } else {
              state = ScannerState.WithinScriptContent;
            }
          } else if (lastTag === "style") {
            state = ScannerState.WithinStyleContent;
          } else {
            state = ScannerState.WithinContent;
          }
          return finishToken(offset, TokenType.StartTagClose);
        }
        if (emitPseudoCloseTags && stream.peekChar() === _LAN) {
          state = ScannerState.WithinContent;
          return finishToken(offset, TokenType.StartTagClose, localize("error.closingBracketMissing", "Closing bracket missing."));
        }
        stream.advance(1);
        return finishToken(offset, TokenType.Unknown, localize("error.unexpectedCharacterInTag", "Unexpected character in tag."));
      case ScannerState.AfterAttributeName:
        if (stream.skipWhitespace()) {
          hasSpaceAfterTag = true;
          return finishToken(offset, TokenType.Whitespace);
        }
        if (stream.advanceIfChar(_EQS)) {
          state = ScannerState.BeforeAttributeValue;
          return finishToken(offset, TokenType.DelimiterAssign);
        }
        state = ScannerState.WithinTag;
        return internalScan();
      case ScannerState.BeforeAttributeValue:
        if (stream.skipWhitespace()) {
          return finishToken(offset, TokenType.Whitespace);
        }
        var attributeValue = stream.advanceIfRegExp(/^[^\s"'`=<>]+/);
        if (attributeValue.length > 0) {
          if (stream.peekChar() === _RAN && stream.peekChar(-1) === _FSL) {
            stream.goBack(1);
            attributeValue = attributeValue.substr(0, attributeValue.length - 1);
          }
          if (lastAttributeName === "type") {
            lastTypeValue = attributeValue;
          }
          state = ScannerState.WithinTag;
          hasSpaceAfterTag = false;
          return finishToken(offset, TokenType.AttributeValue);
        }
        var ch = stream.peekChar();
        if (ch === _SQO || ch === _DQO) {
          stream.advance(1);
          if (stream.advanceUntilChar(ch)) {
            stream.advance(1);
          }
          if (lastAttributeName === "type") {
            lastTypeValue = stream.getSource().substring(offset + 1, stream.pos() - 1);
          }
          state = ScannerState.WithinTag;
          hasSpaceAfterTag = false;
          return finishToken(offset, TokenType.AttributeValue);
        }
        state = ScannerState.WithinTag;
        hasSpaceAfterTag = false;
        return internalScan();
      case ScannerState.WithinScriptContent:
        var sciptState = 1;
        while (!stream.eos()) {
          var match = stream.advanceIfRegExp(/<!--|-->|<\/?script\s*\/?>?/i);
          if (match.length === 0) {
            stream.goToEnd();
            return finishToken(offset, TokenType.Script);
          } else if (match === "<!--") {
            if (sciptState === 1) {
              sciptState = 2;
            }
          } else if (match === "-->") {
            sciptState = 1;
          } else if (match[1] !== "/") {
            if (sciptState === 2) {
              sciptState = 3;
            }
          } else {
            if (sciptState === 3) {
              sciptState = 2;
            } else {
              stream.goBack(match.length);
              break;
            }
          }
        }
        state = ScannerState.WithinContent;
        if (offset < stream.pos()) {
          return finishToken(offset, TokenType.Script);
        }
        return internalScan();
      case ScannerState.WithinStyleContent:
        stream.advanceUntilRegExp(/<\/style/i);
        state = ScannerState.WithinContent;
        if (offset < stream.pos()) {
          return finishToken(offset, TokenType.Styles);
        }
        return internalScan();
    }
    stream.advance(1);
    state = ScannerState.WithinContent;
    return finishToken(offset, TokenType.Unknown, errorMessage);
  }
  return {
    scan,
    getTokenType: function() {
      return tokenType;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return stream.pos() - tokenOffset;
    },
    getTokenEnd: function() {
      return stream.pos();
    },
    getTokenText: function() {
      return stream.getSource().substring(tokenOffset, stream.pos());
    },
    getScannerState: function() {
      return state;
    },
    getTokenError: function() {
      return tokenError;
    }
  };
}
var nls, localize, MultiLineStream, _BNG, _MIN, _LAN, _RAN, _FSL, _EQS, _DQO, _SQO, _NWL, _CAR, _LFD, _WSP, _TAB, htmlScriptContents;
var init_htmlScanner = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/parser/htmlScanner.js"() {
    nls = __toESM(require_main4());
    init_htmlLanguageTypes();
    localize = nls.loadMessageBundle();
    MultiLineStream = function() {
      function MultiLineStream2(source, position) {
        this.source = source;
        this.len = source.length;
        this.position = position;
      }
      MultiLineStream2.prototype.eos = function() {
        return this.len <= this.position;
      };
      MultiLineStream2.prototype.getSource = function() {
        return this.source;
      };
      MultiLineStream2.prototype.pos = function() {
        return this.position;
      };
      MultiLineStream2.prototype.goBackTo = function(pos) {
        this.position = pos;
      };
      MultiLineStream2.prototype.goBack = function(n) {
        this.position -= n;
      };
      MultiLineStream2.prototype.advance = function(n) {
        this.position += n;
      };
      MultiLineStream2.prototype.goToEnd = function() {
        this.position = this.source.length;
      };
      MultiLineStream2.prototype.nextChar = function() {
        return this.source.charCodeAt(this.position++) || 0;
      };
      MultiLineStream2.prototype.peekChar = function(n) {
        if (n === void 0) {
          n = 0;
        }
        return this.source.charCodeAt(this.position + n) || 0;
      };
      MultiLineStream2.prototype.advanceIfChar = function(ch) {
        if (ch === this.source.charCodeAt(this.position)) {
          this.position++;
          return true;
        }
        return false;
      };
      MultiLineStream2.prototype.advanceIfChars = function(ch) {
        var i;
        if (this.position + ch.length > this.source.length) {
          return false;
        }
        for (i = 0; i < ch.length; i++) {
          if (this.source.charCodeAt(this.position + i) !== ch[i]) {
            return false;
          }
        }
        this.advance(i);
        return true;
      };
      MultiLineStream2.prototype.advanceIfRegExp = function(regex) {
        var str = this.source.substr(this.position);
        var match = str.match(regex);
        if (match) {
          this.position = this.position + match.index + match[0].length;
          return match[0];
        }
        return "";
      };
      MultiLineStream2.prototype.advanceUntilRegExp = function(regex) {
        var str = this.source.substr(this.position);
        var match = str.match(regex);
        if (match) {
          this.position = this.position + match.index;
          return match[0];
        } else {
          this.goToEnd();
        }
        return "";
      };
      MultiLineStream2.prototype.advanceUntilChar = function(ch) {
        while (this.position < this.source.length) {
          if (this.source.charCodeAt(this.position) === ch) {
            return true;
          }
          this.advance(1);
        }
        return false;
      };
      MultiLineStream2.prototype.advanceUntilChars = function(ch) {
        while (this.position + ch.length <= this.source.length) {
          var i = 0;
          for (; i < ch.length && this.source.charCodeAt(this.position + i) === ch[i]; i++) {
          }
          if (i === ch.length) {
            return true;
          }
          this.advance(1);
        }
        this.goToEnd();
        return false;
      };
      MultiLineStream2.prototype.skipWhitespace = function() {
        var n = this.advanceWhileChar(function(ch) {
          return ch === _WSP || ch === _TAB || ch === _NWL || ch === _LFD || ch === _CAR;
        });
        return n > 0;
      };
      MultiLineStream2.prototype.advanceWhileChar = function(condition) {
        var posNow = this.position;
        while (this.position < this.len && condition(this.source.charCodeAt(this.position))) {
          this.position++;
        }
        return this.position - posNow;
      };
      return MultiLineStream2;
    }();
    _BNG = "!".charCodeAt(0);
    _MIN = "-".charCodeAt(0);
    _LAN = "<".charCodeAt(0);
    _RAN = ">".charCodeAt(0);
    _FSL = "/".charCodeAt(0);
    _EQS = "=".charCodeAt(0);
    _DQO = '"'.charCodeAt(0);
    _SQO = "'".charCodeAt(0);
    _NWL = "\n".charCodeAt(0);
    _CAR = "\r".charCodeAt(0);
    _LFD = "\f".charCodeAt(0);
    _WSP = " ".charCodeAt(0);
    _TAB = "	".charCodeAt(0);
    htmlScriptContents = {
      "text/x-handlebars-template": true,
      "text/html": true
    };
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/utils/arrays.js
function findFirst(array, p) {
  var low = 0, high = array.length;
  if (high === 0) {
    return 0;
  }
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (p(array[mid])) {
      high = mid;
    } else {
      low = mid + 1;
    }
  }
  return low;
}
function binarySearch(array, key, comparator) {
  var low = 0, high = array.length - 1;
  while (low <= high) {
    var mid = (low + high) / 2 | 0;
    var comp = comparator(array[mid], key);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return -(low + 1);
}
var init_arrays = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/utils/arrays.js"() {
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/languageFacts/fact.js
function isVoidElement(e) {
  return !!e && binarySearch(VOID_ELEMENTS, e.toLowerCase(), function(s1, s2) {
    return s1.localeCompare(s2);
  }) >= 0;
}
var VOID_ELEMENTS;
var init_fact = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/languageFacts/fact.js"() {
    init_arrays();
    VOID_ELEMENTS = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"];
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/parser/htmlParser.js
function parse(text) {
  var scanner = createScanner(text, void 0, void 0, true);
  var htmlDocument = new Node(0, text.length, [], void 0);
  var curr = htmlDocument;
  var endTagStart = -1;
  var endTagName = void 0;
  var pendingAttribute = null;
  var token = scanner.scan();
  while (token !== TokenType.EOS) {
    switch (token) {
      case TokenType.StartTagOpen:
        var child = new Node(scanner.getTokenOffset(), text.length, [], curr);
        curr.children.push(child);
        curr = child;
        break;
      case TokenType.StartTag:
        curr.tag = scanner.getTokenText();
        break;
      case TokenType.StartTagClose:
        if (curr.parent) {
          curr.end = scanner.getTokenEnd();
          if (scanner.getTokenLength()) {
            curr.startTagEnd = scanner.getTokenEnd();
            if (curr.tag && isVoidElement(curr.tag)) {
              curr.closed = true;
              curr = curr.parent;
            }
          } else {
            curr = curr.parent;
          }
        }
        break;
      case TokenType.StartTagSelfClose:
        if (curr.parent) {
          curr.closed = true;
          curr.end = scanner.getTokenEnd();
          curr.startTagEnd = scanner.getTokenEnd();
          curr = curr.parent;
        }
        break;
      case TokenType.EndTagOpen:
        endTagStart = scanner.getTokenOffset();
        endTagName = void 0;
        break;
      case TokenType.EndTag:
        endTagName = scanner.getTokenText().toLowerCase();
        break;
      case TokenType.EndTagClose:
        var node = curr;
        while (!node.isSameTag(endTagName) && node.parent) {
          node = node.parent;
        }
        if (node.parent) {
          while (curr !== node) {
            curr.end = endTagStart;
            curr.closed = false;
            curr = curr.parent;
          }
          curr.closed = true;
          curr.endTagStart = endTagStart;
          curr.end = scanner.getTokenEnd();
          curr = curr.parent;
        }
        break;
      case TokenType.AttributeName: {
        pendingAttribute = scanner.getTokenText();
        var attributes = curr.attributes;
        if (!attributes) {
          curr.attributes = attributes = {};
        }
        attributes[pendingAttribute] = null;
        break;
      }
      case TokenType.AttributeValue: {
        var value = scanner.getTokenText();
        var attributes = curr.attributes;
        if (attributes && pendingAttribute) {
          attributes[pendingAttribute] = value;
          pendingAttribute = null;
        }
        break;
      }
    }
    token = scanner.scan();
  }
  while (curr.parent) {
    curr.end = text.length;
    curr.closed = false;
    curr = curr.parent;
  }
  return {
    roots: htmlDocument.children,
    findNodeBefore: htmlDocument.findNodeBefore.bind(htmlDocument),
    findNodeAt: htmlDocument.findNodeAt.bind(htmlDocument)
  };
}
var Node;
var init_htmlParser = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/parser/htmlParser.js"() {
    init_htmlScanner();
    init_arrays();
    init_htmlLanguageTypes();
    init_fact();
    Node = function() {
      function Node2(start, end, children, parent) {
        this.start = start;
        this.end = end;
        this.children = children;
        this.parent = parent;
        this.closed = false;
      }
      Object.defineProperty(Node2.prototype, "attributeNames", {
        get: function() {
          return this.attributes ? Object.keys(this.attributes) : [];
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.isSameTag = function(tagInLowerCase) {
        if (this.tag === void 0) {
          return tagInLowerCase === void 0;
        } else {
          return tagInLowerCase !== void 0 && this.tag.length === tagInLowerCase.length && this.tag.toLowerCase() === tagInLowerCase;
        }
      };
      Object.defineProperty(Node2.prototype, "firstChild", {
        get: function() {
          return this.children[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "lastChild", {
        get: function() {
          return this.children.length ? this.children[this.children.length - 1] : void 0;
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.findNodeBefore = function(offset) {
        var idx = findFirst(this.children, function(c) {
          return offset <= c.start;
        }) - 1;
        if (idx >= 0) {
          var child = this.children[idx];
          if (offset > child.start) {
            if (offset < child.end) {
              return child.findNodeBefore(offset);
            }
            var lastChild = child.lastChild;
            if (lastChild && lastChild.end === child.end) {
              return child.findNodeBefore(offset);
            }
            return child;
          }
        }
        return this;
      };
      Node2.prototype.findNodeAt = function(offset) {
        var idx = findFirst(this.children, function(c) {
          return offset <= c.start;
        }) - 1;
        if (idx >= 0) {
          var child = this.children[idx];
          if (offset > child.start && offset <= child.end) {
            return child.findNodeAt(offset);
          }
        }
        return this;
      };
      return Node2;
    }();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/parser/htmlEntities.js
var entities;
var init_htmlEntities = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/parser/htmlEntities.js"() {
    entities = {
      "Aacute;": "\xC1",
      "Aacute": "\xC1",
      "aacute;": "\xE1",
      "aacute": "\xE1",
      "Abreve;": "\u0102",
      "abreve;": "\u0103",
      "ac;": "\u223E",
      "acd;": "\u223F",
      "acE;": "\u223E\u0333",
      "Acirc;": "\xC2",
      "Acirc": "\xC2",
      "acirc;": "\xE2",
      "acirc": "\xE2",
      "acute;": "\xB4",
      "acute": "\xB4",
      "Acy;": "\u0410",
      "acy;": "\u0430",
      "AElig;": "\xC6",
      "AElig": "\xC6",
      "aelig;": "\xE6",
      "aelig": "\xE6",
      "af;": "\u2061",
      "Afr;": "\u{1D504}",
      "afr;": "\u{1D51E}",
      "Agrave;": "\xC0",
      "Agrave": "\xC0",
      "agrave;": "\xE0",
      "agrave": "\xE0",
      "alefsym;": "\u2135",
      "aleph;": "\u2135",
      "Alpha;": "\u0391",
      "alpha;": "\u03B1",
      "Amacr;": "\u0100",
      "amacr;": "\u0101",
      "amalg;": "\u2A3F",
      "AMP;": "&",
      "AMP": "&",
      "amp;": "&",
      "amp": "&",
      "And;": "\u2A53",
      "and;": "\u2227",
      "andand;": "\u2A55",
      "andd;": "\u2A5C",
      "andslope;": "\u2A58",
      "andv;": "\u2A5A",
      "ang;": "\u2220",
      "ange;": "\u29A4",
      "angle;": "\u2220",
      "angmsd;": "\u2221",
      "angmsdaa;": "\u29A8",
      "angmsdab;": "\u29A9",
      "angmsdac;": "\u29AA",
      "angmsdad;": "\u29AB",
      "angmsdae;": "\u29AC",
      "angmsdaf;": "\u29AD",
      "angmsdag;": "\u29AE",
      "angmsdah;": "\u29AF",
      "angrt;": "\u221F",
      "angrtvb;": "\u22BE",
      "angrtvbd;": "\u299D",
      "angsph;": "\u2222",
      "angst;": "\xC5",
      "angzarr;": "\u237C",
      "Aogon;": "\u0104",
      "aogon;": "\u0105",
      "Aopf;": "\u{1D538}",
      "aopf;": "\u{1D552}",
      "ap;": "\u2248",
      "apacir;": "\u2A6F",
      "apE;": "\u2A70",
      "ape;": "\u224A",
      "apid;": "\u224B",
      "apos;": "'",
      "ApplyFunction;": "\u2061",
      "approx;": "\u2248",
      "approxeq;": "\u224A",
      "Aring;": "\xC5",
      "Aring": "\xC5",
      "aring;": "\xE5",
      "aring": "\xE5",
      "Ascr;": "\u{1D49C}",
      "ascr;": "\u{1D4B6}",
      "Assign;": "\u2254",
      "ast;": "*",
      "asymp;": "\u2248",
      "asympeq;": "\u224D",
      "Atilde;": "\xC3",
      "Atilde": "\xC3",
      "atilde;": "\xE3",
      "atilde": "\xE3",
      "Auml;": "\xC4",
      "Auml": "\xC4",
      "auml;": "\xE4",
      "auml": "\xE4",
      "awconint;": "\u2233",
      "awint;": "\u2A11",
      "backcong;": "\u224C",
      "backepsilon;": "\u03F6",
      "backprime;": "\u2035",
      "backsim;": "\u223D",
      "backsimeq;": "\u22CD",
      "Backslash;": "\u2216",
      "Barv;": "\u2AE7",
      "barvee;": "\u22BD",
      "Barwed;": "\u2306",
      "barwed;": "\u2305",
      "barwedge;": "\u2305",
      "bbrk;": "\u23B5",
      "bbrktbrk;": "\u23B6",
      "bcong;": "\u224C",
      "Bcy;": "\u0411",
      "bcy;": "\u0431",
      "bdquo;": "\u201E",
      "becaus;": "\u2235",
      "Because;": "\u2235",
      "because;": "\u2235",
      "bemptyv;": "\u29B0",
      "bepsi;": "\u03F6",
      "bernou;": "\u212C",
      "Bernoullis;": "\u212C",
      "Beta;": "\u0392",
      "beta;": "\u03B2",
      "beth;": "\u2136",
      "between;": "\u226C",
      "Bfr;": "\u{1D505}",
      "bfr;": "\u{1D51F}",
      "bigcap;": "\u22C2",
      "bigcirc;": "\u25EF",
      "bigcup;": "\u22C3",
      "bigodot;": "\u2A00",
      "bigoplus;": "\u2A01",
      "bigotimes;": "\u2A02",
      "bigsqcup;": "\u2A06",
      "bigstar;": "\u2605",
      "bigtriangledown;": "\u25BD",
      "bigtriangleup;": "\u25B3",
      "biguplus;": "\u2A04",
      "bigvee;": "\u22C1",
      "bigwedge;": "\u22C0",
      "bkarow;": "\u290D",
      "blacklozenge;": "\u29EB",
      "blacksquare;": "\u25AA",
      "blacktriangle;": "\u25B4",
      "blacktriangledown;": "\u25BE",
      "blacktriangleleft;": "\u25C2",
      "blacktriangleright;": "\u25B8",
      "blank;": "\u2423",
      "blk12;": "\u2592",
      "blk14;": "\u2591",
      "blk34;": "\u2593",
      "block;": "\u2588",
      "bne;": "=\u20E5",
      "bnequiv;": "\u2261\u20E5",
      "bNot;": "\u2AED",
      "bnot;": "\u2310",
      "Bopf;": "\u{1D539}",
      "bopf;": "\u{1D553}",
      "bot;": "\u22A5",
      "bottom;": "\u22A5",
      "bowtie;": "\u22C8",
      "boxbox;": "\u29C9",
      "boxDL;": "\u2557",
      "boxDl;": "\u2556",
      "boxdL;": "\u2555",
      "boxdl;": "\u2510",
      "boxDR;": "\u2554",
      "boxDr;": "\u2553",
      "boxdR;": "\u2552",
      "boxdr;": "\u250C",
      "boxH;": "\u2550",
      "boxh;": "\u2500",
      "boxHD;": "\u2566",
      "boxHd;": "\u2564",
      "boxhD;": "\u2565",
      "boxhd;": "\u252C",
      "boxHU;": "\u2569",
      "boxHu;": "\u2567",
      "boxhU;": "\u2568",
      "boxhu;": "\u2534",
      "boxminus;": "\u229F",
      "boxplus;": "\u229E",
      "boxtimes;": "\u22A0",
      "boxUL;": "\u255D",
      "boxUl;": "\u255C",
      "boxuL;": "\u255B",
      "boxul;": "\u2518",
      "boxUR;": "\u255A",
      "boxUr;": "\u2559",
      "boxuR;": "\u2558",
      "boxur;": "\u2514",
      "boxV;": "\u2551",
      "boxv;": "\u2502",
      "boxVH;": "\u256C",
      "boxVh;": "\u256B",
      "boxvH;": "\u256A",
      "boxvh;": "\u253C",
      "boxVL;": "\u2563",
      "boxVl;": "\u2562",
      "boxvL;": "\u2561",
      "boxvl;": "\u2524",
      "boxVR;": "\u2560",
      "boxVr;": "\u255F",
      "boxvR;": "\u255E",
      "boxvr;": "\u251C",
      "bprime;": "\u2035",
      "Breve;": "\u02D8",
      "breve;": "\u02D8",
      "brvbar;": "\xA6",
      "brvbar": "\xA6",
      "Bscr;": "\u212C",
      "bscr;": "\u{1D4B7}",
      "bsemi;": "\u204F",
      "bsim;": "\u223D",
      "bsime;": "\u22CD",
      "bsol;": "\\",
      "bsolb;": "\u29C5",
      "bsolhsub;": "\u27C8",
      "bull;": "\u2022",
      "bullet;": "\u2022",
      "bump;": "\u224E",
      "bumpE;": "\u2AAE",
      "bumpe;": "\u224F",
      "Bumpeq;": "\u224E",
      "bumpeq;": "\u224F",
      "Cacute;": "\u0106",
      "cacute;": "\u0107",
      "Cap;": "\u22D2",
      "cap;": "\u2229",
      "capand;": "\u2A44",
      "capbrcup;": "\u2A49",
      "capcap;": "\u2A4B",
      "capcup;": "\u2A47",
      "capdot;": "\u2A40",
      "CapitalDifferentialD;": "\u2145",
      "caps;": "\u2229\uFE00",
      "caret;": "\u2041",
      "caron;": "\u02C7",
      "Cayleys;": "\u212D",
      "ccaps;": "\u2A4D",
      "Ccaron;": "\u010C",
      "ccaron;": "\u010D",
      "Ccedil;": "\xC7",
      "Ccedil": "\xC7",
      "ccedil;": "\xE7",
      "ccedil": "\xE7",
      "Ccirc;": "\u0108",
      "ccirc;": "\u0109",
      "Cconint;": "\u2230",
      "ccups;": "\u2A4C",
      "ccupssm;": "\u2A50",
      "Cdot;": "\u010A",
      "cdot;": "\u010B",
      "cedil;": "\xB8",
      "cedil": "\xB8",
      "Cedilla;": "\xB8",
      "cemptyv;": "\u29B2",
      "cent;": "\xA2",
      "cent": "\xA2",
      "CenterDot;": "\xB7",
      "centerdot;": "\xB7",
      "Cfr;": "\u212D",
      "cfr;": "\u{1D520}",
      "CHcy;": "\u0427",
      "chcy;": "\u0447",
      "check;": "\u2713",
      "checkmark;": "\u2713",
      "Chi;": "\u03A7",
      "chi;": "\u03C7",
      "cir;": "\u25CB",
      "circ;": "\u02C6",
      "circeq;": "\u2257",
      "circlearrowleft;": "\u21BA",
      "circlearrowright;": "\u21BB",
      "circledast;": "\u229B",
      "circledcirc;": "\u229A",
      "circleddash;": "\u229D",
      "CircleDot;": "\u2299",
      "circledR;": "\xAE",
      "circledS;": "\u24C8",
      "CircleMinus;": "\u2296",
      "CirclePlus;": "\u2295",
      "CircleTimes;": "\u2297",
      "cirE;": "\u29C3",
      "cire;": "\u2257",
      "cirfnint;": "\u2A10",
      "cirmid;": "\u2AEF",
      "cirscir;": "\u29C2",
      "ClockwiseContourIntegral;": "\u2232",
      "CloseCurlyDoubleQuote;": "\u201D",
      "CloseCurlyQuote;": "\u2019",
      "clubs;": "\u2663",
      "clubsuit;": "\u2663",
      "Colon;": "\u2237",
      "colon;": ":",
      "Colone;": "\u2A74",
      "colone;": "\u2254",
      "coloneq;": "\u2254",
      "comma;": ",",
      "commat;": "@",
      "comp;": "\u2201",
      "compfn;": "\u2218",
      "complement;": "\u2201",
      "complexes;": "\u2102",
      "cong;": "\u2245",
      "congdot;": "\u2A6D",
      "Congruent;": "\u2261",
      "Conint;": "\u222F",
      "conint;": "\u222E",
      "ContourIntegral;": "\u222E",
      "Copf;": "\u2102",
      "copf;": "\u{1D554}",
      "coprod;": "\u2210",
      "Coproduct;": "\u2210",
      "COPY;": "\xA9",
      "COPY": "\xA9",
      "copy;": "\xA9",
      "copy": "\xA9",
      "copysr;": "\u2117",
      "CounterClockwiseContourIntegral;": "\u2233",
      "crarr;": "\u21B5",
      "Cross;": "\u2A2F",
      "cross;": "\u2717",
      "Cscr;": "\u{1D49E}",
      "cscr;": "\u{1D4B8}",
      "csub;": "\u2ACF",
      "csube;": "\u2AD1",
      "csup;": "\u2AD0",
      "csupe;": "\u2AD2",
      "ctdot;": "\u22EF",
      "cudarrl;": "\u2938",
      "cudarrr;": "\u2935",
      "cuepr;": "\u22DE",
      "cuesc;": "\u22DF",
      "cularr;": "\u21B6",
      "cularrp;": "\u293D",
      "Cup;": "\u22D3",
      "cup;": "\u222A",
      "cupbrcap;": "\u2A48",
      "CupCap;": "\u224D",
      "cupcap;": "\u2A46",
      "cupcup;": "\u2A4A",
      "cupdot;": "\u228D",
      "cupor;": "\u2A45",
      "cups;": "\u222A\uFE00",
      "curarr;": "\u21B7",
      "curarrm;": "\u293C",
      "curlyeqprec;": "\u22DE",
      "curlyeqsucc;": "\u22DF",
      "curlyvee;": "\u22CE",
      "curlywedge;": "\u22CF",
      "curren;": "\xA4",
      "curren": "\xA4",
      "curvearrowleft;": "\u21B6",
      "curvearrowright;": "\u21B7",
      "cuvee;": "\u22CE",
      "cuwed;": "\u22CF",
      "cwconint;": "\u2232",
      "cwint;": "\u2231",
      "cylcty;": "\u232D",
      "Dagger;": "\u2021",
      "dagger;": "\u2020",
      "daleth;": "\u2138",
      "Darr;": "\u21A1",
      "dArr;": "\u21D3",
      "darr;": "\u2193",
      "dash;": "\u2010",
      "Dashv;": "\u2AE4",
      "dashv;": "\u22A3",
      "dbkarow;": "\u290F",
      "dblac;": "\u02DD",
      "Dcaron;": "\u010E",
      "dcaron;": "\u010F",
      "Dcy;": "\u0414",
      "dcy;": "\u0434",
      "DD;": "\u2145",
      "dd;": "\u2146",
      "ddagger;": "\u2021",
      "ddarr;": "\u21CA",
      "DDotrahd;": "\u2911",
      "ddotseq;": "\u2A77",
      "deg;": "\xB0",
      "deg": "\xB0",
      "Del;": "\u2207",
      "Delta;": "\u0394",
      "delta;": "\u03B4",
      "demptyv;": "\u29B1",
      "dfisht;": "\u297F",
      "Dfr;": "\u{1D507}",
      "dfr;": "\u{1D521}",
      "dHar;": "\u2965",
      "dharl;": "\u21C3",
      "dharr;": "\u21C2",
      "DiacriticalAcute;": "\xB4",
      "DiacriticalDot;": "\u02D9",
      "DiacriticalDoubleAcute;": "\u02DD",
      "DiacriticalGrave;": "`",
      "DiacriticalTilde;": "\u02DC",
      "diam;": "\u22C4",
      "Diamond;": "\u22C4",
      "diamond;": "\u22C4",
      "diamondsuit;": "\u2666",
      "diams;": "\u2666",
      "die;": "\xA8",
      "DifferentialD;": "\u2146",
      "digamma;": "\u03DD",
      "disin;": "\u22F2",
      "div;": "\xF7",
      "divide;": "\xF7",
      "divide": "\xF7",
      "divideontimes;": "\u22C7",
      "divonx;": "\u22C7",
      "DJcy;": "\u0402",
      "djcy;": "\u0452",
      "dlcorn;": "\u231E",
      "dlcrop;": "\u230D",
      "dollar;": "$",
      "Dopf;": "\u{1D53B}",
      "dopf;": "\u{1D555}",
      "Dot;": "\xA8",
      "dot;": "\u02D9",
      "DotDot;": "\u20DC",
      "doteq;": "\u2250",
      "doteqdot;": "\u2251",
      "DotEqual;": "\u2250",
      "dotminus;": "\u2238",
      "dotplus;": "\u2214",
      "dotsquare;": "\u22A1",
      "doublebarwedge;": "\u2306",
      "DoubleContourIntegral;": "\u222F",
      "DoubleDot;": "\xA8",
      "DoubleDownArrow;": "\u21D3",
      "DoubleLeftArrow;": "\u21D0",
      "DoubleLeftRightArrow;": "\u21D4",
      "DoubleLeftTee;": "\u2AE4",
      "DoubleLongLeftArrow;": "\u27F8",
      "DoubleLongLeftRightArrow;": "\u27FA",
      "DoubleLongRightArrow;": "\u27F9",
      "DoubleRightArrow;": "\u21D2",
      "DoubleRightTee;": "\u22A8",
      "DoubleUpArrow;": "\u21D1",
      "DoubleUpDownArrow;": "\u21D5",
      "DoubleVerticalBar;": "\u2225",
      "DownArrow;": "\u2193",
      "Downarrow;": "\u21D3",
      "downarrow;": "\u2193",
      "DownArrowBar;": "\u2913",
      "DownArrowUpArrow;": "\u21F5",
      "DownBreve;": "\u0311",
      "downdownarrows;": "\u21CA",
      "downharpoonleft;": "\u21C3",
      "downharpoonright;": "\u21C2",
      "DownLeftRightVector;": "\u2950",
      "DownLeftTeeVector;": "\u295E",
      "DownLeftVector;": "\u21BD",
      "DownLeftVectorBar;": "\u2956",
      "DownRightTeeVector;": "\u295F",
      "DownRightVector;": "\u21C1",
      "DownRightVectorBar;": "\u2957",
      "DownTee;": "\u22A4",
      "DownTeeArrow;": "\u21A7",
      "drbkarow;": "\u2910",
      "drcorn;": "\u231F",
      "drcrop;": "\u230C",
      "Dscr;": "\u{1D49F}",
      "dscr;": "\u{1D4B9}",
      "DScy;": "\u0405",
      "dscy;": "\u0455",
      "dsol;": "\u29F6",
      "Dstrok;": "\u0110",
      "dstrok;": "\u0111",
      "dtdot;": "\u22F1",
      "dtri;": "\u25BF",
      "dtrif;": "\u25BE",
      "duarr;": "\u21F5",
      "duhar;": "\u296F",
      "dwangle;": "\u29A6",
      "DZcy;": "\u040F",
      "dzcy;": "\u045F",
      "dzigrarr;": "\u27FF",
      "Eacute;": "\xC9",
      "Eacute": "\xC9",
      "eacute;": "\xE9",
      "eacute": "\xE9",
      "easter;": "\u2A6E",
      "Ecaron;": "\u011A",
      "ecaron;": "\u011B",
      "ecir;": "\u2256",
      "Ecirc;": "\xCA",
      "Ecirc": "\xCA",
      "ecirc;": "\xEA",
      "ecirc": "\xEA",
      "ecolon;": "\u2255",
      "Ecy;": "\u042D",
      "ecy;": "\u044D",
      "eDDot;": "\u2A77",
      "Edot;": "\u0116",
      "eDot;": "\u2251",
      "edot;": "\u0117",
      "ee;": "\u2147",
      "efDot;": "\u2252",
      "Efr;": "\u{1D508}",
      "efr;": "\u{1D522}",
      "eg;": "\u2A9A",
      "Egrave;": "\xC8",
      "Egrave": "\xC8",
      "egrave;": "\xE8",
      "egrave": "\xE8",
      "egs;": "\u2A96",
      "egsdot;": "\u2A98",
      "el;": "\u2A99",
      "Element;": "\u2208",
      "elinters;": "\u23E7",
      "ell;": "\u2113",
      "els;": "\u2A95",
      "elsdot;": "\u2A97",
      "Emacr;": "\u0112",
      "emacr;": "\u0113",
      "empty;": "\u2205",
      "emptyset;": "\u2205",
      "EmptySmallSquare;": "\u25FB",
      "emptyv;": "\u2205",
      "EmptyVerySmallSquare;": "\u25AB",
      "emsp;": "\u2003",
      "emsp13;": "\u2004",
      "emsp14;": "\u2005",
      "ENG;": "\u014A",
      "eng;": "\u014B",
      "ensp;": "\u2002",
      "Eogon;": "\u0118",
      "eogon;": "\u0119",
      "Eopf;": "\u{1D53C}",
      "eopf;": "\u{1D556}",
      "epar;": "\u22D5",
      "eparsl;": "\u29E3",
      "eplus;": "\u2A71",
      "epsi;": "\u03B5",
      "Epsilon;": "\u0395",
      "epsilon;": "\u03B5",
      "epsiv;": "\u03F5",
      "eqcirc;": "\u2256",
      "eqcolon;": "\u2255",
      "eqsim;": "\u2242",
      "eqslantgtr;": "\u2A96",
      "eqslantless;": "\u2A95",
      "Equal;": "\u2A75",
      "equals;": "=",
      "EqualTilde;": "\u2242",
      "equest;": "\u225F",
      "Equilibrium;": "\u21CC",
      "equiv;": "\u2261",
      "equivDD;": "\u2A78",
      "eqvparsl;": "\u29E5",
      "erarr;": "\u2971",
      "erDot;": "\u2253",
      "Escr;": "\u2130",
      "escr;": "\u212F",
      "esdot;": "\u2250",
      "Esim;": "\u2A73",
      "esim;": "\u2242",
      "Eta;": "\u0397",
      "eta;": "\u03B7",
      "ETH;": "\xD0",
      "ETH": "\xD0",
      "eth;": "\xF0",
      "eth": "\xF0",
      "Euml;": "\xCB",
      "Euml": "\xCB",
      "euml;": "\xEB",
      "euml": "\xEB",
      "euro;": "\u20AC",
      "excl;": "!",
      "exist;": "\u2203",
      "Exists;": "\u2203",
      "expectation;": "\u2130",
      "ExponentialE;": "\u2147",
      "exponentiale;": "\u2147",
      "fallingdotseq;": "\u2252",
      "Fcy;": "\u0424",
      "fcy;": "\u0444",
      "female;": "\u2640",
      "ffilig;": "\uFB03",
      "fflig;": "\uFB00",
      "ffllig;": "\uFB04",
      "Ffr;": "\u{1D509}",
      "ffr;": "\u{1D523}",
      "filig;": "\uFB01",
      "FilledSmallSquare;": "\u25FC",
      "FilledVerySmallSquare;": "\u25AA",
      "fjlig;": "fj",
      "flat;": "\u266D",
      "fllig;": "\uFB02",
      "fltns;": "\u25B1",
      "fnof;": "\u0192",
      "Fopf;": "\u{1D53D}",
      "fopf;": "\u{1D557}",
      "ForAll;": "\u2200",
      "forall;": "\u2200",
      "fork;": "\u22D4",
      "forkv;": "\u2AD9",
      "Fouriertrf;": "\u2131",
      "fpartint;": "\u2A0D",
      "frac12;": "\xBD",
      "frac12": "\xBD",
      "frac13;": "\u2153",
      "frac14;": "\xBC",
      "frac14": "\xBC",
      "frac15;": "\u2155",
      "frac16;": "\u2159",
      "frac18;": "\u215B",
      "frac23;": "\u2154",
      "frac25;": "\u2156",
      "frac34;": "\xBE",
      "frac34": "\xBE",
      "frac35;": "\u2157",
      "frac38;": "\u215C",
      "frac45;": "\u2158",
      "frac56;": "\u215A",
      "frac58;": "\u215D",
      "frac78;": "\u215E",
      "frasl;": "\u2044",
      "frown;": "\u2322",
      "Fscr;": "\u2131",
      "fscr;": "\u{1D4BB}",
      "gacute;": "\u01F5",
      "Gamma;": "\u0393",
      "gamma;": "\u03B3",
      "Gammad;": "\u03DC",
      "gammad;": "\u03DD",
      "gap;": "\u2A86",
      "Gbreve;": "\u011E",
      "gbreve;": "\u011F",
      "Gcedil;": "\u0122",
      "Gcirc;": "\u011C",
      "gcirc;": "\u011D",
      "Gcy;": "\u0413",
      "gcy;": "\u0433",
      "Gdot;": "\u0120",
      "gdot;": "\u0121",
      "gE;": "\u2267",
      "ge;": "\u2265",
      "gEl;": "\u2A8C",
      "gel;": "\u22DB",
      "geq;": "\u2265",
      "geqq;": "\u2267",
      "geqslant;": "\u2A7E",
      "ges;": "\u2A7E",
      "gescc;": "\u2AA9",
      "gesdot;": "\u2A80",
      "gesdoto;": "\u2A82",
      "gesdotol;": "\u2A84",
      "gesl;": "\u22DB\uFE00",
      "gesles;": "\u2A94",
      "Gfr;": "\u{1D50A}",
      "gfr;": "\u{1D524}",
      "Gg;": "\u22D9",
      "gg;": "\u226B",
      "ggg;": "\u22D9",
      "gimel;": "\u2137",
      "GJcy;": "\u0403",
      "gjcy;": "\u0453",
      "gl;": "\u2277",
      "gla;": "\u2AA5",
      "glE;": "\u2A92",
      "glj;": "\u2AA4",
      "gnap;": "\u2A8A",
      "gnapprox;": "\u2A8A",
      "gnE;": "\u2269",
      "gne;": "\u2A88",
      "gneq;": "\u2A88",
      "gneqq;": "\u2269",
      "gnsim;": "\u22E7",
      "Gopf;": "\u{1D53E}",
      "gopf;": "\u{1D558}",
      "grave;": "`",
      "GreaterEqual;": "\u2265",
      "GreaterEqualLess;": "\u22DB",
      "GreaterFullEqual;": "\u2267",
      "GreaterGreater;": "\u2AA2",
      "GreaterLess;": "\u2277",
      "GreaterSlantEqual;": "\u2A7E",
      "GreaterTilde;": "\u2273",
      "Gscr;": "\u{1D4A2}",
      "gscr;": "\u210A",
      "gsim;": "\u2273",
      "gsime;": "\u2A8E",
      "gsiml;": "\u2A90",
      "GT;": ">",
      "GT": ">",
      "Gt;": "\u226B",
      "gt;": ">",
      "gt": ">",
      "gtcc;": "\u2AA7",
      "gtcir;": "\u2A7A",
      "gtdot;": "\u22D7",
      "gtlPar;": "\u2995",
      "gtquest;": "\u2A7C",
      "gtrapprox;": "\u2A86",
      "gtrarr;": "\u2978",
      "gtrdot;": "\u22D7",
      "gtreqless;": "\u22DB",
      "gtreqqless;": "\u2A8C",
      "gtrless;": "\u2277",
      "gtrsim;": "\u2273",
      "gvertneqq;": "\u2269\uFE00",
      "gvnE;": "\u2269\uFE00",
      "Hacek;": "\u02C7",
      "hairsp;": "\u200A",
      "half;": "\xBD",
      "hamilt;": "\u210B",
      "HARDcy;": "\u042A",
      "hardcy;": "\u044A",
      "hArr;": "\u21D4",
      "harr;": "\u2194",
      "harrcir;": "\u2948",
      "harrw;": "\u21AD",
      "Hat;": "^",
      "hbar;": "\u210F",
      "Hcirc;": "\u0124",
      "hcirc;": "\u0125",
      "hearts;": "\u2665",
      "heartsuit;": "\u2665",
      "hellip;": "\u2026",
      "hercon;": "\u22B9",
      "Hfr;": "\u210C",
      "hfr;": "\u{1D525}",
      "HilbertSpace;": "\u210B",
      "hksearow;": "\u2925",
      "hkswarow;": "\u2926",
      "hoarr;": "\u21FF",
      "homtht;": "\u223B",
      "hookleftarrow;": "\u21A9",
      "hookrightarrow;": "\u21AA",
      "Hopf;": "\u210D",
      "hopf;": "\u{1D559}",
      "horbar;": "\u2015",
      "HorizontalLine;": "\u2500",
      "Hscr;": "\u210B",
      "hscr;": "\u{1D4BD}",
      "hslash;": "\u210F",
      "Hstrok;": "\u0126",
      "hstrok;": "\u0127",
      "HumpDownHump;": "\u224E",
      "HumpEqual;": "\u224F",
      "hybull;": "\u2043",
      "hyphen;": "\u2010",
      "Iacute;": "\xCD",
      "Iacute": "\xCD",
      "iacute;": "\xED",
      "iacute": "\xED",
      "ic;": "\u2063",
      "Icirc;": "\xCE",
      "Icirc": "\xCE",
      "icirc;": "\xEE",
      "icirc": "\xEE",
      "Icy;": "\u0418",
      "icy;": "\u0438",
      "Idot;": "\u0130",
      "IEcy;": "\u0415",
      "iecy;": "\u0435",
      "iexcl;": "\xA1",
      "iexcl": "\xA1",
      "iff;": "\u21D4",
      "Ifr;": "\u2111",
      "ifr;": "\u{1D526}",
      "Igrave;": "\xCC",
      "Igrave": "\xCC",
      "igrave;": "\xEC",
      "igrave": "\xEC",
      "ii;": "\u2148",
      "iiiint;": "\u2A0C",
      "iiint;": "\u222D",
      "iinfin;": "\u29DC",
      "iiota;": "\u2129",
      "IJlig;": "\u0132",
      "ijlig;": "\u0133",
      "Im;": "\u2111",
      "Imacr;": "\u012A",
      "imacr;": "\u012B",
      "image;": "\u2111",
      "ImaginaryI;": "\u2148",
      "imagline;": "\u2110",
      "imagpart;": "\u2111",
      "imath;": "\u0131",
      "imof;": "\u22B7",
      "imped;": "\u01B5",
      "Implies;": "\u21D2",
      "in;": "\u2208",
      "incare;": "\u2105",
      "infin;": "\u221E",
      "infintie;": "\u29DD",
      "inodot;": "\u0131",
      "Int;": "\u222C",
      "int;": "\u222B",
      "intcal;": "\u22BA",
      "integers;": "\u2124",
      "Integral;": "\u222B",
      "intercal;": "\u22BA",
      "Intersection;": "\u22C2",
      "intlarhk;": "\u2A17",
      "intprod;": "\u2A3C",
      "InvisibleComma;": "\u2063",
      "InvisibleTimes;": "\u2062",
      "IOcy;": "\u0401",
      "iocy;": "\u0451",
      "Iogon;": "\u012E",
      "iogon;": "\u012F",
      "Iopf;": "\u{1D540}",
      "iopf;": "\u{1D55A}",
      "Iota;": "\u0399",
      "iota;": "\u03B9",
      "iprod;": "\u2A3C",
      "iquest;": "\xBF",
      "iquest": "\xBF",
      "Iscr;": "\u2110",
      "iscr;": "\u{1D4BE}",
      "isin;": "\u2208",
      "isindot;": "\u22F5",
      "isinE;": "\u22F9",
      "isins;": "\u22F4",
      "isinsv;": "\u22F3",
      "isinv;": "\u2208",
      "it;": "\u2062",
      "Itilde;": "\u0128",
      "itilde;": "\u0129",
      "Iukcy;": "\u0406",
      "iukcy;": "\u0456",
      "Iuml;": "\xCF",
      "Iuml": "\xCF",
      "iuml;": "\xEF",
      "iuml": "\xEF",
      "Jcirc;": "\u0134",
      "jcirc;": "\u0135",
      "Jcy;": "\u0419",
      "jcy;": "\u0439",
      "Jfr;": "\u{1D50D}",
      "jfr;": "\u{1D527}",
      "jmath;": "\u0237",
      "Jopf;": "\u{1D541}",
      "jopf;": "\u{1D55B}",
      "Jscr;": "\u{1D4A5}",
      "jscr;": "\u{1D4BF}",
      "Jsercy;": "\u0408",
      "jsercy;": "\u0458",
      "Jukcy;": "\u0404",
      "jukcy;": "\u0454",
      "Kappa;": "\u039A",
      "kappa;": "\u03BA",
      "kappav;": "\u03F0",
      "Kcedil;": "\u0136",
      "kcedil;": "\u0137",
      "Kcy;": "\u041A",
      "kcy;": "\u043A",
      "Kfr;": "\u{1D50E}",
      "kfr;": "\u{1D528}",
      "kgreen;": "\u0138",
      "KHcy;": "\u0425",
      "khcy;": "\u0445",
      "KJcy;": "\u040C",
      "kjcy;": "\u045C",
      "Kopf;": "\u{1D542}",
      "kopf;": "\u{1D55C}",
      "Kscr;": "\u{1D4A6}",
      "kscr;": "\u{1D4C0}",
      "lAarr;": "\u21DA",
      "Lacute;": "\u0139",
      "lacute;": "\u013A",
      "laemptyv;": "\u29B4",
      "lagran;": "\u2112",
      "Lambda;": "\u039B",
      "lambda;": "\u03BB",
      "Lang;": "\u27EA",
      "lang;": "\u27E8",
      "langd;": "\u2991",
      "langle;": "\u27E8",
      "lap;": "\u2A85",
      "Laplacetrf;": "\u2112",
      "laquo;": "\xAB",
      "laquo": "\xAB",
      "Larr;": "\u219E",
      "lArr;": "\u21D0",
      "larr;": "\u2190",
      "larrb;": "\u21E4",
      "larrbfs;": "\u291F",
      "larrfs;": "\u291D",
      "larrhk;": "\u21A9",
      "larrlp;": "\u21AB",
      "larrpl;": "\u2939",
      "larrsim;": "\u2973",
      "larrtl;": "\u21A2",
      "lat;": "\u2AAB",
      "lAtail;": "\u291B",
      "latail;": "\u2919",
      "late;": "\u2AAD",
      "lates;": "\u2AAD\uFE00",
      "lBarr;": "\u290E",
      "lbarr;": "\u290C",
      "lbbrk;": "\u2772",
      "lbrace;": "{",
      "lbrack;": "[",
      "lbrke;": "\u298B",
      "lbrksld;": "\u298F",
      "lbrkslu;": "\u298D",
      "Lcaron;": "\u013D",
      "lcaron;": "\u013E",
      "Lcedil;": "\u013B",
      "lcedil;": "\u013C",
      "lceil;": "\u2308",
      "lcub;": "{",
      "Lcy;": "\u041B",
      "lcy;": "\u043B",
      "ldca;": "\u2936",
      "ldquo;": "\u201C",
      "ldquor;": "\u201E",
      "ldrdhar;": "\u2967",
      "ldrushar;": "\u294B",
      "ldsh;": "\u21B2",
      "lE;": "\u2266",
      "le;": "\u2264",
      "LeftAngleBracket;": "\u27E8",
      "LeftArrow;": "\u2190",
      "Leftarrow;": "\u21D0",
      "leftarrow;": "\u2190",
      "LeftArrowBar;": "\u21E4",
      "LeftArrowRightArrow;": "\u21C6",
      "leftarrowtail;": "\u21A2",
      "LeftCeiling;": "\u2308",
      "LeftDoubleBracket;": "\u27E6",
      "LeftDownTeeVector;": "\u2961",
      "LeftDownVector;": "\u21C3",
      "LeftDownVectorBar;": "\u2959",
      "LeftFloor;": "\u230A",
      "leftharpoondown;": "\u21BD",
      "leftharpoonup;": "\u21BC",
      "leftleftarrows;": "\u21C7",
      "LeftRightArrow;": "\u2194",
      "Leftrightarrow;": "\u21D4",
      "leftrightarrow;": "\u2194",
      "leftrightarrows;": "\u21C6",
      "leftrightharpoons;": "\u21CB",
      "leftrightsquigarrow;": "\u21AD",
      "LeftRightVector;": "\u294E",
      "LeftTee;": "\u22A3",
      "LeftTeeArrow;": "\u21A4",
      "LeftTeeVector;": "\u295A",
      "leftthreetimes;": "\u22CB",
      "LeftTriangle;": "\u22B2",
      "LeftTriangleBar;": "\u29CF",
      "LeftTriangleEqual;": "\u22B4",
      "LeftUpDownVector;": "\u2951",
      "LeftUpTeeVector;": "\u2960",
      "LeftUpVector;": "\u21BF",
      "LeftUpVectorBar;": "\u2958",
      "LeftVector;": "\u21BC",
      "LeftVectorBar;": "\u2952",
      "lEg;": "\u2A8B",
      "leg;": "\u22DA",
      "leq;": "\u2264",
      "leqq;": "\u2266",
      "leqslant;": "\u2A7D",
      "les;": "\u2A7D",
      "lescc;": "\u2AA8",
      "lesdot;": "\u2A7F",
      "lesdoto;": "\u2A81",
      "lesdotor;": "\u2A83",
      "lesg;": "\u22DA\uFE00",
      "lesges;": "\u2A93",
      "lessapprox;": "\u2A85",
      "lessdot;": "\u22D6",
      "lesseqgtr;": "\u22DA",
      "lesseqqgtr;": "\u2A8B",
      "LessEqualGreater;": "\u22DA",
      "LessFullEqual;": "\u2266",
      "LessGreater;": "\u2276",
      "lessgtr;": "\u2276",
      "LessLess;": "\u2AA1",
      "lesssim;": "\u2272",
      "LessSlantEqual;": "\u2A7D",
      "LessTilde;": "\u2272",
      "lfisht;": "\u297C",
      "lfloor;": "\u230A",
      "Lfr;": "\u{1D50F}",
      "lfr;": "\u{1D529}",
      "lg;": "\u2276",
      "lgE;": "\u2A91",
      "lHar;": "\u2962",
      "lhard;": "\u21BD",
      "lharu;": "\u21BC",
      "lharul;": "\u296A",
      "lhblk;": "\u2584",
      "LJcy;": "\u0409",
      "ljcy;": "\u0459",
      "Ll;": "\u22D8",
      "ll;": "\u226A",
      "llarr;": "\u21C7",
      "llcorner;": "\u231E",
      "Lleftarrow;": "\u21DA",
      "llhard;": "\u296B",
      "lltri;": "\u25FA",
      "Lmidot;": "\u013F",
      "lmidot;": "\u0140",
      "lmoust;": "\u23B0",
      "lmoustache;": "\u23B0",
      "lnap;": "\u2A89",
      "lnapprox;": "\u2A89",
      "lnE;": "\u2268",
      "lne;": "\u2A87",
      "lneq;": "\u2A87",
      "lneqq;": "\u2268",
      "lnsim;": "\u22E6",
      "loang;": "\u27EC",
      "loarr;": "\u21FD",
      "lobrk;": "\u27E6",
      "LongLeftArrow;": "\u27F5",
      "Longleftarrow;": "\u27F8",
      "longleftarrow;": "\u27F5",
      "LongLeftRightArrow;": "\u27F7",
      "Longleftrightarrow;": "\u27FA",
      "longleftrightarrow;": "\u27F7",
      "longmapsto;": "\u27FC",
      "LongRightArrow;": "\u27F6",
      "Longrightarrow;": "\u27F9",
      "longrightarrow;": "\u27F6",
      "looparrowleft;": "\u21AB",
      "looparrowright;": "\u21AC",
      "lopar;": "\u2985",
      "Lopf;": "\u{1D543}",
      "lopf;": "\u{1D55D}",
      "loplus;": "\u2A2D",
      "lotimes;": "\u2A34",
      "lowast;": "\u2217",
      "lowbar;": "_",
      "LowerLeftArrow;": "\u2199",
      "LowerRightArrow;": "\u2198",
      "loz;": "\u25CA",
      "lozenge;": "\u25CA",
      "lozf;": "\u29EB",
      "lpar;": "(",
      "lparlt;": "\u2993",
      "lrarr;": "\u21C6",
      "lrcorner;": "\u231F",
      "lrhar;": "\u21CB",
      "lrhard;": "\u296D",
      "lrm;": "\u200E",
      "lrtri;": "\u22BF",
      "lsaquo;": "\u2039",
      "Lscr;": "\u2112",
      "lscr;": "\u{1D4C1}",
      "Lsh;": "\u21B0",
      "lsh;": "\u21B0",
      "lsim;": "\u2272",
      "lsime;": "\u2A8D",
      "lsimg;": "\u2A8F",
      "lsqb;": "[",
      "lsquo;": "\u2018",
      "lsquor;": "\u201A",
      "Lstrok;": "\u0141",
      "lstrok;": "\u0142",
      "LT;": "<",
      "LT": "<",
      "Lt;": "\u226A",
      "lt;": "<",
      "lt": "<",
      "ltcc;": "\u2AA6",
      "ltcir;": "\u2A79",
      "ltdot;": "\u22D6",
      "lthree;": "\u22CB",
      "ltimes;": "\u22C9",
      "ltlarr;": "\u2976",
      "ltquest;": "\u2A7B",
      "ltri;": "\u25C3",
      "ltrie;": "\u22B4",
      "ltrif;": "\u25C2",
      "ltrPar;": "\u2996",
      "lurdshar;": "\u294A",
      "luruhar;": "\u2966",
      "lvertneqq;": "\u2268\uFE00",
      "lvnE;": "\u2268\uFE00",
      "macr;": "\xAF",
      "macr": "\xAF",
      "male;": "\u2642",
      "malt;": "\u2720",
      "maltese;": "\u2720",
      "Map;": "\u2905",
      "map;": "\u21A6",
      "mapsto;": "\u21A6",
      "mapstodown;": "\u21A7",
      "mapstoleft;": "\u21A4",
      "mapstoup;": "\u21A5",
      "marker;": "\u25AE",
      "mcomma;": "\u2A29",
      "Mcy;": "\u041C",
      "mcy;": "\u043C",
      "mdash;": "\u2014",
      "mDDot;": "\u223A",
      "measuredangle;": "\u2221",
      "MediumSpace;": "\u205F",
      "Mellintrf;": "\u2133",
      "Mfr;": "\u{1D510}",
      "mfr;": "\u{1D52A}",
      "mho;": "\u2127",
      "micro;": "\xB5",
      "micro": "\xB5",
      "mid;": "\u2223",
      "midast;": "*",
      "midcir;": "\u2AF0",
      "middot;": "\xB7",
      "middot": "\xB7",
      "minus;": "\u2212",
      "minusb;": "\u229F",
      "minusd;": "\u2238",
      "minusdu;": "\u2A2A",
      "MinusPlus;": "\u2213",
      "mlcp;": "\u2ADB",
      "mldr;": "\u2026",
      "mnplus;": "\u2213",
      "models;": "\u22A7",
      "Mopf;": "\u{1D544}",
      "mopf;": "\u{1D55E}",
      "mp;": "\u2213",
      "Mscr;": "\u2133",
      "mscr;": "\u{1D4C2}",
      "mstpos;": "\u223E",
      "Mu;": "\u039C",
      "mu;": "\u03BC",
      "multimap;": "\u22B8",
      "mumap;": "\u22B8",
      "nabla;": "\u2207",
      "Nacute;": "\u0143",
      "nacute;": "\u0144",
      "nang;": "\u2220\u20D2",
      "nap;": "\u2249",
      "napE;": "\u2A70\u0338",
      "napid;": "\u224B\u0338",
      "napos;": "\u0149",
      "napprox;": "\u2249",
      "natur;": "\u266E",
      "natural;": "\u266E",
      "naturals;": "\u2115",
      "nbsp;": "\xA0",
      "nbsp": "\xA0",
      "nbump;": "\u224E\u0338",
      "nbumpe;": "\u224F\u0338",
      "ncap;": "\u2A43",
      "Ncaron;": "\u0147",
      "ncaron;": "\u0148",
      "Ncedil;": "\u0145",
      "ncedil;": "\u0146",
      "ncong;": "\u2247",
      "ncongdot;": "\u2A6D\u0338",
      "ncup;": "\u2A42",
      "Ncy;": "\u041D",
      "ncy;": "\u043D",
      "ndash;": "\u2013",
      "ne;": "\u2260",
      "nearhk;": "\u2924",
      "neArr;": "\u21D7",
      "nearr;": "\u2197",
      "nearrow;": "\u2197",
      "nedot;": "\u2250\u0338",
      "NegativeMediumSpace;": "\u200B",
      "NegativeThickSpace;": "\u200B",
      "NegativeThinSpace;": "\u200B",
      "NegativeVeryThinSpace;": "\u200B",
      "nequiv;": "\u2262",
      "nesear;": "\u2928",
      "nesim;": "\u2242\u0338",
      "NestedGreaterGreater;": "\u226B",
      "NestedLessLess;": "\u226A",
      "NewLine;": "\n",
      "nexist;": "\u2204",
      "nexists;": "\u2204",
      "Nfr;": "\u{1D511}",
      "nfr;": "\u{1D52B}",
      "ngE;": "\u2267\u0338",
      "nge;": "\u2271",
      "ngeq;": "\u2271",
      "ngeqq;": "\u2267\u0338",
      "ngeqslant;": "\u2A7E\u0338",
      "nges;": "\u2A7E\u0338",
      "nGg;": "\u22D9\u0338",
      "ngsim;": "\u2275",
      "nGt;": "\u226B\u20D2",
      "ngt;": "\u226F",
      "ngtr;": "\u226F",
      "nGtv;": "\u226B\u0338",
      "nhArr;": "\u21CE",
      "nharr;": "\u21AE",
      "nhpar;": "\u2AF2",
      "ni;": "\u220B",
      "nis;": "\u22FC",
      "nisd;": "\u22FA",
      "niv;": "\u220B",
      "NJcy;": "\u040A",
      "njcy;": "\u045A",
      "nlArr;": "\u21CD",
      "nlarr;": "\u219A",
      "nldr;": "\u2025",
      "nlE;": "\u2266\u0338",
      "nle;": "\u2270",
      "nLeftarrow;": "\u21CD",
      "nleftarrow;": "\u219A",
      "nLeftrightarrow;": "\u21CE",
      "nleftrightarrow;": "\u21AE",
      "nleq;": "\u2270",
      "nleqq;": "\u2266\u0338",
      "nleqslant;": "\u2A7D\u0338",
      "nles;": "\u2A7D\u0338",
      "nless;": "\u226E",
      "nLl;": "\u22D8\u0338",
      "nlsim;": "\u2274",
      "nLt;": "\u226A\u20D2",
      "nlt;": "\u226E",
      "nltri;": "\u22EA",
      "nltrie;": "\u22EC",
      "nLtv;": "\u226A\u0338",
      "nmid;": "\u2224",
      "NoBreak;": "\u2060",
      "NonBreakingSpace;": "\xA0",
      "Nopf;": "\u2115",
      "nopf;": "\u{1D55F}",
      "Not;": "\u2AEC",
      "not;": "\xAC",
      "not": "\xAC",
      "NotCongruent;": "\u2262",
      "NotCupCap;": "\u226D",
      "NotDoubleVerticalBar;": "\u2226",
      "NotElement;": "\u2209",
      "NotEqual;": "\u2260",
      "NotEqualTilde;": "\u2242\u0338",
      "NotExists;": "\u2204",
      "NotGreater;": "\u226F",
      "NotGreaterEqual;": "\u2271",
      "NotGreaterFullEqual;": "\u2267\u0338",
      "NotGreaterGreater;": "\u226B\u0338",
      "NotGreaterLess;": "\u2279",
      "NotGreaterSlantEqual;": "\u2A7E\u0338",
      "NotGreaterTilde;": "\u2275",
      "NotHumpDownHump;": "\u224E\u0338",
      "NotHumpEqual;": "\u224F\u0338",
      "notin;": "\u2209",
      "notindot;": "\u22F5\u0338",
      "notinE;": "\u22F9\u0338",
      "notinva;": "\u2209",
      "notinvb;": "\u22F7",
      "notinvc;": "\u22F6",
      "NotLeftTriangle;": "\u22EA",
      "NotLeftTriangleBar;": "\u29CF\u0338",
      "NotLeftTriangleEqual;": "\u22EC",
      "NotLess;": "\u226E",
      "NotLessEqual;": "\u2270",
      "NotLessGreater;": "\u2278",
      "NotLessLess;": "\u226A\u0338",
      "NotLessSlantEqual;": "\u2A7D\u0338",
      "NotLessTilde;": "\u2274",
      "NotNestedGreaterGreater;": "\u2AA2\u0338",
      "NotNestedLessLess;": "\u2AA1\u0338",
      "notni;": "\u220C",
      "notniva;": "\u220C",
      "notnivb;": "\u22FE",
      "notnivc;": "\u22FD",
      "NotPrecedes;": "\u2280",
      "NotPrecedesEqual;": "\u2AAF\u0338",
      "NotPrecedesSlantEqual;": "\u22E0",
      "NotReverseElement;": "\u220C",
      "NotRightTriangle;": "\u22EB",
      "NotRightTriangleBar;": "\u29D0\u0338",
      "NotRightTriangleEqual;": "\u22ED",
      "NotSquareSubset;": "\u228F\u0338",
      "NotSquareSubsetEqual;": "\u22E2",
      "NotSquareSuperset;": "\u2290\u0338",
      "NotSquareSupersetEqual;": "\u22E3",
      "NotSubset;": "\u2282\u20D2",
      "NotSubsetEqual;": "\u2288",
      "NotSucceeds;": "\u2281",
      "NotSucceedsEqual;": "\u2AB0\u0338",
      "NotSucceedsSlantEqual;": "\u22E1",
      "NotSucceedsTilde;": "\u227F\u0338",
      "NotSuperset;": "\u2283\u20D2",
      "NotSupersetEqual;": "\u2289",
      "NotTilde;": "\u2241",
      "NotTildeEqual;": "\u2244",
      "NotTildeFullEqual;": "\u2247",
      "NotTildeTilde;": "\u2249",
      "NotVerticalBar;": "\u2224",
      "npar;": "\u2226",
      "nparallel;": "\u2226",
      "nparsl;": "\u2AFD\u20E5",
      "npart;": "\u2202\u0338",
      "npolint;": "\u2A14",
      "npr;": "\u2280",
      "nprcue;": "\u22E0",
      "npre;": "\u2AAF\u0338",
      "nprec;": "\u2280",
      "npreceq;": "\u2AAF\u0338",
      "nrArr;": "\u21CF",
      "nrarr;": "\u219B",
      "nrarrc;": "\u2933\u0338",
      "nrarrw;": "\u219D\u0338",
      "nRightarrow;": "\u21CF",
      "nrightarrow;": "\u219B",
      "nrtri;": "\u22EB",
      "nrtrie;": "\u22ED",
      "nsc;": "\u2281",
      "nsccue;": "\u22E1",
      "nsce;": "\u2AB0\u0338",
      "Nscr;": "\u{1D4A9}",
      "nscr;": "\u{1D4C3}",
      "nshortmid;": "\u2224",
      "nshortparallel;": "\u2226",
      "nsim;": "\u2241",
      "nsime;": "\u2244",
      "nsimeq;": "\u2244",
      "nsmid;": "\u2224",
      "nspar;": "\u2226",
      "nsqsube;": "\u22E2",
      "nsqsupe;": "\u22E3",
      "nsub;": "\u2284",
      "nsubE;": "\u2AC5\u0338",
      "nsube;": "\u2288",
      "nsubset;": "\u2282\u20D2",
      "nsubseteq;": "\u2288",
      "nsubseteqq;": "\u2AC5\u0338",
      "nsucc;": "\u2281",
      "nsucceq;": "\u2AB0\u0338",
      "nsup;": "\u2285",
      "nsupE;": "\u2AC6\u0338",
      "nsupe;": "\u2289",
      "nsupset;": "\u2283\u20D2",
      "nsupseteq;": "\u2289",
      "nsupseteqq;": "\u2AC6\u0338",
      "ntgl;": "\u2279",
      "Ntilde;": "\xD1",
      "Ntilde": "\xD1",
      "ntilde;": "\xF1",
      "ntilde": "\xF1",
      "ntlg;": "\u2278",
      "ntriangleleft;": "\u22EA",
      "ntrianglelefteq;": "\u22EC",
      "ntriangleright;": "\u22EB",
      "ntrianglerighteq;": "\u22ED",
      "Nu;": "\u039D",
      "nu;": "\u03BD",
      "num;": "#",
      "numero;": "\u2116",
      "numsp;": "\u2007",
      "nvap;": "\u224D\u20D2",
      "nVDash;": "\u22AF",
      "nVdash;": "\u22AE",
      "nvDash;": "\u22AD",
      "nvdash;": "\u22AC",
      "nvge;": "\u2265\u20D2",
      "nvgt;": ">\u20D2",
      "nvHarr;": "\u2904",
      "nvinfin;": "\u29DE",
      "nvlArr;": "\u2902",
      "nvle;": "\u2264\u20D2",
      "nvlt;": "<\u20D2",
      "nvltrie;": "\u22B4\u20D2",
      "nvrArr;": "\u2903",
      "nvrtrie;": "\u22B5\u20D2",
      "nvsim;": "\u223C\u20D2",
      "nwarhk;": "\u2923",
      "nwArr;": "\u21D6",
      "nwarr;": "\u2196",
      "nwarrow;": "\u2196",
      "nwnear;": "\u2927",
      "Oacute;": "\xD3",
      "Oacute": "\xD3",
      "oacute;": "\xF3",
      "oacute": "\xF3",
      "oast;": "\u229B",
      "ocir;": "\u229A",
      "Ocirc;": "\xD4",
      "Ocirc": "\xD4",
      "ocirc;": "\xF4",
      "ocirc": "\xF4",
      "Ocy;": "\u041E",
      "ocy;": "\u043E",
      "odash;": "\u229D",
      "Odblac;": "\u0150",
      "odblac;": "\u0151",
      "odiv;": "\u2A38",
      "odot;": "\u2299",
      "odsold;": "\u29BC",
      "OElig;": "\u0152",
      "oelig;": "\u0153",
      "ofcir;": "\u29BF",
      "Ofr;": "\u{1D512}",
      "ofr;": "\u{1D52C}",
      "ogon;": "\u02DB",
      "Ograve;": "\xD2",
      "Ograve": "\xD2",
      "ograve;": "\xF2",
      "ograve": "\xF2",
      "ogt;": "\u29C1",
      "ohbar;": "\u29B5",
      "ohm;": "\u03A9",
      "oint;": "\u222E",
      "olarr;": "\u21BA",
      "olcir;": "\u29BE",
      "olcross;": "\u29BB",
      "oline;": "\u203E",
      "olt;": "\u29C0",
      "Omacr;": "\u014C",
      "omacr;": "\u014D",
      "Omega;": "\u03A9",
      "omega;": "\u03C9",
      "Omicron;": "\u039F",
      "omicron;": "\u03BF",
      "omid;": "\u29B6",
      "ominus;": "\u2296",
      "Oopf;": "\u{1D546}",
      "oopf;": "\u{1D560}",
      "opar;": "\u29B7",
      "OpenCurlyDoubleQuote;": "\u201C",
      "OpenCurlyQuote;": "\u2018",
      "operp;": "\u29B9",
      "oplus;": "\u2295",
      "Or;": "\u2A54",
      "or;": "\u2228",
      "orarr;": "\u21BB",
      "ord;": "\u2A5D",
      "order;": "\u2134",
      "orderof;": "\u2134",
      "ordf;": "\xAA",
      "ordf": "\xAA",
      "ordm;": "\xBA",
      "ordm": "\xBA",
      "origof;": "\u22B6",
      "oror;": "\u2A56",
      "orslope;": "\u2A57",
      "orv;": "\u2A5B",
      "oS;": "\u24C8",
      "Oscr;": "\u{1D4AA}",
      "oscr;": "\u2134",
      "Oslash;": "\xD8",
      "Oslash": "\xD8",
      "oslash;": "\xF8",
      "oslash": "\xF8",
      "osol;": "\u2298",
      "Otilde;": "\xD5",
      "Otilde": "\xD5",
      "otilde;": "\xF5",
      "otilde": "\xF5",
      "Otimes;": "\u2A37",
      "otimes;": "\u2297",
      "otimesas;": "\u2A36",
      "Ouml;": "\xD6",
      "Ouml": "\xD6",
      "ouml;": "\xF6",
      "ouml": "\xF6",
      "ovbar;": "\u233D",
      "OverBar;": "\u203E",
      "OverBrace;": "\u23DE",
      "OverBracket;": "\u23B4",
      "OverParenthesis;": "\u23DC",
      "par;": "\u2225",
      "para;": "\xB6",
      "para": "\xB6",
      "parallel;": "\u2225",
      "parsim;": "\u2AF3",
      "parsl;": "\u2AFD",
      "part;": "\u2202",
      "PartialD;": "\u2202",
      "Pcy;": "\u041F",
      "pcy;": "\u043F",
      "percnt;": "%",
      "period;": ".",
      "permil;": "\u2030",
      "perp;": "\u22A5",
      "pertenk;": "\u2031",
      "Pfr;": "\u{1D513}",
      "pfr;": "\u{1D52D}",
      "Phi;": "\u03A6",
      "phi;": "\u03C6",
      "phiv;": "\u03D5",
      "phmmat;": "\u2133",
      "phone;": "\u260E",
      "Pi;": "\u03A0",
      "pi;": "\u03C0",
      "pitchfork;": "\u22D4",
      "piv;": "\u03D6",
      "planck;": "\u210F",
      "planckh;": "\u210E",
      "plankv;": "\u210F",
      "plus;": "+",
      "plusacir;": "\u2A23",
      "plusb;": "\u229E",
      "pluscir;": "\u2A22",
      "plusdo;": "\u2214",
      "plusdu;": "\u2A25",
      "pluse;": "\u2A72",
      "PlusMinus;": "\xB1",
      "plusmn;": "\xB1",
      "plusmn": "\xB1",
      "plussim;": "\u2A26",
      "plustwo;": "\u2A27",
      "pm;": "\xB1",
      "Poincareplane;": "\u210C",
      "pointint;": "\u2A15",
      "Popf;": "\u2119",
      "popf;": "\u{1D561}",
      "pound;": "\xA3",
      "pound": "\xA3",
      "Pr;": "\u2ABB",
      "pr;": "\u227A",
      "prap;": "\u2AB7",
      "prcue;": "\u227C",
      "prE;": "\u2AB3",
      "pre;": "\u2AAF",
      "prec;": "\u227A",
      "precapprox;": "\u2AB7",
      "preccurlyeq;": "\u227C",
      "Precedes;": "\u227A",
      "PrecedesEqual;": "\u2AAF",
      "PrecedesSlantEqual;": "\u227C",
      "PrecedesTilde;": "\u227E",
      "preceq;": "\u2AAF",
      "precnapprox;": "\u2AB9",
      "precneqq;": "\u2AB5",
      "precnsim;": "\u22E8",
      "precsim;": "\u227E",
      "Prime;": "\u2033",
      "prime;": "\u2032",
      "primes;": "\u2119",
      "prnap;": "\u2AB9",
      "prnE;": "\u2AB5",
      "prnsim;": "\u22E8",
      "prod;": "\u220F",
      "Product;": "\u220F",
      "profalar;": "\u232E",
      "profline;": "\u2312",
      "profsurf;": "\u2313",
      "prop;": "\u221D",
      "Proportion;": "\u2237",
      "Proportional;": "\u221D",
      "propto;": "\u221D",
      "prsim;": "\u227E",
      "prurel;": "\u22B0",
      "Pscr;": "\u{1D4AB}",
      "pscr;": "\u{1D4C5}",
      "Psi;": "\u03A8",
      "psi;": "\u03C8",
      "puncsp;": "\u2008",
      "Qfr;": "\u{1D514}",
      "qfr;": "\u{1D52E}",
      "qint;": "\u2A0C",
      "Qopf;": "\u211A",
      "qopf;": "\u{1D562}",
      "qprime;": "\u2057",
      "Qscr;": "\u{1D4AC}",
      "qscr;": "\u{1D4C6}",
      "quaternions;": "\u210D",
      "quatint;": "\u2A16",
      "quest;": "?",
      "questeq;": "\u225F",
      "QUOT;": '"',
      "QUOT": '"',
      "quot;": '"',
      "quot": '"',
      "rAarr;": "\u21DB",
      "race;": "\u223D\u0331",
      "Racute;": "\u0154",
      "racute;": "\u0155",
      "radic;": "\u221A",
      "raemptyv;": "\u29B3",
      "Rang;": "\u27EB",
      "rang;": "\u27E9",
      "rangd;": "\u2992",
      "range;": "\u29A5",
      "rangle;": "\u27E9",
      "raquo;": "\xBB",
      "raquo": "\xBB",
      "Rarr;": "\u21A0",
      "rArr;": "\u21D2",
      "rarr;": "\u2192",
      "rarrap;": "\u2975",
      "rarrb;": "\u21E5",
      "rarrbfs;": "\u2920",
      "rarrc;": "\u2933",
      "rarrfs;": "\u291E",
      "rarrhk;": "\u21AA",
      "rarrlp;": "\u21AC",
      "rarrpl;": "\u2945",
      "rarrsim;": "\u2974",
      "Rarrtl;": "\u2916",
      "rarrtl;": "\u21A3",
      "rarrw;": "\u219D",
      "rAtail;": "\u291C",
      "ratail;": "\u291A",
      "ratio;": "\u2236",
      "rationals;": "\u211A",
      "RBarr;": "\u2910",
      "rBarr;": "\u290F",
      "rbarr;": "\u290D",
      "rbbrk;": "\u2773",
      "rbrace;": "}",
      "rbrack;": "]",
      "rbrke;": "\u298C",
      "rbrksld;": "\u298E",
      "rbrkslu;": "\u2990",
      "Rcaron;": "\u0158",
      "rcaron;": "\u0159",
      "Rcedil;": "\u0156",
      "rcedil;": "\u0157",
      "rceil;": "\u2309",
      "rcub;": "}",
      "Rcy;": "\u0420",
      "rcy;": "\u0440",
      "rdca;": "\u2937",
      "rdldhar;": "\u2969",
      "rdquo;": "\u201D",
      "rdquor;": "\u201D",
      "rdsh;": "\u21B3",
      "Re;": "\u211C",
      "real;": "\u211C",
      "realine;": "\u211B",
      "realpart;": "\u211C",
      "reals;": "\u211D",
      "rect;": "\u25AD",
      "REG;": "\xAE",
      "REG": "\xAE",
      "reg;": "\xAE",
      "reg": "\xAE",
      "ReverseElement;": "\u220B",
      "ReverseEquilibrium;": "\u21CB",
      "ReverseUpEquilibrium;": "\u296F",
      "rfisht;": "\u297D",
      "rfloor;": "\u230B",
      "Rfr;": "\u211C",
      "rfr;": "\u{1D52F}",
      "rHar;": "\u2964",
      "rhard;": "\u21C1",
      "rharu;": "\u21C0",
      "rharul;": "\u296C",
      "Rho;": "\u03A1",
      "rho;": "\u03C1",
      "rhov;": "\u03F1",
      "RightAngleBracket;": "\u27E9",
      "RightArrow;": "\u2192",
      "Rightarrow;": "\u21D2",
      "rightarrow;": "\u2192",
      "RightArrowBar;": "\u21E5",
      "RightArrowLeftArrow;": "\u21C4",
      "rightarrowtail;": "\u21A3",
      "RightCeiling;": "\u2309",
      "RightDoubleBracket;": "\u27E7",
      "RightDownTeeVector;": "\u295D",
      "RightDownVector;": "\u21C2",
      "RightDownVectorBar;": "\u2955",
      "RightFloor;": "\u230B",
      "rightharpoondown;": "\u21C1",
      "rightharpoonup;": "\u21C0",
      "rightleftarrows;": "\u21C4",
      "rightleftharpoons;": "\u21CC",
      "rightrightarrows;": "\u21C9",
      "rightsquigarrow;": "\u219D",
      "RightTee;": "\u22A2",
      "RightTeeArrow;": "\u21A6",
      "RightTeeVector;": "\u295B",
      "rightthreetimes;": "\u22CC",
      "RightTriangle;": "\u22B3",
      "RightTriangleBar;": "\u29D0",
      "RightTriangleEqual;": "\u22B5",
      "RightUpDownVector;": "\u294F",
      "RightUpTeeVector;": "\u295C",
      "RightUpVector;": "\u21BE",
      "RightUpVectorBar;": "\u2954",
      "RightVector;": "\u21C0",
      "RightVectorBar;": "\u2953",
      "ring;": "\u02DA",
      "risingdotseq;": "\u2253",
      "rlarr;": "\u21C4",
      "rlhar;": "\u21CC",
      "rlm;": "\u200F",
      "rmoust;": "\u23B1",
      "rmoustache;": "\u23B1",
      "rnmid;": "\u2AEE",
      "roang;": "\u27ED",
      "roarr;": "\u21FE",
      "robrk;": "\u27E7",
      "ropar;": "\u2986",
      "Ropf;": "\u211D",
      "ropf;": "\u{1D563}",
      "roplus;": "\u2A2E",
      "rotimes;": "\u2A35",
      "RoundImplies;": "\u2970",
      "rpar;": ")",
      "rpargt;": "\u2994",
      "rppolint;": "\u2A12",
      "rrarr;": "\u21C9",
      "Rrightarrow;": "\u21DB",
      "rsaquo;": "\u203A",
      "Rscr;": "\u211B",
      "rscr;": "\u{1D4C7}",
      "Rsh;": "\u21B1",
      "rsh;": "\u21B1",
      "rsqb;": "]",
      "rsquo;": "\u2019",
      "rsquor;": "\u2019",
      "rthree;": "\u22CC",
      "rtimes;": "\u22CA",
      "rtri;": "\u25B9",
      "rtrie;": "\u22B5",
      "rtrif;": "\u25B8",
      "rtriltri;": "\u29CE",
      "RuleDelayed;": "\u29F4",
      "ruluhar;": "\u2968",
      "rx;": "\u211E",
      "Sacute;": "\u015A",
      "sacute;": "\u015B",
      "sbquo;": "\u201A",
      "Sc;": "\u2ABC",
      "sc;": "\u227B",
      "scap;": "\u2AB8",
      "Scaron;": "\u0160",
      "scaron;": "\u0161",
      "sccue;": "\u227D",
      "scE;": "\u2AB4",
      "sce;": "\u2AB0",
      "Scedil;": "\u015E",
      "scedil;": "\u015F",
      "Scirc;": "\u015C",
      "scirc;": "\u015D",
      "scnap;": "\u2ABA",
      "scnE;": "\u2AB6",
      "scnsim;": "\u22E9",
      "scpolint;": "\u2A13",
      "scsim;": "\u227F",
      "Scy;": "\u0421",
      "scy;": "\u0441",
      "sdot;": "\u22C5",
      "sdotb;": "\u22A1",
      "sdote;": "\u2A66",
      "searhk;": "\u2925",
      "seArr;": "\u21D8",
      "searr;": "\u2198",
      "searrow;": "\u2198",
      "sect;": "\xA7",
      "sect": "\xA7",
      "semi;": ";",
      "seswar;": "\u2929",
      "setminus;": "\u2216",
      "setmn;": "\u2216",
      "sext;": "\u2736",
      "Sfr;": "\u{1D516}",
      "sfr;": "\u{1D530}",
      "sfrown;": "\u2322",
      "sharp;": "\u266F",
      "SHCHcy;": "\u0429",
      "shchcy;": "\u0449",
      "SHcy;": "\u0428",
      "shcy;": "\u0448",
      "ShortDownArrow;": "\u2193",
      "ShortLeftArrow;": "\u2190",
      "shortmid;": "\u2223",
      "shortparallel;": "\u2225",
      "ShortRightArrow;": "\u2192",
      "ShortUpArrow;": "\u2191",
      "shy;": "\xAD",
      "shy": "\xAD",
      "Sigma;": "\u03A3",
      "sigma;": "\u03C3",
      "sigmaf;": "\u03C2",
      "sigmav;": "\u03C2",
      "sim;": "\u223C",
      "simdot;": "\u2A6A",
      "sime;": "\u2243",
      "simeq;": "\u2243",
      "simg;": "\u2A9E",
      "simgE;": "\u2AA0",
      "siml;": "\u2A9D",
      "simlE;": "\u2A9F",
      "simne;": "\u2246",
      "simplus;": "\u2A24",
      "simrarr;": "\u2972",
      "slarr;": "\u2190",
      "SmallCircle;": "\u2218",
      "smallsetminus;": "\u2216",
      "smashp;": "\u2A33",
      "smeparsl;": "\u29E4",
      "smid;": "\u2223",
      "smile;": "\u2323",
      "smt;": "\u2AAA",
      "smte;": "\u2AAC",
      "smtes;": "\u2AAC\uFE00",
      "SOFTcy;": "\u042C",
      "softcy;": "\u044C",
      "sol;": "/",
      "solb;": "\u29C4",
      "solbar;": "\u233F",
      "Sopf;": "\u{1D54A}",
      "sopf;": "\u{1D564}",
      "spades;": "\u2660",
      "spadesuit;": "\u2660",
      "spar;": "\u2225",
      "sqcap;": "\u2293",
      "sqcaps;": "\u2293\uFE00",
      "sqcup;": "\u2294",
      "sqcups;": "\u2294\uFE00",
      "Sqrt;": "\u221A",
      "sqsub;": "\u228F",
      "sqsube;": "\u2291",
      "sqsubset;": "\u228F",
      "sqsubseteq;": "\u2291",
      "sqsup;": "\u2290",
      "sqsupe;": "\u2292",
      "sqsupset;": "\u2290",
      "sqsupseteq;": "\u2292",
      "squ;": "\u25A1",
      "Square;": "\u25A1",
      "square;": "\u25A1",
      "SquareIntersection;": "\u2293",
      "SquareSubset;": "\u228F",
      "SquareSubsetEqual;": "\u2291",
      "SquareSuperset;": "\u2290",
      "SquareSupersetEqual;": "\u2292",
      "SquareUnion;": "\u2294",
      "squarf;": "\u25AA",
      "squf;": "\u25AA",
      "srarr;": "\u2192",
      "Sscr;": "\u{1D4AE}",
      "sscr;": "\u{1D4C8}",
      "ssetmn;": "\u2216",
      "ssmile;": "\u2323",
      "sstarf;": "\u22C6",
      "Star;": "\u22C6",
      "star;": "\u2606",
      "starf;": "\u2605",
      "straightepsilon;": "\u03F5",
      "straightphi;": "\u03D5",
      "strns;": "\xAF",
      "Sub;": "\u22D0",
      "sub;": "\u2282",
      "subdot;": "\u2ABD",
      "subE;": "\u2AC5",
      "sube;": "\u2286",
      "subedot;": "\u2AC3",
      "submult;": "\u2AC1",
      "subnE;": "\u2ACB",
      "subne;": "\u228A",
      "subplus;": "\u2ABF",
      "subrarr;": "\u2979",
      "Subset;": "\u22D0",
      "subset;": "\u2282",
      "subseteq;": "\u2286",
      "subseteqq;": "\u2AC5",
      "SubsetEqual;": "\u2286",
      "subsetneq;": "\u228A",
      "subsetneqq;": "\u2ACB",
      "subsim;": "\u2AC7",
      "subsub;": "\u2AD5",
      "subsup;": "\u2AD3",
      "succ;": "\u227B",
      "succapprox;": "\u2AB8",
      "succcurlyeq;": "\u227D",
      "Succeeds;": "\u227B",
      "SucceedsEqual;": "\u2AB0",
      "SucceedsSlantEqual;": "\u227D",
      "SucceedsTilde;": "\u227F",
      "succeq;": "\u2AB0",
      "succnapprox;": "\u2ABA",
      "succneqq;": "\u2AB6",
      "succnsim;": "\u22E9",
      "succsim;": "\u227F",
      "SuchThat;": "\u220B",
      "Sum;": "\u2211",
      "sum;": "\u2211",
      "sung;": "\u266A",
      "Sup;": "\u22D1",
      "sup;": "\u2283",
      "sup1;": "\xB9",
      "sup1": "\xB9",
      "sup2;": "\xB2",
      "sup2": "\xB2",
      "sup3;": "\xB3",
      "sup3": "\xB3",
      "supdot;": "\u2ABE",
      "supdsub;": "\u2AD8",
      "supE;": "\u2AC6",
      "supe;": "\u2287",
      "supedot;": "\u2AC4",
      "Superset;": "\u2283",
      "SupersetEqual;": "\u2287",
      "suphsol;": "\u27C9",
      "suphsub;": "\u2AD7",
      "suplarr;": "\u297B",
      "supmult;": "\u2AC2",
      "supnE;": "\u2ACC",
      "supne;": "\u228B",
      "supplus;": "\u2AC0",
      "Supset;": "\u22D1",
      "supset;": "\u2283",
      "supseteq;": "\u2287",
      "supseteqq;": "\u2AC6",
      "supsetneq;": "\u228B",
      "supsetneqq;": "\u2ACC",
      "supsim;": "\u2AC8",
      "supsub;": "\u2AD4",
      "supsup;": "\u2AD6",
      "swarhk;": "\u2926",
      "swArr;": "\u21D9",
      "swarr;": "\u2199",
      "swarrow;": "\u2199",
      "swnwar;": "\u292A",
      "szlig;": "\xDF",
      "szlig": "\xDF",
      "Tab;": "	",
      "target;": "\u2316",
      "Tau;": "\u03A4",
      "tau;": "\u03C4",
      "tbrk;": "\u23B4",
      "Tcaron;": "\u0164",
      "tcaron;": "\u0165",
      "Tcedil;": "\u0162",
      "tcedil;": "\u0163",
      "Tcy;": "\u0422",
      "tcy;": "\u0442",
      "tdot;": "\u20DB",
      "telrec;": "\u2315",
      "Tfr;": "\u{1D517}",
      "tfr;": "\u{1D531}",
      "there4;": "\u2234",
      "Therefore;": "\u2234",
      "therefore;": "\u2234",
      "Theta;": "\u0398",
      "theta;": "\u03B8",
      "thetasym;": "\u03D1",
      "thetav;": "\u03D1",
      "thickapprox;": "\u2248",
      "thicksim;": "\u223C",
      "ThickSpace;": "\u205F\u200A",
      "thinsp;": "\u2009",
      "ThinSpace;": "\u2009",
      "thkap;": "\u2248",
      "thksim;": "\u223C",
      "THORN;": "\xDE",
      "THORN": "\xDE",
      "thorn;": "\xFE",
      "thorn": "\xFE",
      "Tilde;": "\u223C",
      "tilde;": "\u02DC",
      "TildeEqual;": "\u2243",
      "TildeFullEqual;": "\u2245",
      "TildeTilde;": "\u2248",
      "times;": "\xD7",
      "times": "\xD7",
      "timesb;": "\u22A0",
      "timesbar;": "\u2A31",
      "timesd;": "\u2A30",
      "tint;": "\u222D",
      "toea;": "\u2928",
      "top;": "\u22A4",
      "topbot;": "\u2336",
      "topcir;": "\u2AF1",
      "Topf;": "\u{1D54B}",
      "topf;": "\u{1D565}",
      "topfork;": "\u2ADA",
      "tosa;": "\u2929",
      "tprime;": "\u2034",
      "TRADE;": "\u2122",
      "trade;": "\u2122",
      "triangle;": "\u25B5",
      "triangledown;": "\u25BF",
      "triangleleft;": "\u25C3",
      "trianglelefteq;": "\u22B4",
      "triangleq;": "\u225C",
      "triangleright;": "\u25B9",
      "trianglerighteq;": "\u22B5",
      "tridot;": "\u25EC",
      "trie;": "\u225C",
      "triminus;": "\u2A3A",
      "TripleDot;": "\u20DB",
      "triplus;": "\u2A39",
      "trisb;": "\u29CD",
      "tritime;": "\u2A3B",
      "trpezium;": "\u23E2",
      "Tscr;": "\u{1D4AF}",
      "tscr;": "\u{1D4C9}",
      "TScy;": "\u0426",
      "tscy;": "\u0446",
      "TSHcy;": "\u040B",
      "tshcy;": "\u045B",
      "Tstrok;": "\u0166",
      "tstrok;": "\u0167",
      "twixt;": "\u226C",
      "twoheadleftarrow;": "\u219E",
      "twoheadrightarrow;": "\u21A0",
      "Uacute;": "\xDA",
      "Uacute": "\xDA",
      "uacute;": "\xFA",
      "uacute": "\xFA",
      "Uarr;": "\u219F",
      "uArr;": "\u21D1",
      "uarr;": "\u2191",
      "Uarrocir;": "\u2949",
      "Ubrcy;": "\u040E",
      "ubrcy;": "\u045E",
      "Ubreve;": "\u016C",
      "ubreve;": "\u016D",
      "Ucirc;": "\xDB",
      "Ucirc": "\xDB",
      "ucirc;": "\xFB",
      "ucirc": "\xFB",
      "Ucy;": "\u0423",
      "ucy;": "\u0443",
      "udarr;": "\u21C5",
      "Udblac;": "\u0170",
      "udblac;": "\u0171",
      "udhar;": "\u296E",
      "ufisht;": "\u297E",
      "Ufr;": "\u{1D518}",
      "ufr;": "\u{1D532}",
      "Ugrave;": "\xD9",
      "Ugrave": "\xD9",
      "ugrave;": "\xF9",
      "ugrave": "\xF9",
      "uHar;": "\u2963",
      "uharl;": "\u21BF",
      "uharr;": "\u21BE",
      "uhblk;": "\u2580",
      "ulcorn;": "\u231C",
      "ulcorner;": "\u231C",
      "ulcrop;": "\u230F",
      "ultri;": "\u25F8",
      "Umacr;": "\u016A",
      "umacr;": "\u016B",
      "uml;": "\xA8",
      "uml": "\xA8",
      "UnderBar;": "_",
      "UnderBrace;": "\u23DF",
      "UnderBracket;": "\u23B5",
      "UnderParenthesis;": "\u23DD",
      "Union;": "\u22C3",
      "UnionPlus;": "\u228E",
      "Uogon;": "\u0172",
      "uogon;": "\u0173",
      "Uopf;": "\u{1D54C}",
      "uopf;": "\u{1D566}",
      "UpArrow;": "\u2191",
      "Uparrow;": "\u21D1",
      "uparrow;": "\u2191",
      "UpArrowBar;": "\u2912",
      "UpArrowDownArrow;": "\u21C5",
      "UpDownArrow;": "\u2195",
      "Updownarrow;": "\u21D5",
      "updownarrow;": "\u2195",
      "UpEquilibrium;": "\u296E",
      "upharpoonleft;": "\u21BF",
      "upharpoonright;": "\u21BE",
      "uplus;": "\u228E",
      "UpperLeftArrow;": "\u2196",
      "UpperRightArrow;": "\u2197",
      "Upsi;": "\u03D2",
      "upsi;": "\u03C5",
      "upsih;": "\u03D2",
      "Upsilon;": "\u03A5",
      "upsilon;": "\u03C5",
      "UpTee;": "\u22A5",
      "UpTeeArrow;": "\u21A5",
      "upuparrows;": "\u21C8",
      "urcorn;": "\u231D",
      "urcorner;": "\u231D",
      "urcrop;": "\u230E",
      "Uring;": "\u016E",
      "uring;": "\u016F",
      "urtri;": "\u25F9",
      "Uscr;": "\u{1D4B0}",
      "uscr;": "\u{1D4CA}",
      "utdot;": "\u22F0",
      "Utilde;": "\u0168",
      "utilde;": "\u0169",
      "utri;": "\u25B5",
      "utrif;": "\u25B4",
      "uuarr;": "\u21C8",
      "Uuml;": "\xDC",
      "Uuml": "\xDC",
      "uuml;": "\xFC",
      "uuml": "\xFC",
      "uwangle;": "\u29A7",
      "vangrt;": "\u299C",
      "varepsilon;": "\u03F5",
      "varkappa;": "\u03F0",
      "varnothing;": "\u2205",
      "varphi;": "\u03D5",
      "varpi;": "\u03D6",
      "varpropto;": "\u221D",
      "vArr;": "\u21D5",
      "varr;": "\u2195",
      "varrho;": "\u03F1",
      "varsigma;": "\u03C2",
      "varsubsetneq;": "\u228A\uFE00",
      "varsubsetneqq;": "\u2ACB\uFE00",
      "varsupsetneq;": "\u228B\uFE00",
      "varsupsetneqq;": "\u2ACC\uFE00",
      "vartheta;": "\u03D1",
      "vartriangleleft;": "\u22B2",
      "vartriangleright;": "\u22B3",
      "Vbar;": "\u2AEB",
      "vBar;": "\u2AE8",
      "vBarv;": "\u2AE9",
      "Vcy;": "\u0412",
      "vcy;": "\u0432",
      "VDash;": "\u22AB",
      "Vdash;": "\u22A9",
      "vDash;": "\u22A8",
      "vdash;": "\u22A2",
      "Vdashl;": "\u2AE6",
      "Vee;": "\u22C1",
      "vee;": "\u2228",
      "veebar;": "\u22BB",
      "veeeq;": "\u225A",
      "vellip;": "\u22EE",
      "Verbar;": "\u2016",
      "verbar;": "|",
      "Vert;": "\u2016",
      "vert;": "|",
      "VerticalBar;": "\u2223",
      "VerticalLine;": "|",
      "VerticalSeparator;": "\u2758",
      "VerticalTilde;": "\u2240",
      "VeryThinSpace;": "\u200A",
      "Vfr;": "\u{1D519}",
      "vfr;": "\u{1D533}",
      "vltri;": "\u22B2",
      "vnsub;": "\u2282\u20D2",
      "vnsup;": "\u2283\u20D2",
      "Vopf;": "\u{1D54D}",
      "vopf;": "\u{1D567}",
      "vprop;": "\u221D",
      "vrtri;": "\u22B3",
      "Vscr;": "\u{1D4B1}",
      "vscr;": "\u{1D4CB}",
      "vsubnE;": "\u2ACB\uFE00",
      "vsubne;": "\u228A\uFE00",
      "vsupnE;": "\u2ACC\uFE00",
      "vsupne;": "\u228B\uFE00",
      "Vvdash;": "\u22AA",
      "vzigzag;": "\u299A",
      "Wcirc;": "\u0174",
      "wcirc;": "\u0175",
      "wedbar;": "\u2A5F",
      "Wedge;": "\u22C0",
      "wedge;": "\u2227",
      "wedgeq;": "\u2259",
      "weierp;": "\u2118",
      "Wfr;": "\u{1D51A}",
      "wfr;": "\u{1D534}",
      "Wopf;": "\u{1D54E}",
      "wopf;": "\u{1D568}",
      "wp;": "\u2118",
      "wr;": "\u2240",
      "wreath;": "\u2240",
      "Wscr;": "\u{1D4B2}",
      "wscr;": "\u{1D4CC}",
      "xcap;": "\u22C2",
      "xcirc;": "\u25EF",
      "xcup;": "\u22C3",
      "xdtri;": "\u25BD",
      "Xfr;": "\u{1D51B}",
      "xfr;": "\u{1D535}",
      "xhArr;": "\u27FA",
      "xharr;": "\u27F7",
      "Xi;": "\u039E",
      "xi;": "\u03BE",
      "xlArr;": "\u27F8",
      "xlarr;": "\u27F5",
      "xmap;": "\u27FC",
      "xnis;": "\u22FB",
      "xodot;": "\u2A00",
      "Xopf;": "\u{1D54F}",
      "xopf;": "\u{1D569}",
      "xoplus;": "\u2A01",
      "xotime;": "\u2A02",
      "xrArr;": "\u27F9",
      "xrarr;": "\u27F6",
      "Xscr;": "\u{1D4B3}",
      "xscr;": "\u{1D4CD}",
      "xsqcup;": "\u2A06",
      "xuplus;": "\u2A04",
      "xutri;": "\u25B3",
      "xvee;": "\u22C1",
      "xwedge;": "\u22C0",
      "Yacute;": "\xDD",
      "Yacute": "\xDD",
      "yacute;": "\xFD",
      "yacute": "\xFD",
      "YAcy;": "\u042F",
      "yacy;": "\u044F",
      "Ycirc;": "\u0176",
      "ycirc;": "\u0177",
      "Ycy;": "\u042B",
      "ycy;": "\u044B",
      "yen;": "\xA5",
      "yen": "\xA5",
      "Yfr;": "\u{1D51C}",
      "yfr;": "\u{1D536}",
      "YIcy;": "\u0407",
      "yicy;": "\u0457",
      "Yopf;": "\u{1D550}",
      "yopf;": "\u{1D56A}",
      "Yscr;": "\u{1D4B4}",
      "yscr;": "\u{1D4CE}",
      "YUcy;": "\u042E",
      "yucy;": "\u044E",
      "Yuml;": "\u0178",
      "yuml;": "\xFF",
      "yuml": "\xFF",
      "Zacute;": "\u0179",
      "zacute;": "\u017A",
      "Zcaron;": "\u017D",
      "zcaron;": "\u017E",
      "Zcy;": "\u0417",
      "zcy;": "\u0437",
      "Zdot;": "\u017B",
      "zdot;": "\u017C",
      "zeetrf;": "\u2128",
      "ZeroWidthSpace;": "\u200B",
      "Zeta;": "\u0396",
      "zeta;": "\u03B6",
      "Zfr;": "\u2128",
      "zfr;": "\u{1D537}",
      "ZHcy;": "\u0416",
      "zhcy;": "\u0436",
      "zigrarr;": "\u21DD",
      "Zopf;": "\u2124",
      "zopf;": "\u{1D56B}",
      "Zscr;": "\u{1D4B5}",
      "zscr;": "\u{1D4CF}",
      "zwj;": "\u200D",
      "zwnj;": "\u200C"
    };
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/utils/strings.js
function startsWith(haystack, needle) {
  if (haystack.length < needle.length) {
    return false;
  }
  for (var i = 0; i < needle.length; i++) {
    if (haystack[i] !== needle[i]) {
      return false;
    }
  }
  return true;
}
function endsWith(haystack, needle) {
  var diff = haystack.length - needle.length;
  if (diff > 0) {
    return haystack.lastIndexOf(needle) === diff;
  } else if (diff === 0) {
    return haystack === needle;
  } else {
    return false;
  }
}
function repeat(value, count) {
  var s = "";
  while (count > 0) {
    if ((count & 1) === 1) {
      s += value;
    }
    value += value;
    count = count >>> 1;
  }
  return s;
}
function isLetterOrDigit(text, index) {
  var c = text.charCodeAt(index);
  return _a <= c && c <= _z || _A <= c && c <= _Z || _0 <= c && c <= _9;
}
var _a, _z, _A, _Z, _0, _9;
var init_strings = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/utils/strings.js"() {
    _a = "a".charCodeAt(0);
    _z = "z".charCodeAt(0);
    _A = "A".charCodeAt(0);
    _Z = "Z".charCodeAt(0);
    _0 = "0".charCodeAt(0);
    _9 = "9".charCodeAt(0);
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/utils/object.js
function isDefined(obj) {
  return typeof obj !== "undefined";
}
var init_object = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/utils/object.js"() {
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/utils/markup.js
function normalizeMarkupContent(input) {
  if (!input) {
    return void 0;
  }
  if (typeof input === "string") {
    return {
      kind: "markdown",
      value: input
    };
  }
  return {
    kind: "markdown",
    value: input.value
  };
}
var init_markup = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/utils/markup.js"() {
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/languageFacts/dataProvider.js
function generateDocumentation(item, settings, doesSupportMarkdown) {
  if (settings === void 0) {
    settings = {};
  }
  var result = {
    kind: doesSupportMarkdown ? "markdown" : "plaintext",
    value: ""
  };
  if (item.description && settings.documentation !== false) {
    var normalizedDescription = normalizeMarkupContent(item.description);
    if (normalizedDescription) {
      result.value += normalizedDescription.value;
    }
  }
  if (item.references && item.references.length > 0 && settings.references !== false) {
    if (result.value.length) {
      result.value += "\n\n";
    }
    if (doesSupportMarkdown) {
      result.value += item.references.map(function(r) {
        return "[" + r.name + "](" + r.url + ")";
      }).join(" | ");
    } else {
      result.value += item.references.map(function(r) {
        return r.name + ": " + r.url;
      }).join("\n");
    }
  }
  if (result.value === "") {
    return void 0;
  }
  return result;
}
var HTMLDataProvider;
var init_dataProvider = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/languageFacts/dataProvider.js"() {
    init_markup();
    HTMLDataProvider = function() {
      function HTMLDataProvider2(id, customData) {
        var _this = this;
        this.id = id;
        this._tags = [];
        this._tagMap = {};
        this._valueSetMap = {};
        this._tags = customData.tags || [];
        this._globalAttributes = customData.globalAttributes || [];
        this._tags.forEach(function(t) {
          _this._tagMap[t.name.toLowerCase()] = t;
        });
        if (customData.valueSets) {
          customData.valueSets.forEach(function(vs) {
            _this._valueSetMap[vs.name] = vs.values;
          });
        }
      }
      HTMLDataProvider2.prototype.isApplicable = function() {
        return true;
      };
      HTMLDataProvider2.prototype.getId = function() {
        return this.id;
      };
      HTMLDataProvider2.prototype.provideTags = function() {
        return this._tags;
      };
      HTMLDataProvider2.prototype.provideAttributes = function(tag) {
        var attributes = [];
        var processAttribute = function(a) {
          attributes.push(a);
        };
        var tagEntry = this._tagMap[tag.toLowerCase()];
        if (tagEntry) {
          tagEntry.attributes.forEach(processAttribute);
        }
        this._globalAttributes.forEach(processAttribute);
        return attributes;
      };
      HTMLDataProvider2.prototype.provideValues = function(tag, attribute) {
        var _this = this;
        var values = [];
        attribute = attribute.toLowerCase();
        var processAttributes = function(attributes) {
          attributes.forEach(function(a) {
            if (a.name.toLowerCase() === attribute) {
              if (a.values) {
                a.values.forEach(function(v) {
                  values.push(v);
                });
              }
              if (a.valueSet) {
                if (_this._valueSetMap[a.valueSet]) {
                  _this._valueSetMap[a.valueSet].forEach(function(v) {
                    values.push(v);
                  });
                }
              }
            }
          });
        };
        var tagEntry = this._tagMap[tag.toLowerCase()];
        if (tagEntry) {
          processAttributes(tagEntry.attributes);
        }
        processAttributes(this._globalAttributes);
        return values;
      };
      return HTMLDataProvider2;
    }();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/pathCompletion.js
function stripQuotes(fullValue) {
  if (startsWith(fullValue, "'") || startsWith(fullValue, '"')) {
    return fullValue.slice(1, -1);
  } else {
    return fullValue;
  }
}
function isCompletablePath(value) {
  if (startsWith(value, "http") || startsWith(value, "https") || startsWith(value, "//")) {
    return false;
  }
  return true;
}
function isPathAttribute(tag, attr) {
  if (attr === "src" || attr === "href") {
    return true;
  }
  var a = PATH_TAG_AND_ATTR[tag];
  if (a) {
    if (typeof a === "string") {
      return a === attr;
    } else {
      return a.indexOf(attr) !== -1;
    }
  }
  return false;
}
function pathToReplaceRange(valueBeforeCursor, fullValue, range) {
  var replaceRange;
  var lastIndexOfSlash = valueBeforeCursor.lastIndexOf("/");
  if (lastIndexOfSlash === -1) {
    replaceRange = shiftRange(range, 1, -1);
  } else {
    var valueAfterLastSlash = fullValue.slice(lastIndexOfSlash + 1);
    var startPos = shiftPosition(range.end, -1 - valueAfterLastSlash.length);
    var whitespaceIndex = valueAfterLastSlash.indexOf(" ");
    var endPos = void 0;
    if (whitespaceIndex !== -1) {
      endPos = shiftPosition(startPos, whitespaceIndex);
    } else {
      endPos = shiftPosition(range.end, -1);
    }
    replaceRange = Range2.create(startPos, endPos);
  }
  return replaceRange;
}
function createCompletionItem(p, isDir, replaceRange) {
  if (isDir) {
    p = p + "/";
    return {
      label: p,
      kind: CompletionItemKind2.Folder,
      textEdit: TextEdit2.replace(replaceRange, p),
      command: {
        title: "Suggest",
        command: "editor.action.triggerSuggest"
      }
    };
  } else {
    return {
      label: p,
      kind: CompletionItemKind2.File,
      textEdit: TextEdit2.replace(replaceRange, p)
    };
  }
}
function shiftPosition(pos, offset) {
  return Position2.create(pos.line, pos.character + offset);
}
function shiftRange(range, startOffset, endOffset) {
  var start = shiftPosition(range.start, startOffset);
  var end = shiftPosition(range.end, endOffset);
  return Range2.create(start, end);
}
var __awaiter, __generator, PathCompletionParticipant, CharCode_dot, PATH_TAG_AND_ATTR;
var init_pathCompletion = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/pathCompletion.js"() {
    init_htmlLanguageTypes();
    init_strings();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    PathCompletionParticipant = function() {
      function PathCompletionParticipant2(readDirectory) {
        this.readDirectory = readDirectory;
        this.atributeCompletions = [];
      }
      PathCompletionParticipant2.prototype.onHtmlAttributeValue = function(context) {
        if (isPathAttribute(context.tag, context.attribute)) {
          this.atributeCompletions.push(context);
        }
      };
      PathCompletionParticipant2.prototype.computeCompletions = function(document, documentContext) {
        return __awaiter(this, void 0, void 0, function() {
          var result, _i, _a2, attributeCompletion, fullValue, replaceRange, suggestions, _b, suggestions_1, item;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                result = { items: [], isIncomplete: false };
                _i = 0, _a2 = this.atributeCompletions;
                _c.label = 1;
              case 1:
                if (!(_i < _a2.length))
                  return [3, 5];
                attributeCompletion = _a2[_i];
                fullValue = stripQuotes(document.getText(attributeCompletion.range));
                if (!isCompletablePath(fullValue))
                  return [3, 4];
                if (!(fullValue === "." || fullValue === ".."))
                  return [3, 2];
                result.isIncomplete = true;
                return [3, 4];
              case 2:
                replaceRange = pathToReplaceRange(attributeCompletion.value, fullValue, attributeCompletion.range);
                return [4, this.providePathSuggestions(attributeCompletion.value, replaceRange, document, documentContext)];
              case 3:
                suggestions = _c.sent();
                for (_b = 0, suggestions_1 = suggestions; _b < suggestions_1.length; _b++) {
                  item = suggestions_1[_b];
                  result.items.push(item);
                }
                _c.label = 4;
              case 4:
                _i++;
                return [3, 1];
              case 5:
                return [2, result];
            }
          });
        });
      };
      PathCompletionParticipant2.prototype.providePathSuggestions = function(valueBeforeCursor, replaceRange, document, documentContext) {
        return __awaiter(this, void 0, void 0, function() {
          var valueBeforeLastSlash, parentDir, result, infos, _i, infos_1, _a2, name, type, e_1;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                valueBeforeLastSlash = valueBeforeCursor.substring(0, valueBeforeCursor.lastIndexOf("/") + 1);
                parentDir = documentContext.resolveReference(valueBeforeLastSlash || ".", document.uri);
                if (!parentDir)
                  return [3, 4];
                _b.label = 1;
              case 1:
                _b.trys.push([1, 3, , 4]);
                result = [];
                return [4, this.readDirectory(parentDir)];
              case 2:
                infos = _b.sent();
                for (_i = 0, infos_1 = infos; _i < infos_1.length; _i++) {
                  _a2 = infos_1[_i], name = _a2[0], type = _a2[1];
                  if (name.charCodeAt(0) !== CharCode_dot) {
                    result.push(createCompletionItem(name, type === FileType.Directory, replaceRange));
                  }
                }
                return [2, result];
              case 3:
                e_1 = _b.sent();
                return [3, 4];
              case 4:
                return [2, []];
            }
          });
        });
      };
      return PathCompletionParticipant2;
    }();
    CharCode_dot = ".".charCodeAt(0);
    PATH_TAG_AND_ATTR = {
      a: "href",
      area: "href",
      body: "background",
      del: "cite",
      form: "action",
      frame: ["src", "longdesc"],
      img: ["src", "longdesc"],
      ins: "cite",
      link: "href",
      object: "data",
      q: "cite",
      script: "src",
      audio: "src",
      button: "formaction",
      command: "icon",
      embed: "src",
      html: "manifest",
      input: ["src", "formaction"],
      source: "src",
      track: "src",
      video: ["src", "poster"]
    };
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlCompletion.js
function isQuote(s) {
  return /^["']*$/.test(s);
}
function isWhiteSpace(s) {
  return /^\s*$/.test(s);
}
function isFollowedBy(s, offset, intialState, expectedToken) {
  var scanner = createScanner(s, offset, intialState);
  var token = scanner.scan();
  while (token === TokenType.Whitespace) {
    token = scanner.scan();
  }
  return token === expectedToken;
}
function getWordStart(s, offset, limit) {
  while (offset > limit && !isWhiteSpace(s[offset - 1])) {
    offset--;
  }
  return offset;
}
function getWordEnd(s, offset, limit) {
  while (offset < limit && !isWhiteSpace(s[offset])) {
    offset++;
  }
  return offset;
}
var nls2, __awaiter2, __generator2, localize2, HTMLCompletion;
var init_htmlCompletion = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlCompletion.js"() {
    init_htmlScanner();
    init_htmlLanguageTypes();
    init_htmlEntities();
    nls2 = __toESM(require_main4());
    init_strings();
    init_fact();
    init_object();
    init_dataProvider();
    init_pathCompletion();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    localize2 = nls2.loadMessageBundle();
    HTMLCompletion = function() {
      function HTMLCompletion2(lsOptions, dataManager) {
        this.lsOptions = lsOptions;
        this.dataManager = dataManager;
        this.completionParticipants = [];
      }
      HTMLCompletion2.prototype.setCompletionParticipants = function(registeredCompletionParticipants) {
        this.completionParticipants = registeredCompletionParticipants || [];
      };
      HTMLCompletion2.prototype.doComplete2 = function(document, position, htmlDocument, documentContext, settings) {
        return __awaiter2(this, void 0, void 0, function() {
          var participant, contributedParticipants, result, pathCompletionResult;
          return __generator2(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!this.lsOptions.fileSystemProvider || !this.lsOptions.fileSystemProvider.readDirectory) {
                  return [2, this.doComplete(document, position, htmlDocument, settings)];
                }
                participant = new PathCompletionParticipant(this.lsOptions.fileSystemProvider.readDirectory);
                contributedParticipants = this.completionParticipants;
                this.completionParticipants = [participant].concat(contributedParticipants);
                result = this.doComplete(document, position, htmlDocument, settings);
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, , 3, 4]);
                return [4, participant.computeCompletions(document, documentContext)];
              case 2:
                pathCompletionResult = _a2.sent();
                return [2, {
                  isIncomplete: result.isIncomplete || pathCompletionResult.isIncomplete,
                  items: pathCompletionResult.items.concat(result.items)
                }];
              case 3:
                this.completionParticipants = contributedParticipants;
                return [7];
              case 4:
                return [2];
            }
          });
        });
      };
      HTMLCompletion2.prototype.doComplete = function(document, position, htmlDocument, settings) {
        var result = this._doComplete(document, position, htmlDocument, settings);
        return this.convertCompletionList(result);
      };
      HTMLCompletion2.prototype._doComplete = function(document, position, htmlDocument, settings) {
        var result = {
          isIncomplete: false,
          items: []
        };
        var completionParticipants = this.completionParticipants;
        var dataProviders = this.dataManager.getDataProviders().filter(function(p) {
          return p.isApplicable(document.languageId) && (!settings || settings[p.getId()] !== false);
        });
        var doesSupportMarkdown = this.doesSupportMarkdown();
        var text = document.getText();
        var offset = document.offsetAt(position);
        var node = htmlDocument.findNodeBefore(offset);
        if (!node) {
          return result;
        }
        var scanner = createScanner(text, node.start);
        var currentTag = "";
        var currentAttributeName;
        function getReplaceRange(replaceStart, replaceEnd) {
          if (replaceEnd === void 0) {
            replaceEnd = offset;
          }
          if (replaceStart > offset) {
            replaceStart = offset;
          }
          return { start: document.positionAt(replaceStart), end: document.positionAt(replaceEnd) };
        }
        function collectOpenTagSuggestions(afterOpenBracket2, tagNameEnd) {
          var range = getReplaceRange(afterOpenBracket2, tagNameEnd);
          dataProviders.forEach(function(provider) {
            provider.provideTags().forEach(function(tag) {
              result.items.push({
                label: tag.name,
                kind: CompletionItemKind2.Property,
                documentation: generateDocumentation(tag, void 0, doesSupportMarkdown),
                textEdit: TextEdit2.replace(range, tag.name),
                insertTextFormat: InsertTextFormat2.PlainText
              });
            });
          });
          return result;
        }
        function getLineIndent(offset2) {
          var start2 = offset2;
          while (start2 > 0) {
            var ch2 = text.charAt(start2 - 1);
            if ("\n\r".indexOf(ch2) >= 0) {
              return text.substring(start2, offset2);
            }
            if (!isWhiteSpace(ch2)) {
              return null;
            }
            start2--;
          }
          return text.substring(0, offset2);
        }
        function collectCloseTagSuggestions(afterOpenBracket2, inOpenTag, tagNameEnd) {
          if (tagNameEnd === void 0) {
            tagNameEnd = offset;
          }
          var range = getReplaceRange(afterOpenBracket2, tagNameEnd);
          var closeTag = isFollowedBy(text, tagNameEnd, ScannerState.WithinEndTag, TokenType.EndTagClose) ? "" : ">";
          var curr = node;
          if (inOpenTag) {
            curr = curr.parent;
          }
          while (curr) {
            var tag = curr.tag;
            if (tag && (!curr.closed || curr.endTagStart && curr.endTagStart > offset)) {
              var item = {
                label: "/" + tag,
                kind: CompletionItemKind2.Property,
                filterText: "/" + tag,
                textEdit: TextEdit2.replace(range, "/" + tag + closeTag),
                insertTextFormat: InsertTextFormat2.PlainText
              };
              var startIndent = getLineIndent(curr.start);
              var endIndent = getLineIndent(afterOpenBracket2 - 1);
              if (startIndent !== null && endIndent !== null && startIndent !== endIndent) {
                var insertText = startIndent + "</" + tag + closeTag;
                item.textEdit = TextEdit2.replace(getReplaceRange(afterOpenBracket2 - 1 - endIndent.length), insertText);
                item.filterText = endIndent + "</" + tag;
              }
              result.items.push(item);
              return result;
            }
            curr = curr.parent;
          }
          if (inOpenTag) {
            return result;
          }
          dataProviders.forEach(function(provider) {
            provider.provideTags().forEach(function(tag2) {
              result.items.push({
                label: "/" + tag2.name,
                kind: CompletionItemKind2.Property,
                documentation: generateDocumentation(tag2, void 0, doesSupportMarkdown),
                filterText: "/" + tag2.name + closeTag,
                textEdit: TextEdit2.replace(range, "/" + tag2.name + closeTag),
                insertTextFormat: InsertTextFormat2.PlainText
              });
            });
          });
          return result;
        }
        function collectAutoCloseTagSuggestion(tagCloseEnd, tag) {
          if (settings && settings.hideAutoCompleteProposals) {
            return result;
          }
          if (!isVoidElement(tag)) {
            var pos = document.positionAt(tagCloseEnd);
            result.items.push({
              label: "</" + tag + ">",
              kind: CompletionItemKind2.Property,
              filterText: "</" + tag + ">",
              textEdit: TextEdit2.insert(pos, "$0</" + tag + ">"),
              insertTextFormat: InsertTextFormat2.Snippet
            });
          }
          return result;
        }
        function collectTagSuggestions(tagStart, tagEnd) {
          collectOpenTagSuggestions(tagStart, tagEnd);
          collectCloseTagSuggestions(tagStart, true, tagEnd);
          return result;
        }
        function getExistingAttributes() {
          var existingAttributes = /* @__PURE__ */ Object.create(null);
          node.attributeNames.forEach(function(attribute) {
            existingAttributes[attribute] = true;
          });
          return existingAttributes;
        }
        function collectAttributeNameSuggestions(nameStart, nameEnd) {
          var _a2;
          if (nameEnd === void 0) {
            nameEnd = offset;
          }
          var replaceEnd = offset;
          while (replaceEnd < nameEnd && text[replaceEnd] !== "<") {
            replaceEnd++;
          }
          var currentAttribute = text.substring(nameStart, nameEnd);
          var range = getReplaceRange(nameStart, replaceEnd);
          var value = "";
          if (!isFollowedBy(text, nameEnd, ScannerState.AfterAttributeName, TokenType.DelimiterAssign)) {
            var defaultValue = (_a2 = settings === null || settings === void 0 ? void 0 : settings.attributeDefaultValue) !== null && _a2 !== void 0 ? _a2 : "doublequotes";
            if (defaultValue === "empty") {
              value = "=$1";
            } else if (defaultValue === "singlequotes") {
              value = "='$1'";
            } else {
              value = '="$1"';
            }
          }
          var seenAttributes = getExistingAttributes();
          seenAttributes[currentAttribute] = false;
          dataProviders.forEach(function(provider) {
            provider.provideAttributes(currentTag).forEach(function(attr) {
              if (seenAttributes[attr.name]) {
                return;
              }
              seenAttributes[attr.name] = true;
              var codeSnippet = attr.name;
              var command;
              if (attr.valueSet !== "v" && value.length) {
                codeSnippet = codeSnippet + value;
                if (attr.valueSet || attr.name === "style") {
                  command = {
                    title: "Suggest",
                    command: "editor.action.triggerSuggest"
                  };
                }
              }
              result.items.push({
                label: attr.name,
                kind: attr.valueSet === "handler" ? CompletionItemKind2.Function : CompletionItemKind2.Value,
                documentation: generateDocumentation(attr, void 0, doesSupportMarkdown),
                textEdit: TextEdit2.replace(range, codeSnippet),
                insertTextFormat: InsertTextFormat2.Snippet,
                command
              });
            });
          });
          collectDataAttributesSuggestions(range, seenAttributes);
          return result;
        }
        function collectDataAttributesSuggestions(range, seenAttributes) {
          var dataAttr = "data-";
          var dataAttributes = {};
          dataAttributes[dataAttr] = dataAttr + '$1="$2"';
          function addNodeDataAttributes(node2) {
            node2.attributeNames.forEach(function(attr) {
              if (startsWith(attr, dataAttr) && !dataAttributes[attr] && !seenAttributes[attr]) {
                dataAttributes[attr] = attr + '="$1"';
              }
            });
            node2.children.forEach(function(child) {
              return addNodeDataAttributes(child);
            });
          }
          if (htmlDocument) {
            htmlDocument.roots.forEach(function(root) {
              return addNodeDataAttributes(root);
            });
          }
          Object.keys(dataAttributes).forEach(function(attr) {
            return result.items.push({
              label: attr,
              kind: CompletionItemKind2.Value,
              textEdit: TextEdit2.replace(range, dataAttributes[attr]),
              insertTextFormat: InsertTextFormat2.Snippet
            });
          });
        }
        function collectAttributeValueSuggestions(valueStart, valueEnd) {
          if (valueEnd === void 0) {
            valueEnd = offset;
          }
          var range;
          var addQuotes;
          var valuePrefix;
          if (offset > valueStart && offset <= valueEnd && isQuote(text[valueStart])) {
            var valueContentStart = valueStart + 1;
            var valueContentEnd = valueEnd;
            if (valueEnd > valueStart && text[valueEnd - 1] === text[valueStart]) {
              valueContentEnd--;
            }
            var wsBefore = getWordStart(text, offset, valueContentStart);
            var wsAfter = getWordEnd(text, offset, valueContentEnd);
            range = getReplaceRange(wsBefore, wsAfter);
            valuePrefix = offset >= valueContentStart && offset <= valueContentEnd ? text.substring(valueContentStart, offset) : "";
            addQuotes = false;
          } else {
            range = getReplaceRange(valueStart, valueEnd);
            valuePrefix = text.substring(valueStart, offset);
            addQuotes = true;
          }
          if (completionParticipants.length > 0) {
            var tag = currentTag.toLowerCase();
            var attribute = currentAttributeName.toLowerCase();
            var fullRange = getReplaceRange(valueStart, valueEnd);
            for (var _i = 0, completionParticipants_1 = completionParticipants; _i < completionParticipants_1.length; _i++) {
              var participant = completionParticipants_1[_i];
              if (participant.onHtmlAttributeValue) {
                participant.onHtmlAttributeValue({ document, position, tag, attribute, value: valuePrefix, range: fullRange });
              }
            }
          }
          dataProviders.forEach(function(provider) {
            provider.provideValues(currentTag, currentAttributeName).forEach(function(value) {
              var insertText = addQuotes ? '"' + value.name + '"' : value.name;
              result.items.push({
                label: value.name,
                filterText: insertText,
                kind: CompletionItemKind2.Unit,
                documentation: generateDocumentation(value, void 0, doesSupportMarkdown),
                textEdit: TextEdit2.replace(range, insertText),
                insertTextFormat: InsertTextFormat2.PlainText
              });
            });
          });
          collectCharacterEntityProposals();
          return result;
        }
        function scanNextForEndPos(nextToken) {
          if (offset === scanner.getTokenEnd()) {
            token = scanner.scan();
            if (token === nextToken && scanner.getTokenOffset() === offset) {
              return scanner.getTokenEnd();
            }
          }
          return offset;
        }
        function collectInsideContent() {
          for (var _i = 0, completionParticipants_2 = completionParticipants; _i < completionParticipants_2.length; _i++) {
            var participant = completionParticipants_2[_i];
            if (participant.onHtmlContent) {
              participant.onHtmlContent({ document, position });
            }
          }
          return collectCharacterEntityProposals();
        }
        function collectCharacterEntityProposals() {
          var k = offset - 1;
          var characterStart = position.character;
          while (k >= 0 && isLetterOrDigit(text, k)) {
            k--;
            characterStart--;
          }
          if (k >= 0 && text[k] === "&") {
            var range = Range2.create(Position2.create(position.line, characterStart - 1), position);
            for (var entity in entities) {
              if (endsWith(entity, ";")) {
                var label = "&" + entity;
                result.items.push({
                  label,
                  kind: CompletionItemKind2.Keyword,
                  documentation: localize2("entity.propose", "Character entity representing '" + entities[entity] + "'"),
                  textEdit: TextEdit2.replace(range, label),
                  insertTextFormat: InsertTextFormat2.PlainText
                });
              }
            }
          }
          return result;
        }
        function suggestDoctype(replaceStart, replaceEnd) {
          var range = getReplaceRange(replaceStart, replaceEnd);
          result.items.push({
            label: "!DOCTYPE",
            kind: CompletionItemKind2.Property,
            documentation: "A preamble for an HTML document.",
            textEdit: TextEdit2.replace(range, "!DOCTYPE html>"),
            insertTextFormat: InsertTextFormat2.PlainText
          });
        }
        var token = scanner.scan();
        while (token !== TokenType.EOS && scanner.getTokenOffset() <= offset) {
          switch (token) {
            case TokenType.StartTagOpen:
              if (scanner.getTokenEnd() === offset) {
                var endPos = scanNextForEndPos(TokenType.StartTag);
                if (position.line === 0) {
                  suggestDoctype(offset, endPos);
                }
                return collectTagSuggestions(offset, endPos);
              }
              break;
            case TokenType.StartTag:
              if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                return collectOpenTagSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
              }
              currentTag = scanner.getTokenText();
              break;
            case TokenType.AttributeName:
              if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                return collectAttributeNameSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
              }
              currentAttributeName = scanner.getTokenText();
              break;
            case TokenType.DelimiterAssign:
              if (scanner.getTokenEnd() === offset) {
                var endPos = scanNextForEndPos(TokenType.AttributeValue);
                return collectAttributeValueSuggestions(offset, endPos);
              }
              break;
            case TokenType.AttributeValue:
              if (scanner.getTokenOffset() <= offset && offset <= scanner.getTokenEnd()) {
                return collectAttributeValueSuggestions(scanner.getTokenOffset(), scanner.getTokenEnd());
              }
              break;
            case TokenType.Whitespace:
              if (offset <= scanner.getTokenEnd()) {
                switch (scanner.getScannerState()) {
                  case ScannerState.AfterOpeningStartTag:
                    var startPos = scanner.getTokenOffset();
                    var endTagPos = scanNextForEndPos(TokenType.StartTag);
                    return collectTagSuggestions(startPos, endTagPos);
                  case ScannerState.WithinTag:
                  case ScannerState.AfterAttributeName:
                    return collectAttributeNameSuggestions(scanner.getTokenEnd());
                  case ScannerState.BeforeAttributeValue:
                    return collectAttributeValueSuggestions(scanner.getTokenEnd());
                  case ScannerState.AfterOpeningEndTag:
                    return collectCloseTagSuggestions(scanner.getTokenOffset() - 1, false);
                  case ScannerState.WithinContent:
                    return collectInsideContent();
                }
              }
              break;
            case TokenType.EndTagOpen:
              if (offset <= scanner.getTokenEnd()) {
                var afterOpenBracket = scanner.getTokenOffset() + 1;
                var endOffset = scanNextForEndPos(TokenType.EndTag);
                return collectCloseTagSuggestions(afterOpenBracket, false, endOffset);
              }
              break;
            case TokenType.EndTag:
              if (offset <= scanner.getTokenEnd()) {
                var start = scanner.getTokenOffset() - 1;
                while (start >= 0) {
                  var ch = text.charAt(start);
                  if (ch === "/") {
                    return collectCloseTagSuggestions(start, false, scanner.getTokenEnd());
                  } else if (!isWhiteSpace(ch)) {
                    break;
                  }
                  start--;
                }
              }
              break;
            case TokenType.StartTagClose:
              if (offset <= scanner.getTokenEnd()) {
                if (currentTag) {
                  return collectAutoCloseTagSuggestion(scanner.getTokenEnd(), currentTag);
                }
              }
              break;
            case TokenType.Content:
              if (offset <= scanner.getTokenEnd()) {
                return collectInsideContent();
              }
              break;
            default:
              if (offset <= scanner.getTokenEnd()) {
                return result;
              }
              break;
          }
          token = scanner.scan();
        }
        return result;
      };
      HTMLCompletion2.prototype.doQuoteComplete = function(document, position, htmlDocument, settings) {
        var _a2;
        var offset = document.offsetAt(position);
        if (offset <= 0) {
          return null;
        }
        var defaultValue = (_a2 = settings === null || settings === void 0 ? void 0 : settings.attributeDefaultValue) !== null && _a2 !== void 0 ? _a2 : "doublequotes";
        if (defaultValue === "empty") {
          return null;
        }
        var char = document.getText().charAt(offset - 1);
        if (char !== "=") {
          return null;
        }
        var value = defaultValue === "doublequotes" ? '"$1"' : "'$1'";
        var node = htmlDocument.findNodeBefore(offset);
        if (node && node.attributes && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {
          var scanner = createScanner(document.getText(), node.start);
          var token = scanner.scan();
          while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {
            if (token === TokenType.AttributeName && scanner.getTokenEnd() === offset - 1) {
              token = scanner.scan();
              if (token !== TokenType.DelimiterAssign) {
                return null;
              }
              token = scanner.scan();
              if (token === TokenType.Unknown || token === TokenType.AttributeValue) {
                return null;
              }
              return value;
            }
            token = scanner.scan();
          }
        }
        return null;
      };
      HTMLCompletion2.prototype.doTagComplete = function(document, position, htmlDocument) {
        var offset = document.offsetAt(position);
        if (offset <= 0) {
          return null;
        }
        var char = document.getText().charAt(offset - 1);
        if (char === ">") {
          var node = htmlDocument.findNodeBefore(offset);
          if (node && node.tag && !isVoidElement(node.tag) && node.start < offset && (!node.endTagStart || node.endTagStart > offset)) {
            var scanner = createScanner(document.getText(), node.start);
            var token = scanner.scan();
            while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {
              if (token === TokenType.StartTagClose && scanner.getTokenEnd() === offset) {
                return "$0</" + node.tag + ">";
              }
              token = scanner.scan();
            }
          }
        } else if (char === "/") {
          var node = htmlDocument.findNodeBefore(offset);
          while (node && node.closed && !(node.endTagStart && node.endTagStart > offset)) {
            node = node.parent;
          }
          if (node && node.tag) {
            var scanner = createScanner(document.getText(), node.start);
            var token = scanner.scan();
            while (token !== TokenType.EOS && scanner.getTokenEnd() <= offset) {
              if (token === TokenType.EndTagOpen && scanner.getTokenEnd() === offset) {
                return node.tag + ">";
              }
              token = scanner.scan();
            }
          }
        }
        return null;
      };
      HTMLCompletion2.prototype.convertCompletionList = function(list) {
        if (!this.doesSupportMarkdown()) {
          list.items.forEach(function(item) {
            if (item.documentation && typeof item.documentation !== "string") {
              item.documentation = {
                kind: "plaintext",
                value: item.documentation.value
              };
            }
          });
        }
        return list;
      };
      HTMLCompletion2.prototype.doesSupportMarkdown = function() {
        var _a2, _b, _c;
        if (!isDefined(this.supportsMarkdown)) {
          if (!isDefined(this.lsOptions.clientCapabilities)) {
            this.supportsMarkdown = true;
            return this.supportsMarkdown;
          }
          var documentationFormat = (_c = (_b = (_a2 = this.lsOptions.clientCapabilities.textDocument) === null || _a2 === void 0 ? void 0 : _a2.completion) === null || _b === void 0 ? void 0 : _b.completionItem) === null || _c === void 0 ? void 0 : _c.documentationFormat;
          this.supportsMarkdown = Array.isArray(documentationFormat) && documentationFormat.indexOf(MarkupKind2.Markdown) !== -1;
        }
        return this.supportsMarkdown;
      };
      return HTMLCompletion2;
    }();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlHover.js
function trimQuotes(s) {
  if (s.length <= 1) {
    return s.replace(/['"]/, "");
  }
  if (s[0] === "'" || s[0] === '"') {
    s = s.slice(1);
  }
  if (s[s.length - 1] === "'" || s[s.length - 1] === '"') {
    s = s.slice(0, -1);
  }
  return s;
}
var nls3, localize3, HTMLHover;
var init_htmlHover = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlHover.js"() {
    init_htmlScanner();
    init_htmlLanguageTypes();
    init_object();
    init_dataProvider();
    init_htmlEntities();
    init_strings();
    nls3 = __toESM(require_main4());
    localize3 = nls3.loadMessageBundle();
    HTMLHover = function() {
      function HTMLHover2(lsOptions, dataManager) {
        this.lsOptions = lsOptions;
        this.dataManager = dataManager;
      }
      HTMLHover2.prototype.doHover = function(document, position, htmlDocument, options) {
        var convertContents = this.convertContents.bind(this);
        var doesSupportMarkdown = this.doesSupportMarkdown();
        var offset = document.offsetAt(position);
        var node = htmlDocument.findNodeAt(offset);
        var text = document.getText();
        if (!node || !node.tag) {
          return null;
        }
        var dataProviders = this.dataManager.getDataProviders().filter(function(p) {
          return p.isApplicable(document.languageId);
        });
        function getTagHover(currTag, range, open) {
          var _loop_1 = function(provider2) {
            var hover = null;
            provider2.provideTags().forEach(function(tag2) {
              if (tag2.name.toLowerCase() === currTag.toLowerCase()) {
                var markupContent = generateDocumentation(tag2, options, doesSupportMarkdown);
                if (!markupContent) {
                  markupContent = {
                    kind: doesSupportMarkdown ? "markdown" : "plaintext",
                    value: ""
                  };
                }
                hover = { contents: markupContent, range };
              }
            });
            if (hover) {
              hover.contents = convertContents(hover.contents);
              return { value: hover };
            }
          };
          for (var _i = 0, dataProviders_1 = dataProviders; _i < dataProviders_1.length; _i++) {
            var provider = dataProviders_1[_i];
            var state_1 = _loop_1(provider);
            if (typeof state_1 === "object")
              return state_1.value;
          }
          return null;
        }
        function getAttrHover(currTag, currAttr, range) {
          var _loop_2 = function(provider2) {
            var hover = null;
            provider2.provideAttributes(currTag).forEach(function(attr2) {
              if (currAttr === attr2.name && attr2.description) {
                var contentsDoc = generateDocumentation(attr2, options, doesSupportMarkdown);
                if (contentsDoc) {
                  hover = { contents: contentsDoc, range };
                } else {
                  hover = null;
                }
              }
            });
            if (hover) {
              hover.contents = convertContents(hover.contents);
              return { value: hover };
            }
          };
          for (var _i = 0, dataProviders_2 = dataProviders; _i < dataProviders_2.length; _i++) {
            var provider = dataProviders_2[_i];
            var state_2 = _loop_2(provider);
            if (typeof state_2 === "object")
              return state_2.value;
          }
          return null;
        }
        function getAttrValueHover(currTag, currAttr, currAttrValue, range) {
          var _loop_3 = function(provider2) {
            var hover = null;
            provider2.provideValues(currTag, currAttr).forEach(function(attrValue2) {
              if (currAttrValue === attrValue2.name && attrValue2.description) {
                var contentsDoc = generateDocumentation(attrValue2, options, doesSupportMarkdown);
                if (contentsDoc) {
                  hover = { contents: contentsDoc, range };
                } else {
                  hover = null;
                }
              }
            });
            if (hover) {
              hover.contents = convertContents(hover.contents);
              return { value: hover };
            }
          };
          for (var _i = 0, dataProviders_3 = dataProviders; _i < dataProviders_3.length; _i++) {
            var provider = dataProviders_3[_i];
            var state_3 = _loop_3(provider);
            if (typeof state_3 === "object")
              return state_3.value;
          }
          return null;
        }
        function getEntityHover(text2, range) {
          var currEntity = filterEntity(text2);
          for (var entity in entities) {
            var hover = null;
            var label = "&" + entity;
            if (currEntity === label) {
              var code = entities[entity].charCodeAt(0).toString(16).toUpperCase();
              var hex = "U+";
              if (code.length < 4) {
                var zeroes = 4 - code.length;
                var k = 0;
                while (k < zeroes) {
                  hex += "0";
                  k += 1;
                }
              }
              hex += code;
              var contentsDoc = localize3("entity.propose", "Character entity representing '" + entities[entity] + "', unicode equivalent '" + hex + "'");
              if (contentsDoc) {
                hover = { contents: contentsDoc, range };
              } else {
                hover = null;
              }
            }
            if (hover) {
              hover.contents = convertContents(hover.contents);
              return hover;
            }
          }
          return null;
        }
        function getTagNameRange2(tokenType, startOffset) {
          var scanner = createScanner(document.getText(), startOffset);
          var token = scanner.scan();
          while (token !== TokenType.EOS && (scanner.getTokenEnd() < offset || scanner.getTokenEnd() === offset && token !== tokenType)) {
            token = scanner.scan();
          }
          if (token === tokenType && offset <= scanner.getTokenEnd()) {
            return { start: document.positionAt(scanner.getTokenOffset()), end: document.positionAt(scanner.getTokenEnd()) };
          }
          return null;
        }
        function getEntityRange() {
          var k = offset - 1;
          var characterStart = position.character;
          while (k >= 0 && isLetterOrDigit(text, k)) {
            k--;
            characterStart--;
          }
          var n = k + 1;
          var characterEnd = characterStart;
          while (isLetterOrDigit(text, n)) {
            n++;
            characterEnd++;
          }
          if (k >= 0 && text[k] === "&") {
            var range = null;
            if (text[n] === ";") {
              range = Range2.create(Position2.create(position.line, characterStart), Position2.create(position.line, characterEnd + 1));
            } else {
              range = Range2.create(Position2.create(position.line, characterStart), Position2.create(position.line, characterEnd));
            }
            return range;
          }
          return null;
        }
        function filterEntity(text2) {
          var k = offset - 1;
          var newText = "&";
          while (k >= 0 && isLetterOrDigit(text2, k)) {
            k--;
          }
          k = k + 1;
          while (isLetterOrDigit(text2, k)) {
            newText += text2[k];
            k += 1;
          }
          newText += ";";
          return newText;
        }
        if (node.endTagStart && offset >= node.endTagStart) {
          var tagRange_1 = getTagNameRange2(TokenType.EndTag, node.endTagStart);
          if (tagRange_1) {
            return getTagHover(node.tag, tagRange_1, false);
          }
          return null;
        }
        var tagRange = getTagNameRange2(TokenType.StartTag, node.start);
        if (tagRange) {
          return getTagHover(node.tag, tagRange, true);
        }
        var attrRange = getTagNameRange2(TokenType.AttributeName, node.start);
        if (attrRange) {
          var tag = node.tag;
          var attr = document.getText(attrRange);
          return getAttrHover(tag, attr, attrRange);
        }
        var entityRange = getEntityRange();
        if (entityRange) {
          return getEntityHover(text, entityRange);
        }
        function scanAttrAndAttrValue(nodeStart, attrValueStart) {
          var scanner = createScanner(document.getText(), nodeStart);
          var token = scanner.scan();
          var prevAttr = void 0;
          while (token !== TokenType.EOS && scanner.getTokenEnd() <= attrValueStart) {
            token = scanner.scan();
            if (token === TokenType.AttributeName) {
              prevAttr = scanner.getTokenText();
            }
          }
          return prevAttr;
        }
        var attrValueRange = getTagNameRange2(TokenType.AttributeValue, node.start);
        if (attrValueRange) {
          var tag = node.tag;
          var attrValue = trimQuotes(document.getText(attrValueRange));
          var matchAttr = scanAttrAndAttrValue(node.start, document.offsetAt(attrValueRange.start));
          if (matchAttr) {
            return getAttrValueHover(tag, matchAttr, attrValue, attrValueRange);
          }
        }
        return null;
      };
      HTMLHover2.prototype.convertContents = function(contents) {
        if (!this.doesSupportMarkdown()) {
          if (typeof contents === "string") {
            return contents;
          } else if ("kind" in contents) {
            return {
              kind: "plaintext",
              value: contents.value
            };
          } else if (Array.isArray(contents)) {
            contents.map(function(c) {
              return typeof c === "string" ? c : c.value;
            });
          } else {
            return contents.value;
          }
        }
        return contents;
      };
      HTMLHover2.prototype.doesSupportMarkdown = function() {
        var _a2, _b, _c;
        if (!isDefined(this.supportsMarkdown)) {
          if (!isDefined(this.lsOptions.clientCapabilities)) {
            this.supportsMarkdown = true;
            return this.supportsMarkdown;
          }
          var contentFormat = (_c = (_b = (_a2 = this.lsOptions.clientCapabilities) === null || _a2 === void 0 ? void 0 : _a2.textDocument) === null || _b === void 0 ? void 0 : _b.hover) === null || _c === void 0 ? void 0 : _c.contentFormat;
          this.supportsMarkdown = Array.isArray(contentFormat) && contentFormat.indexOf(MarkupKind2.Markdown) !== -1;
        }
        return this.supportsMarkdown;
      };
      return HTMLHover2;
    }();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/beautify/beautify.js
function js_beautify(js_source_text, options) {
  return js_source_text;
}
var init_beautify = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/beautify/beautify.js"() {
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/beautify/beautify-css.js
var legacy_beautify_css, css_beautify;
var init_beautify_css = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/beautify/beautify-css.js"() {
    (function() {
      "use strict";
      var __webpack_modules__ = [
        ,
        ,
        function(module2) {
          function OutputLine(parent) {
            this.__parent = parent;
            this.__character_count = 0;
            this.__indent_count = -1;
            this.__alignment_count = 0;
            this.__wrap_point_index = 0;
            this.__wrap_point_character_count = 0;
            this.__wrap_point_indent_count = -1;
            this.__wrap_point_alignment_count = 0;
            this.__items = [];
          }
          OutputLine.prototype.clone_empty = function() {
            var line = new OutputLine(this.__parent);
            line.set_indent(this.__indent_count, this.__alignment_count);
            return line;
          };
          OutputLine.prototype.item = function(index) {
            if (index < 0) {
              return this.__items[this.__items.length + index];
            } else {
              return this.__items[index];
            }
          };
          OutputLine.prototype.has_match = function(pattern) {
            for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
              if (this.__items[lastCheckedOutput].match(pattern)) {
                return true;
              }
            }
            return false;
          };
          OutputLine.prototype.set_indent = function(indent, alignment) {
            if (this.is_empty()) {
              this.__indent_count = indent || 0;
              this.__alignment_count = alignment || 0;
              this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
            }
          };
          OutputLine.prototype._set_wrap_point = function() {
            if (this.__parent.wrap_line_length) {
              this.__wrap_point_index = this.__items.length;
              this.__wrap_point_character_count = this.__character_count;
              this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
              this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
            }
          };
          OutputLine.prototype._should_wrap = function() {
            return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
          };
          OutputLine.prototype._allow_wrap = function() {
            if (this._should_wrap()) {
              this.__parent.add_new_line();
              var next = this.__parent.current_line;
              next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
              next.__items = this.__items.slice(this.__wrap_point_index);
              this.__items = this.__items.slice(0, this.__wrap_point_index);
              next.__character_count += this.__character_count - this.__wrap_point_character_count;
              this.__character_count = this.__wrap_point_character_count;
              if (next.__items[0] === " ") {
                next.__items.splice(0, 1);
                next.__character_count -= 1;
              }
              return true;
            }
            return false;
          };
          OutputLine.prototype.is_empty = function() {
            return this.__items.length === 0;
          };
          OutputLine.prototype.last = function() {
            if (!this.is_empty()) {
              return this.__items[this.__items.length - 1];
            } else {
              return null;
            }
          };
          OutputLine.prototype.push = function(item) {
            this.__items.push(item);
            var last_newline_index = item.lastIndexOf("\n");
            if (last_newline_index !== -1) {
              this.__character_count = item.length - last_newline_index;
            } else {
              this.__character_count += item.length;
            }
          };
          OutputLine.prototype.pop = function() {
            var item = null;
            if (!this.is_empty()) {
              item = this.__items.pop();
              this.__character_count -= item.length;
            }
            return item;
          };
          OutputLine.prototype._remove_indent = function() {
            if (this.__indent_count > 0) {
              this.__indent_count -= 1;
              this.__character_count -= this.__parent.indent_size;
            }
          };
          OutputLine.prototype._remove_wrap_indent = function() {
            if (this.__wrap_point_indent_count > 0) {
              this.__wrap_point_indent_count -= 1;
            }
          };
          OutputLine.prototype.trim = function() {
            while (this.last() === " ") {
              this.__items.pop();
              this.__character_count -= 1;
            }
          };
          OutputLine.prototype.toString = function() {
            var result = "";
            if (this.is_empty()) {
              if (this.__parent.indent_empty_lines) {
                result = this.__parent.get_indent_string(this.__indent_count);
              }
            } else {
              result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
              result += this.__items.join("");
            }
            return result;
          };
          function IndentStringCache(options, baseIndentString) {
            this.__cache = [""];
            this.__indent_size = options.indent_size;
            this.__indent_string = options.indent_char;
            if (!options.indent_with_tabs) {
              this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
            }
            baseIndentString = baseIndentString || "";
            if (options.indent_level > 0) {
              baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
            }
            this.__base_string = baseIndentString;
            this.__base_string_length = baseIndentString.length;
          }
          IndentStringCache.prototype.get_indent_size = function(indent, column) {
            var result = this.__base_string_length;
            column = column || 0;
            if (indent < 0) {
              result = 0;
            }
            result += indent * this.__indent_size;
            result += column;
            return result;
          };
          IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
            var result = this.__base_string;
            column = column || 0;
            if (indent_level < 0) {
              indent_level = 0;
              result = "";
            }
            column += indent_level * this.__indent_size;
            this.__ensure_cache(column);
            result += this.__cache[column];
            return result;
          };
          IndentStringCache.prototype.__ensure_cache = function(column) {
            while (column >= this.__cache.length) {
              this.__add_column();
            }
          };
          IndentStringCache.prototype.__add_column = function() {
            var column = this.__cache.length;
            var indent = 0;
            var result = "";
            if (this.__indent_size && column >= this.__indent_size) {
              indent = Math.floor(column / this.__indent_size);
              column -= indent * this.__indent_size;
              result = new Array(indent + 1).join(this.__indent_string);
            }
            if (column) {
              result += new Array(column + 1).join(" ");
            }
            this.__cache.push(result);
          };
          function Output(options, baseIndentString) {
            this.__indent_cache = new IndentStringCache(options, baseIndentString);
            this.raw = false;
            this._end_with_newline = options.end_with_newline;
            this.indent_size = options.indent_size;
            this.wrap_line_length = options.wrap_line_length;
            this.indent_empty_lines = options.indent_empty_lines;
            this.__lines = [];
            this.previous_line = null;
            this.current_line = null;
            this.next_line = new OutputLine(this);
            this.space_before_token = false;
            this.non_breaking_space = false;
            this.previous_token_wrapped = false;
            this.__add_outputline();
          }
          Output.prototype.__add_outputline = function() {
            this.previous_line = this.current_line;
            this.current_line = this.next_line.clone_empty();
            this.__lines.push(this.current_line);
          };
          Output.prototype.get_line_number = function() {
            return this.__lines.length;
          };
          Output.prototype.get_indent_string = function(indent, column) {
            return this.__indent_cache.get_indent_string(indent, column);
          };
          Output.prototype.get_indent_size = function(indent, column) {
            return this.__indent_cache.get_indent_size(indent, column);
          };
          Output.prototype.is_empty = function() {
            return !this.previous_line && this.current_line.is_empty();
          };
          Output.prototype.add_new_line = function(force_newline) {
            if (this.is_empty() || !force_newline && this.just_added_newline()) {
              return false;
            }
            if (!this.raw) {
              this.__add_outputline();
            }
            return true;
          };
          Output.prototype.get_code = function(eol) {
            this.trim(true);
            var last_item = this.current_line.pop();
            if (last_item) {
              if (last_item[last_item.length - 1] === "\n") {
                last_item = last_item.replace(/\n+$/g, "");
              }
              this.current_line.push(last_item);
            }
            if (this._end_with_newline) {
              this.__add_outputline();
            }
            var sweet_code = this.__lines.join("\n");
            if (eol !== "\n") {
              sweet_code = sweet_code.replace(/[\n]/g, eol);
            }
            return sweet_code;
          };
          Output.prototype.set_wrap_point = function() {
            this.current_line._set_wrap_point();
          };
          Output.prototype.set_indent = function(indent, alignment) {
            indent = indent || 0;
            alignment = alignment || 0;
            this.next_line.set_indent(indent, alignment);
            if (this.__lines.length > 1) {
              this.current_line.set_indent(indent, alignment);
              return true;
            }
            this.current_line.set_indent();
            return false;
          };
          Output.prototype.add_raw_token = function(token) {
            for (var x = 0; x < token.newlines; x++) {
              this.__add_outputline();
            }
            this.current_line.set_indent(-1);
            this.current_line.push(token.whitespace_before);
            this.current_line.push(token.text);
            this.space_before_token = false;
            this.non_breaking_space = false;
            this.previous_token_wrapped = false;
          };
          Output.prototype.add_token = function(printable_token) {
            this.__add_space_before_token();
            this.current_line.push(printable_token);
            this.space_before_token = false;
            this.non_breaking_space = false;
            this.previous_token_wrapped = this.current_line._allow_wrap();
          };
          Output.prototype.__add_space_before_token = function() {
            if (this.space_before_token && !this.just_added_newline()) {
              if (!this.non_breaking_space) {
                this.set_wrap_point();
              }
              this.current_line.push(" ");
            }
          };
          Output.prototype.remove_indent = function(index) {
            var output_length = this.__lines.length;
            while (index < output_length) {
              this.__lines[index]._remove_indent();
              index++;
            }
            this.current_line._remove_wrap_indent();
          };
          Output.prototype.trim = function(eat_newlines) {
            eat_newlines = eat_newlines === void 0 ? false : eat_newlines;
            this.current_line.trim();
            while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
              this.__lines.pop();
              this.current_line = this.__lines[this.__lines.length - 1];
              this.current_line.trim();
            }
            this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
          };
          Output.prototype.just_added_newline = function() {
            return this.current_line.is_empty();
          };
          Output.prototype.just_added_blankline = function() {
            return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
          };
          Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
            var index = this.__lines.length - 2;
            while (index >= 0) {
              var potentialEmptyLine = this.__lines[index];
              if (potentialEmptyLine.is_empty()) {
                break;
              } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
                this.__lines.splice(index + 1, 0, new OutputLine(this));
                this.previous_line = this.__lines[this.__lines.length - 2];
                break;
              }
              index--;
            }
          };
          module2.exports.Output = Output;
        },
        ,
        ,
        ,
        function(module2) {
          function Options(options, merge_child_field) {
            this.raw_options = _mergeOpts(options, merge_child_field);
            this.disabled = this._get_boolean("disabled");
            this.eol = this._get_characters("eol", "auto");
            this.end_with_newline = this._get_boolean("end_with_newline");
            this.indent_size = this._get_number("indent_size", 4);
            this.indent_char = this._get_characters("indent_char", " ");
            this.indent_level = this._get_number("indent_level");
            this.preserve_newlines = this._get_boolean("preserve_newlines", true);
            this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
            if (!this.preserve_newlines) {
              this.max_preserve_newlines = 0;
            }
            this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
            if (this.indent_with_tabs) {
              this.indent_char = "	";
              if (this.indent_size === 1) {
                this.indent_size = 4;
              }
            }
            this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
            this.indent_empty_lines = this._get_boolean("indent_empty_lines");
            this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
          }
          Options.prototype._get_array = function(name, default_value) {
            var option_value = this.raw_options[name];
            var result = default_value || [];
            if (typeof option_value === "object") {
              if (option_value !== null && typeof option_value.concat === "function") {
                result = option_value.concat();
              }
            } else if (typeof option_value === "string") {
              result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
            }
            return result;
          };
          Options.prototype._get_boolean = function(name, default_value) {
            var option_value = this.raw_options[name];
            var result = option_value === void 0 ? !!default_value : !!option_value;
            return result;
          };
          Options.prototype._get_characters = function(name, default_value) {
            var option_value = this.raw_options[name];
            var result = default_value || "";
            if (typeof option_value === "string") {
              result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
            }
            return result;
          };
          Options.prototype._get_number = function(name, default_value) {
            var option_value = this.raw_options[name];
            default_value = parseInt(default_value, 10);
            if (isNaN(default_value)) {
              default_value = 0;
            }
            var result = parseInt(option_value, 10);
            if (isNaN(result)) {
              result = default_value;
            }
            return result;
          };
          Options.prototype._get_selection = function(name, selection_list, default_value) {
            var result = this._get_selection_list(name, selection_list, default_value);
            if (result.length !== 1) {
              throw new Error("Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
            }
            return result[0];
          };
          Options.prototype._get_selection_list = function(name, selection_list, default_value) {
            if (!selection_list || selection_list.length === 0) {
              throw new Error("Selection list cannot be empty.");
            }
            default_value = default_value || [selection_list[0]];
            if (!this._is_valid_selection(default_value, selection_list)) {
              throw new Error("Invalid Default Value!");
            }
            var result = this._get_array(name, default_value);
            if (!this._is_valid_selection(result, selection_list)) {
              throw new Error("Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
            }
            return result;
          };
          Options.prototype._is_valid_selection = function(result, selection_list) {
            return result.length && selection_list.length && !result.some(function(item) {
              return selection_list.indexOf(item) === -1;
            });
          };
          function _mergeOpts(allOptions, childFieldName) {
            var finalOpts = {};
            allOptions = _normalizeOpts(allOptions);
            var name;
            for (name in allOptions) {
              if (name !== childFieldName) {
                finalOpts[name] = allOptions[name];
              }
            }
            if (childFieldName && allOptions[childFieldName]) {
              for (name in allOptions[childFieldName]) {
                finalOpts[name] = allOptions[childFieldName][name];
              }
            }
            return finalOpts;
          }
          function _normalizeOpts(options) {
            var convertedOpts = {};
            var key;
            for (key in options) {
              var newKey = key.replace(/-/g, "_");
              convertedOpts[newKey] = options[key];
            }
            return convertedOpts;
          }
          module2.exports.Options = Options;
          module2.exports.normalizeOpts = _normalizeOpts;
          module2.exports.mergeOpts = _mergeOpts;
        },
        ,
        function(module2) {
          var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
          function InputScanner(input_string) {
            this.__input = input_string || "";
            this.__input_length = this.__input.length;
            this.__position = 0;
          }
          InputScanner.prototype.restart = function() {
            this.__position = 0;
          };
          InputScanner.prototype.back = function() {
            if (this.__position > 0) {
              this.__position -= 1;
            }
          };
          InputScanner.prototype.hasNext = function() {
            return this.__position < this.__input_length;
          };
          InputScanner.prototype.next = function() {
            var val = null;
            if (this.hasNext()) {
              val = this.__input.charAt(this.__position);
              this.__position += 1;
            }
            return val;
          };
          InputScanner.prototype.peek = function(index) {
            var val = null;
            index = index || 0;
            index += this.__position;
            if (index >= 0 && index < this.__input_length) {
              val = this.__input.charAt(index);
            }
            return val;
          };
          InputScanner.prototype.__match = function(pattern, index) {
            pattern.lastIndex = index;
            var pattern_match = pattern.exec(this.__input);
            if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
              if (pattern_match.index !== index) {
                pattern_match = null;
              }
            }
            return pattern_match;
          };
          InputScanner.prototype.test = function(pattern, index) {
            index = index || 0;
            index += this.__position;
            if (index >= 0 && index < this.__input_length) {
              return !!this.__match(pattern, index);
            } else {
              return false;
            }
          };
          InputScanner.prototype.testChar = function(pattern, index) {
            var val = this.peek(index);
            pattern.lastIndex = 0;
            return val !== null && pattern.test(val);
          };
          InputScanner.prototype.match = function(pattern) {
            var pattern_match = this.__match(pattern, this.__position);
            if (pattern_match) {
              this.__position += pattern_match[0].length;
            } else {
              pattern_match = null;
            }
            return pattern_match;
          };
          InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
            var val = "";
            var match;
            if (starting_pattern) {
              match = this.match(starting_pattern);
              if (match) {
                val += match[0];
              }
            }
            if (until_pattern && (match || !starting_pattern)) {
              val += this.readUntil(until_pattern, until_after);
            }
            return val;
          };
          InputScanner.prototype.readUntil = function(pattern, until_after) {
            var val = "";
            var match_index = this.__position;
            pattern.lastIndex = this.__position;
            var pattern_match = pattern.exec(this.__input);
            if (pattern_match) {
              match_index = pattern_match.index;
              if (until_after) {
                match_index += pattern_match[0].length;
              }
            } else {
              match_index = this.__input_length;
            }
            val = this.__input.substring(this.__position, match_index);
            this.__position = match_index;
            return val;
          };
          InputScanner.prototype.readUntilAfter = function(pattern) {
            return this.readUntil(pattern, true);
          };
          InputScanner.prototype.get_regexp = function(pattern, match_from) {
            var result = null;
            var flags = "g";
            if (match_from && regexp_has_sticky) {
              flags = "y";
            }
            if (typeof pattern === "string" && pattern !== "") {
              result = new RegExp(pattern, flags);
            } else if (pattern) {
              result = new RegExp(pattern.source, flags);
            }
            return result;
          };
          InputScanner.prototype.get_literal_regexp = function(literal_string) {
            return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
          };
          InputScanner.prototype.peekUntilAfter = function(pattern) {
            var start = this.__position;
            var val = this.readUntilAfter(pattern);
            this.__position = start;
            return val;
          };
          InputScanner.prototype.lookBack = function(testVal) {
            var start = this.__position - 1;
            return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
          };
          module2.exports.InputScanner = InputScanner;
        },
        ,
        ,
        ,
        ,
        function(module2) {
          function Directives(start_block_pattern, end_block_pattern) {
            start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
            end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
            this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
            this.__directive_pattern = / (\w+)[:](\w+)/g;
            this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
          }
          Directives.prototype.get_directives = function(text) {
            if (!text.match(this.__directives_block_pattern)) {
              return null;
            }
            var directives = {};
            this.__directive_pattern.lastIndex = 0;
            var directive_match = this.__directive_pattern.exec(text);
            while (directive_match) {
              directives[directive_match[1]] = directive_match[2];
              directive_match = this.__directive_pattern.exec(text);
            }
            return directives;
          };
          Directives.prototype.readIgnored = function(input) {
            return input.readUntilAfter(this.__directives_end_ignore_pattern);
          };
          module2.exports.Directives = Directives;
        },
        ,
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var Beautifier = __webpack_require__2(16).Beautifier, Options = __webpack_require__2(17).Options;
          function css_beautify2(source_text, options) {
            var beautifier = new Beautifier(source_text, options);
            return beautifier.beautify();
          }
          module2.exports = css_beautify2;
          module2.exports.defaultOptions = function() {
            return new Options();
          };
        },
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var Options = __webpack_require__2(17).Options;
          var Output = __webpack_require__2(2).Output;
          var InputScanner = __webpack_require__2(8).InputScanner;
          var Directives = __webpack_require__2(13).Directives;
          var directives_core = new Directives(/\/\*/, /\*\//);
          var lineBreak = /\r\n|[\r\n]/;
          var allLineBreaks = /\r\n|[\r\n]/g;
          var whitespaceChar = /\s/;
          var whitespacePattern = /(?:\s|\n)+/g;
          var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
          var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
          function Beautifier(source_text, options) {
            this._source_text = source_text || "";
            this._options = new Options(options);
            this._ch = null;
            this._input = null;
            this.NESTED_AT_RULE = {
              "@page": true,
              "@font-face": true,
              "@keyframes": true,
              "@media": true,
              "@supports": true,
              "@document": true
            };
            this.CONDITIONAL_GROUP_RULE = {
              "@media": true,
              "@supports": true,
              "@document": true
            };
          }
          Beautifier.prototype.eatString = function(endChars) {
            var result = "";
            this._ch = this._input.next();
            while (this._ch) {
              result += this._ch;
              if (this._ch === "\\") {
                result += this._input.next();
              } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
                break;
              }
              this._ch = this._input.next();
            }
            return result;
          };
          Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
            var result = whitespaceChar.test(this._input.peek());
            var newline_count = 0;
            while (whitespaceChar.test(this._input.peek())) {
              this._ch = this._input.next();
              if (allowAtLeastOneNewLine && this._ch === "\n") {
                if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
                  newline_count++;
                  this._output.add_new_line(true);
                }
              }
            }
            return result;
          };
          Beautifier.prototype.foundNestedPseudoClass = function() {
            var openParen = 0;
            var i = 1;
            var ch = this._input.peek(i);
            while (ch) {
              if (ch === "{") {
                return true;
              } else if (ch === "(") {
                openParen += 1;
              } else if (ch === ")") {
                if (openParen === 0) {
                  return false;
                }
                openParen -= 1;
              } else if (ch === ";" || ch === "}") {
                return false;
              }
              i++;
              ch = this._input.peek(i);
            }
            return false;
          };
          Beautifier.prototype.print_string = function(output_string) {
            this._output.set_indent(this._indentLevel);
            this._output.non_breaking_space = true;
            this._output.add_token(output_string);
          };
          Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
            if (isAfterSpace) {
              this._output.space_before_token = true;
            }
          };
          Beautifier.prototype.indent = function() {
            this._indentLevel++;
          };
          Beautifier.prototype.outdent = function() {
            if (this._indentLevel > 0) {
              this._indentLevel--;
            }
          };
          Beautifier.prototype.beautify = function() {
            if (this._options.disabled) {
              return this._source_text;
            }
            var source_text = this._source_text;
            var eol = this._options.eol;
            if (eol === "auto") {
              eol = "\n";
              if (source_text && lineBreak.test(source_text || "")) {
                eol = source_text.match(lineBreak)[0];
              }
            }
            source_text = source_text.replace(allLineBreaks, "\n");
            var baseIndentString = source_text.match(/^[\t ]*/)[0];
            this._output = new Output(this._options, baseIndentString);
            this._input = new InputScanner(source_text);
            this._indentLevel = 0;
            this._nestedLevel = 0;
            this._ch = null;
            var parenLevel = 0;
            var insideRule = false;
            var insidePropertyValue = false;
            var enteringConditionalGroup = false;
            var insideAtExtend = false;
            var insideAtImport = false;
            var topCharacter = this._ch;
            var whitespace;
            var isAfterSpace;
            var previous_ch;
            while (true) {
              whitespace = this._input.read(whitespacePattern);
              isAfterSpace = whitespace !== "";
              previous_ch = topCharacter;
              this._ch = this._input.next();
              if (this._ch === "\\" && this._input.hasNext()) {
                this._ch += this._input.next();
              }
              topCharacter = this._ch;
              if (!this._ch) {
                break;
              } else if (this._ch === "/" && this._input.peek() === "*") {
                this._output.add_new_line();
                this._input.back();
                var comment = this._input.read(block_comment_pattern);
                var directives = directives_core.get_directives(comment);
                if (directives && directives.ignore === "start") {
                  comment += directives_core.readIgnored(this._input);
                }
                this.print_string(comment);
                this.eatWhitespace(true);
                this._output.add_new_line();
              } else if (this._ch === "/" && this._input.peek() === "/") {
                this._output.space_before_token = true;
                this._input.back();
                this.print_string(this._input.read(comment_pattern));
                this.eatWhitespace(true);
              } else if (this._ch === "@") {
                this.preserveSingleSpace(isAfterSpace);
                if (this._input.peek() === "{") {
                  this.print_string(this._ch + this.eatString("}"));
                } else {
                  this.print_string(this._ch);
                  var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
                  if (variableOrRule.match(/[ :]$/)) {
                    variableOrRule = this.eatString(": ").replace(/\s$/, "");
                    this.print_string(variableOrRule);
                    this._output.space_before_token = true;
                  }
                  variableOrRule = variableOrRule.replace(/\s$/, "");
                  if (variableOrRule === "extend") {
                    insideAtExtend = true;
                  } else if (variableOrRule === "import") {
                    insideAtImport = true;
                  }
                  if (variableOrRule in this.NESTED_AT_RULE) {
                    this._nestedLevel += 1;
                    if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
                      enteringConditionalGroup = true;
                    }
                  } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
                    insidePropertyValue = true;
                    this.indent();
                  }
                }
              } else if (this._ch === "#" && this._input.peek() === "{") {
                this.preserveSingleSpace(isAfterSpace);
                this.print_string(this._ch + this.eatString("}"));
              } else if (this._ch === "{") {
                if (insidePropertyValue) {
                  insidePropertyValue = false;
                  this.outdent();
                }
                if (enteringConditionalGroup) {
                  enteringConditionalGroup = false;
                  insideRule = this._indentLevel >= this._nestedLevel;
                } else {
                  insideRule = this._indentLevel >= this._nestedLevel - 1;
                }
                if (this._options.newline_between_rules && insideRule) {
                  if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
                    this._output.ensure_empty_line_above("/", ",");
                  }
                }
                this._output.space_before_token = true;
                if (this._options.brace_style === "expand") {
                  this._output.add_new_line();
                  this.print_string(this._ch);
                  this.indent();
                  this._output.set_indent(this._indentLevel);
                } else {
                  this.indent();
                  this.print_string(this._ch);
                }
                this.eatWhitespace(true);
                this._output.add_new_line();
              } else if (this._ch === "}") {
                this.outdent();
                this._output.add_new_line();
                if (previous_ch === "{") {
                  this._output.trim(true);
                }
                insideAtImport = false;
                insideAtExtend = false;
                if (insidePropertyValue) {
                  this.outdent();
                  insidePropertyValue = false;
                }
                this.print_string(this._ch);
                insideRule = false;
                if (this._nestedLevel) {
                  this._nestedLevel--;
                }
                this.eatWhitespace(true);
                this._output.add_new_line();
                if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
                  if (this._input.peek() !== "}") {
                    this._output.add_new_line(true);
                  }
                }
              } else if (this._ch === ":") {
                if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideAtExtend && parenLevel === 0) {
                  this.print_string(":");
                  if (!insidePropertyValue) {
                    insidePropertyValue = true;
                    this._output.space_before_token = true;
                    this.eatWhitespace(true);
                    this.indent();
                  }
                } else {
                  if (this._input.lookBack(" ")) {
                    this._output.space_before_token = true;
                  }
                  if (this._input.peek() === ":") {
                    this._ch = this._input.next();
                    this.print_string("::");
                  } else {
                    this.print_string(":");
                  }
                }
              } else if (this._ch === '"' || this._ch === "'") {
                this.preserveSingleSpace(isAfterSpace);
                this.print_string(this._ch + this.eatString(this._ch));
                this.eatWhitespace(true);
              } else if (this._ch === ";") {
                if (parenLevel === 0) {
                  if (insidePropertyValue) {
                    this.outdent();
                    insidePropertyValue = false;
                  }
                  insideAtExtend = false;
                  insideAtImport = false;
                  this.print_string(this._ch);
                  this.eatWhitespace(true);
                  if (this._input.peek() !== "/") {
                    this._output.add_new_line();
                  }
                } else {
                  this.print_string(this._ch);
                  this.eatWhitespace(true);
                  this._output.space_before_token = true;
                }
              } else if (this._ch === "(") {
                if (this._input.lookBack("url")) {
                  this.print_string(this._ch);
                  this.eatWhitespace();
                  parenLevel++;
                  this.indent();
                  this._ch = this._input.next();
                  if (this._ch === ")" || this._ch === '"' || this._ch === "'") {
                    this._input.back();
                  } else if (this._ch) {
                    this.print_string(this._ch + this.eatString(")"));
                    if (parenLevel) {
                      parenLevel--;
                      this.outdent();
                    }
                  }
                } else {
                  this.preserveSingleSpace(isAfterSpace);
                  this.print_string(this._ch);
                  this.eatWhitespace();
                  parenLevel++;
                  this.indent();
                }
              } else if (this._ch === ")") {
                if (parenLevel) {
                  parenLevel--;
                  this.outdent();
                }
                this.print_string(this._ch);
              } else if (this._ch === ",") {
                this.print_string(this._ch);
                this.eatWhitespace(true);
                if (this._options.selector_separator_newline && !insidePropertyValue && parenLevel === 0 && !insideAtImport && !insideAtExtend) {
                  this._output.add_new_line();
                } else {
                  this._output.space_before_token = true;
                }
              } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
                if (this._options.space_around_combinator) {
                  this._output.space_before_token = true;
                  this.print_string(this._ch);
                  this._output.space_before_token = true;
                } else {
                  this.print_string(this._ch);
                  this.eatWhitespace();
                  if (this._ch && whitespaceChar.test(this._ch)) {
                    this._ch = "";
                  }
                }
              } else if (this._ch === "]") {
                this.print_string(this._ch);
              } else if (this._ch === "[") {
                this.preserveSingleSpace(isAfterSpace);
                this.print_string(this._ch);
              } else if (this._ch === "=") {
                this.eatWhitespace();
                this.print_string("=");
                if (whitespaceChar.test(this._ch)) {
                  this._ch = "";
                }
              } else if (this._ch === "!" && !this._input.lookBack("\\")) {
                this.print_string(" ");
                this.print_string(this._ch);
              } else {
                this.preserveSingleSpace(isAfterSpace);
                this.print_string(this._ch);
              }
            }
            var sweetCode = this._output.get_code(eol);
            return sweetCode;
          };
          module2.exports.Beautifier = Beautifier;
        },
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var BaseOptions = __webpack_require__2(6).Options;
          function Options(options) {
            BaseOptions.call(this, options, "css");
            this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
            this.newline_between_rules = this._get_boolean("newline_between_rules", true);
            var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
            this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
            var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
            this.brace_style = "collapse";
            for (var bs = 0; bs < brace_style_split.length; bs++) {
              if (brace_style_split[bs] !== "expand") {
                this.brace_style = "collapse";
              } else {
                this.brace_style = brace_style_split[bs];
              }
            }
          }
          Options.prototype = new BaseOptions();
          module2.exports.Options = Options;
        }
      ];
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          exports: {}
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      var __webpack_exports__ = __webpack_require__(15);
      legacy_beautify_css = __webpack_exports__;
    })();
    css_beautify = legacy_beautify_css;
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/beautify/beautify-html.js
function html_beautify(html_source, options) {
  return legacy_beautify_html(html_source, options, js_beautify, css_beautify);
}
var legacy_beautify_html;
var init_beautify_html = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/beautify/beautify-html.js"() {
    init_beautify();
    init_beautify_css();
    (function() {
      "use strict";
      var __webpack_modules__ = [
        ,
        ,
        function(module2) {
          function OutputLine(parent) {
            this.__parent = parent;
            this.__character_count = 0;
            this.__indent_count = -1;
            this.__alignment_count = 0;
            this.__wrap_point_index = 0;
            this.__wrap_point_character_count = 0;
            this.__wrap_point_indent_count = -1;
            this.__wrap_point_alignment_count = 0;
            this.__items = [];
          }
          OutputLine.prototype.clone_empty = function() {
            var line = new OutputLine(this.__parent);
            line.set_indent(this.__indent_count, this.__alignment_count);
            return line;
          };
          OutputLine.prototype.item = function(index) {
            if (index < 0) {
              return this.__items[this.__items.length + index];
            } else {
              return this.__items[index];
            }
          };
          OutputLine.prototype.has_match = function(pattern) {
            for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
              if (this.__items[lastCheckedOutput].match(pattern)) {
                return true;
              }
            }
            return false;
          };
          OutputLine.prototype.set_indent = function(indent, alignment) {
            if (this.is_empty()) {
              this.__indent_count = indent || 0;
              this.__alignment_count = alignment || 0;
              this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
            }
          };
          OutputLine.prototype._set_wrap_point = function() {
            if (this.__parent.wrap_line_length) {
              this.__wrap_point_index = this.__items.length;
              this.__wrap_point_character_count = this.__character_count;
              this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
              this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
            }
          };
          OutputLine.prototype._should_wrap = function() {
            return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
          };
          OutputLine.prototype._allow_wrap = function() {
            if (this._should_wrap()) {
              this.__parent.add_new_line();
              var next = this.__parent.current_line;
              next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
              next.__items = this.__items.slice(this.__wrap_point_index);
              this.__items = this.__items.slice(0, this.__wrap_point_index);
              next.__character_count += this.__character_count - this.__wrap_point_character_count;
              this.__character_count = this.__wrap_point_character_count;
              if (next.__items[0] === " ") {
                next.__items.splice(0, 1);
                next.__character_count -= 1;
              }
              return true;
            }
            return false;
          };
          OutputLine.prototype.is_empty = function() {
            return this.__items.length === 0;
          };
          OutputLine.prototype.last = function() {
            if (!this.is_empty()) {
              return this.__items[this.__items.length - 1];
            } else {
              return null;
            }
          };
          OutputLine.prototype.push = function(item) {
            this.__items.push(item);
            var last_newline_index = item.lastIndexOf("\n");
            if (last_newline_index !== -1) {
              this.__character_count = item.length - last_newline_index;
            } else {
              this.__character_count += item.length;
            }
          };
          OutputLine.prototype.pop = function() {
            var item = null;
            if (!this.is_empty()) {
              item = this.__items.pop();
              this.__character_count -= item.length;
            }
            return item;
          };
          OutputLine.prototype._remove_indent = function() {
            if (this.__indent_count > 0) {
              this.__indent_count -= 1;
              this.__character_count -= this.__parent.indent_size;
            }
          };
          OutputLine.prototype._remove_wrap_indent = function() {
            if (this.__wrap_point_indent_count > 0) {
              this.__wrap_point_indent_count -= 1;
            }
          };
          OutputLine.prototype.trim = function() {
            while (this.last() === " ") {
              this.__items.pop();
              this.__character_count -= 1;
            }
          };
          OutputLine.prototype.toString = function() {
            var result = "";
            if (this.is_empty()) {
              if (this.__parent.indent_empty_lines) {
                result = this.__parent.get_indent_string(this.__indent_count);
              }
            } else {
              result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
              result += this.__items.join("");
            }
            return result;
          };
          function IndentStringCache(options, baseIndentString) {
            this.__cache = [""];
            this.__indent_size = options.indent_size;
            this.__indent_string = options.indent_char;
            if (!options.indent_with_tabs) {
              this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
            }
            baseIndentString = baseIndentString || "";
            if (options.indent_level > 0) {
              baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
            }
            this.__base_string = baseIndentString;
            this.__base_string_length = baseIndentString.length;
          }
          IndentStringCache.prototype.get_indent_size = function(indent, column) {
            var result = this.__base_string_length;
            column = column || 0;
            if (indent < 0) {
              result = 0;
            }
            result += indent * this.__indent_size;
            result += column;
            return result;
          };
          IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
            var result = this.__base_string;
            column = column || 0;
            if (indent_level < 0) {
              indent_level = 0;
              result = "";
            }
            column += indent_level * this.__indent_size;
            this.__ensure_cache(column);
            result += this.__cache[column];
            return result;
          };
          IndentStringCache.prototype.__ensure_cache = function(column) {
            while (column >= this.__cache.length) {
              this.__add_column();
            }
          };
          IndentStringCache.prototype.__add_column = function() {
            var column = this.__cache.length;
            var indent = 0;
            var result = "";
            if (this.__indent_size && column >= this.__indent_size) {
              indent = Math.floor(column / this.__indent_size);
              column -= indent * this.__indent_size;
              result = new Array(indent + 1).join(this.__indent_string);
            }
            if (column) {
              result += new Array(column + 1).join(" ");
            }
            this.__cache.push(result);
          };
          function Output(options, baseIndentString) {
            this.__indent_cache = new IndentStringCache(options, baseIndentString);
            this.raw = false;
            this._end_with_newline = options.end_with_newline;
            this.indent_size = options.indent_size;
            this.wrap_line_length = options.wrap_line_length;
            this.indent_empty_lines = options.indent_empty_lines;
            this.__lines = [];
            this.previous_line = null;
            this.current_line = null;
            this.next_line = new OutputLine(this);
            this.space_before_token = false;
            this.non_breaking_space = false;
            this.previous_token_wrapped = false;
            this.__add_outputline();
          }
          Output.prototype.__add_outputline = function() {
            this.previous_line = this.current_line;
            this.current_line = this.next_line.clone_empty();
            this.__lines.push(this.current_line);
          };
          Output.prototype.get_line_number = function() {
            return this.__lines.length;
          };
          Output.prototype.get_indent_string = function(indent, column) {
            return this.__indent_cache.get_indent_string(indent, column);
          };
          Output.prototype.get_indent_size = function(indent, column) {
            return this.__indent_cache.get_indent_size(indent, column);
          };
          Output.prototype.is_empty = function() {
            return !this.previous_line && this.current_line.is_empty();
          };
          Output.prototype.add_new_line = function(force_newline) {
            if (this.is_empty() || !force_newline && this.just_added_newline()) {
              return false;
            }
            if (!this.raw) {
              this.__add_outputline();
            }
            return true;
          };
          Output.prototype.get_code = function(eol) {
            this.trim(true);
            var last_item = this.current_line.pop();
            if (last_item) {
              if (last_item[last_item.length - 1] === "\n") {
                last_item = last_item.replace(/\n+$/g, "");
              }
              this.current_line.push(last_item);
            }
            if (this._end_with_newline) {
              this.__add_outputline();
            }
            var sweet_code = this.__lines.join("\n");
            if (eol !== "\n") {
              sweet_code = sweet_code.replace(/[\n]/g, eol);
            }
            return sweet_code;
          };
          Output.prototype.set_wrap_point = function() {
            this.current_line._set_wrap_point();
          };
          Output.prototype.set_indent = function(indent, alignment) {
            indent = indent || 0;
            alignment = alignment || 0;
            this.next_line.set_indent(indent, alignment);
            if (this.__lines.length > 1) {
              this.current_line.set_indent(indent, alignment);
              return true;
            }
            this.current_line.set_indent();
            return false;
          };
          Output.prototype.add_raw_token = function(token) {
            for (var x = 0; x < token.newlines; x++) {
              this.__add_outputline();
            }
            this.current_line.set_indent(-1);
            this.current_line.push(token.whitespace_before);
            this.current_line.push(token.text);
            this.space_before_token = false;
            this.non_breaking_space = false;
            this.previous_token_wrapped = false;
          };
          Output.prototype.add_token = function(printable_token) {
            this.__add_space_before_token();
            this.current_line.push(printable_token);
            this.space_before_token = false;
            this.non_breaking_space = false;
            this.previous_token_wrapped = this.current_line._allow_wrap();
          };
          Output.prototype.__add_space_before_token = function() {
            if (this.space_before_token && !this.just_added_newline()) {
              if (!this.non_breaking_space) {
                this.set_wrap_point();
              }
              this.current_line.push(" ");
            }
          };
          Output.prototype.remove_indent = function(index) {
            var output_length = this.__lines.length;
            while (index < output_length) {
              this.__lines[index]._remove_indent();
              index++;
            }
            this.current_line._remove_wrap_indent();
          };
          Output.prototype.trim = function(eat_newlines) {
            eat_newlines = eat_newlines === void 0 ? false : eat_newlines;
            this.current_line.trim();
            while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
              this.__lines.pop();
              this.current_line = this.__lines[this.__lines.length - 1];
              this.current_line.trim();
            }
            this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
          };
          Output.prototype.just_added_newline = function() {
            return this.current_line.is_empty();
          };
          Output.prototype.just_added_blankline = function() {
            return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
          };
          Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
            var index = this.__lines.length - 2;
            while (index >= 0) {
              var potentialEmptyLine = this.__lines[index];
              if (potentialEmptyLine.is_empty()) {
                break;
              } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
                this.__lines.splice(index + 1, 0, new OutputLine(this));
                this.previous_line = this.__lines[this.__lines.length - 2];
                break;
              }
              index--;
            }
          };
          module2.exports.Output = Output;
        },
        function(module2) {
          function Token(type, text, newlines, whitespace_before) {
            this.type = type;
            this.text = text;
            this.comments_before = null;
            this.newlines = newlines || 0;
            this.whitespace_before = whitespace_before || "";
            this.parent = null;
            this.next = null;
            this.previous = null;
            this.opened = null;
            this.closed = null;
            this.directives = null;
          }
          module2.exports.Token = Token;
        },
        ,
        ,
        function(module2) {
          function Options(options, merge_child_field) {
            this.raw_options = _mergeOpts(options, merge_child_field);
            this.disabled = this._get_boolean("disabled");
            this.eol = this._get_characters("eol", "auto");
            this.end_with_newline = this._get_boolean("end_with_newline");
            this.indent_size = this._get_number("indent_size", 4);
            this.indent_char = this._get_characters("indent_char", " ");
            this.indent_level = this._get_number("indent_level");
            this.preserve_newlines = this._get_boolean("preserve_newlines", true);
            this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
            if (!this.preserve_newlines) {
              this.max_preserve_newlines = 0;
            }
            this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
            if (this.indent_with_tabs) {
              this.indent_char = "	";
              if (this.indent_size === 1) {
                this.indent_size = 4;
              }
            }
            this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
            this.indent_empty_lines = this._get_boolean("indent_empty_lines");
            this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
          }
          Options.prototype._get_array = function(name, default_value) {
            var option_value = this.raw_options[name];
            var result = default_value || [];
            if (typeof option_value === "object") {
              if (option_value !== null && typeof option_value.concat === "function") {
                result = option_value.concat();
              }
            } else if (typeof option_value === "string") {
              result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
            }
            return result;
          };
          Options.prototype._get_boolean = function(name, default_value) {
            var option_value = this.raw_options[name];
            var result = option_value === void 0 ? !!default_value : !!option_value;
            return result;
          };
          Options.prototype._get_characters = function(name, default_value) {
            var option_value = this.raw_options[name];
            var result = default_value || "";
            if (typeof option_value === "string") {
              result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
            }
            return result;
          };
          Options.prototype._get_number = function(name, default_value) {
            var option_value = this.raw_options[name];
            default_value = parseInt(default_value, 10);
            if (isNaN(default_value)) {
              default_value = 0;
            }
            var result = parseInt(option_value, 10);
            if (isNaN(result)) {
              result = default_value;
            }
            return result;
          };
          Options.prototype._get_selection = function(name, selection_list, default_value) {
            var result = this._get_selection_list(name, selection_list, default_value);
            if (result.length !== 1) {
              throw new Error("Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
            }
            return result[0];
          };
          Options.prototype._get_selection_list = function(name, selection_list, default_value) {
            if (!selection_list || selection_list.length === 0) {
              throw new Error("Selection list cannot be empty.");
            }
            default_value = default_value || [selection_list[0]];
            if (!this._is_valid_selection(default_value, selection_list)) {
              throw new Error("Invalid Default Value!");
            }
            var result = this._get_array(name, default_value);
            if (!this._is_valid_selection(result, selection_list)) {
              throw new Error("Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
            }
            return result;
          };
          Options.prototype._is_valid_selection = function(result, selection_list) {
            return result.length && selection_list.length && !result.some(function(item) {
              return selection_list.indexOf(item) === -1;
            });
          };
          function _mergeOpts(allOptions, childFieldName) {
            var finalOpts = {};
            allOptions = _normalizeOpts(allOptions);
            var name;
            for (name in allOptions) {
              if (name !== childFieldName) {
                finalOpts[name] = allOptions[name];
              }
            }
            if (childFieldName && allOptions[childFieldName]) {
              for (name in allOptions[childFieldName]) {
                finalOpts[name] = allOptions[childFieldName][name];
              }
            }
            return finalOpts;
          }
          function _normalizeOpts(options) {
            var convertedOpts = {};
            var key;
            for (key in options) {
              var newKey = key.replace(/-/g, "_");
              convertedOpts[newKey] = options[key];
            }
            return convertedOpts;
          }
          module2.exports.Options = Options;
          module2.exports.normalizeOpts = _normalizeOpts;
          module2.exports.mergeOpts = _mergeOpts;
        },
        ,
        function(module2) {
          var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
          function InputScanner(input_string) {
            this.__input = input_string || "";
            this.__input_length = this.__input.length;
            this.__position = 0;
          }
          InputScanner.prototype.restart = function() {
            this.__position = 0;
          };
          InputScanner.prototype.back = function() {
            if (this.__position > 0) {
              this.__position -= 1;
            }
          };
          InputScanner.prototype.hasNext = function() {
            return this.__position < this.__input_length;
          };
          InputScanner.prototype.next = function() {
            var val = null;
            if (this.hasNext()) {
              val = this.__input.charAt(this.__position);
              this.__position += 1;
            }
            return val;
          };
          InputScanner.prototype.peek = function(index) {
            var val = null;
            index = index || 0;
            index += this.__position;
            if (index >= 0 && index < this.__input_length) {
              val = this.__input.charAt(index);
            }
            return val;
          };
          InputScanner.prototype.__match = function(pattern, index) {
            pattern.lastIndex = index;
            var pattern_match = pattern.exec(this.__input);
            if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
              if (pattern_match.index !== index) {
                pattern_match = null;
              }
            }
            return pattern_match;
          };
          InputScanner.prototype.test = function(pattern, index) {
            index = index || 0;
            index += this.__position;
            if (index >= 0 && index < this.__input_length) {
              return !!this.__match(pattern, index);
            } else {
              return false;
            }
          };
          InputScanner.prototype.testChar = function(pattern, index) {
            var val = this.peek(index);
            pattern.lastIndex = 0;
            return val !== null && pattern.test(val);
          };
          InputScanner.prototype.match = function(pattern) {
            var pattern_match = this.__match(pattern, this.__position);
            if (pattern_match) {
              this.__position += pattern_match[0].length;
            } else {
              pattern_match = null;
            }
            return pattern_match;
          };
          InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
            var val = "";
            var match;
            if (starting_pattern) {
              match = this.match(starting_pattern);
              if (match) {
                val += match[0];
              }
            }
            if (until_pattern && (match || !starting_pattern)) {
              val += this.readUntil(until_pattern, until_after);
            }
            return val;
          };
          InputScanner.prototype.readUntil = function(pattern, until_after) {
            var val = "";
            var match_index = this.__position;
            pattern.lastIndex = this.__position;
            var pattern_match = pattern.exec(this.__input);
            if (pattern_match) {
              match_index = pattern_match.index;
              if (until_after) {
                match_index += pattern_match[0].length;
              }
            } else {
              match_index = this.__input_length;
            }
            val = this.__input.substring(this.__position, match_index);
            this.__position = match_index;
            return val;
          };
          InputScanner.prototype.readUntilAfter = function(pattern) {
            return this.readUntil(pattern, true);
          };
          InputScanner.prototype.get_regexp = function(pattern, match_from) {
            var result = null;
            var flags = "g";
            if (match_from && regexp_has_sticky) {
              flags = "y";
            }
            if (typeof pattern === "string" && pattern !== "") {
              result = new RegExp(pattern, flags);
            } else if (pattern) {
              result = new RegExp(pattern.source, flags);
            }
            return result;
          };
          InputScanner.prototype.get_literal_regexp = function(literal_string) {
            return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
          };
          InputScanner.prototype.peekUntilAfter = function(pattern) {
            var start = this.__position;
            var val = this.readUntilAfter(pattern);
            this.__position = start;
            return val;
          };
          InputScanner.prototype.lookBack = function(testVal) {
            var start = this.__position - 1;
            return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
          };
          module2.exports.InputScanner = InputScanner;
        },
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var InputScanner = __webpack_require__2(8).InputScanner;
          var Token = __webpack_require__2(3).Token;
          var TokenStream = __webpack_require__2(10).TokenStream;
          var WhitespacePattern = __webpack_require__2(11).WhitespacePattern;
          var TOKEN = {
            START: "TK_START",
            RAW: "TK_RAW",
            EOF: "TK_EOF"
          };
          var Tokenizer = function(input_string, options) {
            this._input = new InputScanner(input_string);
            this._options = options || {};
            this.__tokens = null;
            this._patterns = {};
            this._patterns.whitespace = new WhitespacePattern(this._input);
          };
          Tokenizer.prototype.tokenize = function() {
            this._input.restart();
            this.__tokens = new TokenStream();
            this._reset();
            var current;
            var previous = new Token(TOKEN.START, "");
            var open_token = null;
            var open_stack = [];
            var comments = new TokenStream();
            while (previous.type !== TOKEN.EOF) {
              current = this._get_next_token(previous, open_token);
              while (this._is_comment(current)) {
                comments.add(current);
                current = this._get_next_token(previous, open_token);
              }
              if (!comments.isEmpty()) {
                current.comments_before = comments;
                comments = new TokenStream();
              }
              current.parent = open_token;
              if (this._is_opening(current)) {
                open_stack.push(open_token);
                open_token = current;
              } else if (open_token && this._is_closing(current, open_token)) {
                current.opened = open_token;
                open_token.closed = current;
                open_token = open_stack.pop();
                current.parent = open_token;
              }
              current.previous = previous;
              previous.next = current;
              this.__tokens.add(current);
              previous = current;
            }
            return this.__tokens;
          };
          Tokenizer.prototype._is_first_token = function() {
            return this.__tokens.isEmpty();
          };
          Tokenizer.prototype._reset = function() {
          };
          Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
            this._readWhitespace();
            var resulting_string = this._input.read(/.+/g);
            if (resulting_string) {
              return this._create_token(TOKEN.RAW, resulting_string);
            } else {
              return this._create_token(TOKEN.EOF, "");
            }
          };
          Tokenizer.prototype._is_comment = function(current_token) {
            return false;
          };
          Tokenizer.prototype._is_opening = function(current_token) {
            return false;
          };
          Tokenizer.prototype._is_closing = function(current_token, open_token) {
            return false;
          };
          Tokenizer.prototype._create_token = function(type, text) {
            var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
            return token;
          };
          Tokenizer.prototype._readWhitespace = function() {
            return this._patterns.whitespace.read();
          };
          module2.exports.Tokenizer = Tokenizer;
          module2.exports.TOKEN = TOKEN;
        },
        function(module2) {
          function TokenStream(parent_token) {
            this.__tokens = [];
            this.__tokens_length = this.__tokens.length;
            this.__position = 0;
            this.__parent_token = parent_token;
          }
          TokenStream.prototype.restart = function() {
            this.__position = 0;
          };
          TokenStream.prototype.isEmpty = function() {
            return this.__tokens_length === 0;
          };
          TokenStream.prototype.hasNext = function() {
            return this.__position < this.__tokens_length;
          };
          TokenStream.prototype.next = function() {
            var val = null;
            if (this.hasNext()) {
              val = this.__tokens[this.__position];
              this.__position += 1;
            }
            return val;
          };
          TokenStream.prototype.peek = function(index) {
            var val = null;
            index = index || 0;
            index += this.__position;
            if (index >= 0 && index < this.__tokens_length) {
              val = this.__tokens[index];
            }
            return val;
          };
          TokenStream.prototype.add = function(token) {
            if (this.__parent_token) {
              token.parent = this.__parent_token;
            }
            this.__tokens.push(token);
            this.__tokens_length += 1;
          };
          module2.exports.TokenStream = TokenStream;
        },
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var Pattern = __webpack_require__2(12).Pattern;
          function WhitespacePattern(input_scanner, parent) {
            Pattern.call(this, input_scanner, parent);
            if (parent) {
              this._line_regexp = this._input.get_regexp(parent._line_regexp);
            } else {
              this.__set_whitespace_patterns("", "");
            }
            this.newline_count = 0;
            this.whitespace_before_token = "";
          }
          WhitespacePattern.prototype = new Pattern();
          WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
            whitespace_chars += "\\t ";
            newline_chars += "\\n\\r";
            this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
            this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
          };
          WhitespacePattern.prototype.read = function() {
            this.newline_count = 0;
            this.whitespace_before_token = "";
            var resulting_string = this._input.read(this._match_pattern);
            if (resulting_string === " ") {
              this.whitespace_before_token = " ";
            } else if (resulting_string) {
              var matches = this.__split(this._newline_regexp, resulting_string);
              this.newline_count = matches.length - 1;
              this.whitespace_before_token = matches[this.newline_count];
            }
            return resulting_string;
          };
          WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
            var result = this._create();
            result.__set_whitespace_patterns(whitespace_chars, newline_chars);
            result._update();
            return result;
          };
          WhitespacePattern.prototype._create = function() {
            return new WhitespacePattern(this._input, this);
          };
          WhitespacePattern.prototype.__split = function(regexp, input_string) {
            regexp.lastIndex = 0;
            var start_index = 0;
            var result = [];
            var next_match = regexp.exec(input_string);
            while (next_match) {
              result.push(input_string.substring(start_index, next_match.index));
              start_index = next_match.index + next_match[0].length;
              next_match = regexp.exec(input_string);
            }
            if (start_index < input_string.length) {
              result.push(input_string.substring(start_index, input_string.length));
            } else {
              result.push("");
            }
            return result;
          };
          module2.exports.WhitespacePattern = WhitespacePattern;
        },
        function(module2) {
          function Pattern(input_scanner, parent) {
            this._input = input_scanner;
            this._starting_pattern = null;
            this._match_pattern = null;
            this._until_pattern = null;
            this._until_after = false;
            if (parent) {
              this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
              this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
              this._until_pattern = this._input.get_regexp(parent._until_pattern);
              this._until_after = parent._until_after;
            }
          }
          Pattern.prototype.read = function() {
            var result = this._input.read(this._starting_pattern);
            if (!this._starting_pattern || result) {
              result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
            }
            return result;
          };
          Pattern.prototype.read_match = function() {
            return this._input.match(this._match_pattern);
          };
          Pattern.prototype.until_after = function(pattern) {
            var result = this._create();
            result._until_after = true;
            result._until_pattern = this._input.get_regexp(pattern);
            result._update();
            return result;
          };
          Pattern.prototype.until = function(pattern) {
            var result = this._create();
            result._until_after = false;
            result._until_pattern = this._input.get_regexp(pattern);
            result._update();
            return result;
          };
          Pattern.prototype.starting_with = function(pattern) {
            var result = this._create();
            result._starting_pattern = this._input.get_regexp(pattern, true);
            result._update();
            return result;
          };
          Pattern.prototype.matching = function(pattern) {
            var result = this._create();
            result._match_pattern = this._input.get_regexp(pattern, true);
            result._update();
            return result;
          };
          Pattern.prototype._create = function() {
            return new Pattern(this._input, this);
          };
          Pattern.prototype._update = function() {
          };
          module2.exports.Pattern = Pattern;
        },
        function(module2) {
          function Directives(start_block_pattern, end_block_pattern) {
            start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
            end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
            this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
            this.__directive_pattern = / (\w+)[:](\w+)/g;
            this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
          }
          Directives.prototype.get_directives = function(text) {
            if (!text.match(this.__directives_block_pattern)) {
              return null;
            }
            var directives = {};
            this.__directive_pattern.lastIndex = 0;
            var directive_match = this.__directive_pattern.exec(text);
            while (directive_match) {
              directives[directive_match[1]] = directive_match[2];
              directive_match = this.__directive_pattern.exec(text);
            }
            return directives;
          };
          Directives.prototype.readIgnored = function(input) {
            return input.readUntilAfter(this.__directives_end_ignore_pattern);
          };
          module2.exports.Directives = Directives;
        },
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var Pattern = __webpack_require__2(12).Pattern;
          var template_names = {
            django: false,
            erb: false,
            handlebars: false,
            php: false,
            smarty: false
          };
          function TemplatablePattern(input_scanner, parent) {
            Pattern.call(this, input_scanner, parent);
            this.__template_pattern = null;
            this._disabled = Object.assign({}, template_names);
            this._excluded = Object.assign({}, template_names);
            if (parent) {
              this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
              this._excluded = Object.assign(this._excluded, parent._excluded);
              this._disabled = Object.assign(this._disabled, parent._disabled);
            }
            var pattern = new Pattern(input_scanner);
            this.__patterns = {
              handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
              handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
              handlebars: pattern.starting_with(/{{/).until_after(/}}/),
              php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
              erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
              django: pattern.starting_with(/{%/).until_after(/%}/),
              django_value: pattern.starting_with(/{{/).until_after(/}}/),
              django_comment: pattern.starting_with(/{#/).until_after(/#}/),
              smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
              smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
              smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
            };
          }
          TemplatablePattern.prototype = new Pattern();
          TemplatablePattern.prototype._create = function() {
            return new TemplatablePattern(this._input, this);
          };
          TemplatablePattern.prototype._update = function() {
            this.__set_templated_pattern();
          };
          TemplatablePattern.prototype.disable = function(language) {
            var result = this._create();
            result._disabled[language] = true;
            result._update();
            return result;
          };
          TemplatablePattern.prototype.read_options = function(options) {
            var result = this._create();
            for (var language in template_names) {
              result._disabled[language] = options.templating.indexOf(language) === -1;
            }
            result._update();
            return result;
          };
          TemplatablePattern.prototype.exclude = function(language) {
            var result = this._create();
            result._excluded[language] = true;
            result._update();
            return result;
          };
          TemplatablePattern.prototype.read = function() {
            var result = "";
            if (this._match_pattern) {
              result = this._input.read(this._starting_pattern);
            } else {
              result = this._input.read(this._starting_pattern, this.__template_pattern);
            }
            var next = this._read_template();
            while (next) {
              if (this._match_pattern) {
                next += this._input.read(this._match_pattern);
              } else {
                next += this._input.readUntil(this.__template_pattern);
              }
              result += next;
              next = this._read_template();
            }
            if (this._until_after) {
              result += this._input.readUntilAfter(this._until_pattern);
            }
            return result;
          };
          TemplatablePattern.prototype.__set_templated_pattern = function() {
            var items = [];
            if (!this._disabled.php) {
              items.push(this.__patterns.php._starting_pattern.source);
            }
            if (!this._disabled.handlebars) {
              items.push(this.__patterns.handlebars._starting_pattern.source);
            }
            if (!this._disabled.erb) {
              items.push(this.__patterns.erb._starting_pattern.source);
            }
            if (!this._disabled.django) {
              items.push(this.__patterns.django._starting_pattern.source);
              items.push(this.__patterns.django_value._starting_pattern.source);
              items.push(this.__patterns.django_comment._starting_pattern.source);
            }
            if (!this._disabled.smarty) {
              items.push(this.__patterns.smarty._starting_pattern.source);
            }
            if (this._until_pattern) {
              items.push(this._until_pattern.source);
            }
            this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
          };
          TemplatablePattern.prototype._read_template = function() {
            var resulting_string = "";
            var c = this._input.peek();
            if (c === "<") {
              var peek1 = this._input.peek(1);
              if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
                resulting_string = resulting_string || this.__patterns.php.read();
              }
              if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
                resulting_string = resulting_string || this.__patterns.erb.read();
              }
            } else if (c === "{") {
              if (!this._disabled.handlebars && !this._excluded.handlebars) {
                resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
                resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
                resulting_string = resulting_string || this.__patterns.handlebars.read();
              }
              if (!this._disabled.django) {
                if (!this._excluded.django && !this._excluded.handlebars) {
                  resulting_string = resulting_string || this.__patterns.django_value.read();
                }
                if (!this._excluded.django) {
                  resulting_string = resulting_string || this.__patterns.django_comment.read();
                  resulting_string = resulting_string || this.__patterns.django.read();
                }
              }
              if (!this._disabled.smarty) {
                if (this._disabled.django && this._disabled.handlebars) {
                  resulting_string = resulting_string || this.__patterns.smarty_comment.read();
                  resulting_string = resulting_string || this.__patterns.smarty_literal.read();
                  resulting_string = resulting_string || this.__patterns.smarty.read();
                }
              }
            }
            return resulting_string;
          };
          module2.exports.TemplatablePattern = TemplatablePattern;
        },
        ,
        ,
        ,
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var Beautifier = __webpack_require__2(19).Beautifier, Options = __webpack_require__2(20).Options;
          function style_html(html_source, options, js_beautify2, css_beautify2) {
            var beautifier = new Beautifier(html_source, options, js_beautify2, css_beautify2);
            return beautifier.beautify();
          }
          module2.exports = style_html;
          module2.exports.defaultOptions = function() {
            return new Options();
          };
        },
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var Options = __webpack_require__2(20).Options;
          var Output = __webpack_require__2(2).Output;
          var Tokenizer = __webpack_require__2(21).Tokenizer;
          var TOKEN = __webpack_require__2(21).TOKEN;
          var lineBreak = /\r\n|[\r\n]/;
          var allLineBreaks = /\r\n|[\r\n]/g;
          var Printer = function(options, base_indent_string) {
            this.indent_level = 0;
            this.alignment_size = 0;
            this.max_preserve_newlines = options.max_preserve_newlines;
            this.preserve_newlines = options.preserve_newlines;
            this._output = new Output(options, base_indent_string);
          };
          Printer.prototype.current_line_has_match = function(pattern) {
            return this._output.current_line.has_match(pattern);
          };
          Printer.prototype.set_space_before_token = function(value, non_breaking) {
            this._output.space_before_token = value;
            this._output.non_breaking_space = non_breaking;
          };
          Printer.prototype.set_wrap_point = function() {
            this._output.set_indent(this.indent_level, this.alignment_size);
            this._output.set_wrap_point();
          };
          Printer.prototype.add_raw_token = function(token) {
            this._output.add_raw_token(token);
          };
          Printer.prototype.print_preserved_newlines = function(raw_token) {
            var newlines = 0;
            if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
              newlines = raw_token.newlines ? 1 : 0;
            }
            if (this.preserve_newlines) {
              newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
            }
            for (var n = 0; n < newlines; n++) {
              this.print_newline(n > 0);
            }
            return newlines !== 0;
          };
          Printer.prototype.traverse_whitespace = function(raw_token) {
            if (raw_token.whitespace_before || raw_token.newlines) {
              if (!this.print_preserved_newlines(raw_token)) {
                this._output.space_before_token = true;
              }
              return true;
            }
            return false;
          };
          Printer.prototype.previous_token_wrapped = function() {
            return this._output.previous_token_wrapped;
          };
          Printer.prototype.print_newline = function(force) {
            this._output.add_new_line(force);
          };
          Printer.prototype.print_token = function(token) {
            if (token.text) {
              this._output.set_indent(this.indent_level, this.alignment_size);
              this._output.add_token(token.text);
            }
          };
          Printer.prototype.indent = function() {
            this.indent_level++;
          };
          Printer.prototype.get_full_indent = function(level) {
            level = this.indent_level + (level || 0);
            if (level < 1) {
              return "";
            }
            return this._output.get_indent_string(level);
          };
          var get_type_attribute = function(start_token) {
            var result = null;
            var raw_token = start_token.next;
            while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
              if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
                if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
                  result = raw_token.next.next.text;
                }
                break;
              }
              raw_token = raw_token.next;
            }
            return result;
          };
          var get_custom_beautifier_name = function(tag_check, raw_token) {
            var typeAttribute = null;
            var result = null;
            if (!raw_token.closed) {
              return null;
            }
            if (tag_check === "script") {
              typeAttribute = "text/javascript";
            } else if (tag_check === "style") {
              typeAttribute = "text/css";
            }
            typeAttribute = get_type_attribute(raw_token) || typeAttribute;
            if (typeAttribute.search("text/css") > -1) {
              result = "css";
            } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
              result = "javascript";
            } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
              result = "html";
            } else if (typeAttribute.search(/test\/null/) > -1) {
              result = "null";
            }
            return result;
          };
          function in_array(what, arr) {
            return arr.indexOf(what) !== -1;
          }
          function TagFrame(parent, parser_token, indent_level) {
            this.parent = parent || null;
            this.tag = parser_token ? parser_token.tag_name : "";
            this.indent_level = indent_level || 0;
            this.parser_token = parser_token || null;
          }
          function TagStack(printer) {
            this._printer = printer;
            this._current_frame = null;
          }
          TagStack.prototype.get_parser_token = function() {
            return this._current_frame ? this._current_frame.parser_token : null;
          };
          TagStack.prototype.record_tag = function(parser_token) {
            var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
            this._current_frame = new_frame;
          };
          TagStack.prototype._try_pop_frame = function(frame) {
            var parser_token = null;
            if (frame) {
              parser_token = frame.parser_token;
              this._printer.indent_level = frame.indent_level;
              this._current_frame = frame.parent;
            }
            return parser_token;
          };
          TagStack.prototype._get_frame = function(tag_list, stop_list) {
            var frame = this._current_frame;
            while (frame) {
              if (tag_list.indexOf(frame.tag) !== -1) {
                break;
              } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
                frame = null;
                break;
              }
              frame = frame.parent;
            }
            return frame;
          };
          TagStack.prototype.try_pop = function(tag, stop_list) {
            var frame = this._get_frame([tag], stop_list);
            return this._try_pop_frame(frame);
          };
          TagStack.prototype.indent_to_tag = function(tag_list) {
            var frame = this._get_frame(tag_list);
            if (frame) {
              this._printer.indent_level = frame.indent_level;
            }
          };
          function Beautifier(source_text, options, js_beautify2, css_beautify2) {
            this._source_text = source_text || "";
            options = options || {};
            this._js_beautify = js_beautify2;
            this._css_beautify = css_beautify2;
            this._tag_stack = null;
            var optionHtml = new Options(options, "html");
            this._options = optionHtml;
            this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
            this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
            this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
            this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
            this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
            this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
          }
          Beautifier.prototype.beautify = function() {
            if (this._options.disabled) {
              return this._source_text;
            }
            var source_text = this._source_text;
            var eol = this._options.eol;
            if (this._options.eol === "auto") {
              eol = "\n";
              if (source_text && lineBreak.test(source_text)) {
                eol = source_text.match(lineBreak)[0];
              }
            }
            source_text = source_text.replace(allLineBreaks, "\n");
            var baseIndentString = source_text.match(/^[\t ]*/)[0];
            var last_token = {
              text: "",
              type: ""
            };
            var last_tag_token = new TagOpenParserToken();
            var printer = new Printer(this._options, baseIndentString);
            var tokens = new Tokenizer(source_text, this._options).tokenize();
            this._tag_stack = new TagStack(printer);
            var parser_token = null;
            var raw_token = tokens.next();
            while (raw_token.type !== TOKEN.EOF) {
              if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
                parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);
                last_tag_token = parser_token;
              } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
                parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);
              } else if (raw_token.type === TOKEN.TAG_CLOSE) {
                parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
              } else if (raw_token.type === TOKEN.TEXT) {
                parser_token = this._handle_text(printer, raw_token, last_tag_token);
              } else {
                printer.add_raw_token(raw_token);
              }
              last_token = parser_token;
              raw_token = tokens.next();
            }
            var sweet_code = printer._output.get_code(eol);
            return sweet_code;
          };
          Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
            var parser_token = {
              text: raw_token.text,
              type: raw_token.type
            };
            printer.alignment_size = 0;
            last_tag_token.tag_complete = true;
            printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
            if (last_tag_token.is_unformatted) {
              printer.add_raw_token(raw_token);
            } else {
              if (last_tag_token.tag_start_char === "<") {
                printer.set_space_before_token(raw_token.text[0] === "/", true);
                if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
                  printer.print_newline(false);
                }
              }
              printer.print_token(raw_token);
            }
            if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
              printer.indent();
              last_tag_token.indent_content = false;
            }
            if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
              printer.set_wrap_point();
            }
            return parser_token;
          };
          Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {
            var wrapped = last_tag_token.has_wrapped_attrs;
            var parser_token = {
              text: raw_token.text,
              type: raw_token.type
            };
            printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
            if (last_tag_token.is_unformatted) {
              printer.add_raw_token(raw_token);
            } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
              if (printer.print_preserved_newlines(raw_token)) {
                raw_token.newlines = 0;
                printer.add_raw_token(raw_token);
              } else {
                printer.print_token(raw_token);
              }
            } else {
              if (raw_token.type === TOKEN.ATTRIBUTE) {
                printer.set_space_before_token(true);
                last_tag_token.attr_count += 1;
              } else if (raw_token.type === TOKEN.EQUALS) {
                printer.set_space_before_token(false);
              } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
                printer.set_space_before_token(false);
              }
              if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
                if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
                  printer.traverse_whitespace(raw_token);
                  wrapped = wrapped || raw_token.newlines !== 0;
                }
                if (this._is_wrap_attributes_force) {
                  var force_attr_wrap = last_tag_token.attr_count > 1;
                  if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {
                    var is_only_attribute = true;
                    var peek_index = 0;
                    var peek_token;
                    do {
                      peek_token = tokens.peek(peek_index);
                      if (peek_token.type === TOKEN.ATTRIBUTE) {
                        is_only_attribute = false;
                        break;
                      }
                      peek_index += 1;
                    } while (peek_index < 4 && peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
                    force_attr_wrap = !is_only_attribute;
                  }
                  if (force_attr_wrap) {
                    printer.print_newline(false);
                    wrapped = true;
                  }
                }
              }
              printer.print_token(raw_token);
              wrapped = wrapped || printer.previous_token_wrapped();
              last_tag_token.has_wrapped_attrs = wrapped;
            }
            return parser_token;
          };
          Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
            var parser_token = {
              text: raw_token.text,
              type: "TK_CONTENT"
            };
            if (last_tag_token.custom_beautifier_name) {
              this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
            } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
              printer.add_raw_token(raw_token);
            } else {
              printer.traverse_whitespace(raw_token);
              printer.print_token(raw_token);
            }
            return parser_token;
          };
          Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
            var local = this;
            if (raw_token.text !== "") {
              var text = raw_token.text, _beautifier, script_indent_level = 1, pre = "", post = "";
              if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
                _beautifier = this._js_beautify;
              } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
                _beautifier = this._css_beautify;
              } else if (last_tag_token.custom_beautifier_name === "html") {
                _beautifier = function(html_source, options) {
                  var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
                  return beautifier.beautify();
                };
              }
              if (this._options.indent_scripts === "keep") {
                script_indent_level = 0;
              } else if (this._options.indent_scripts === "separate") {
                script_indent_level = -printer.indent_level;
              }
              var indentation = printer.get_full_indent(script_indent_level);
              text = text.replace(/\n[ \t]*$/, "");
              if (last_tag_token.custom_beautifier_name !== "html" && text[0] === "<" && text.match(/^(<!--|<!\[CDATA\[)/)) {
                var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);
                if (!matched) {
                  printer.add_raw_token(raw_token);
                  return;
                }
                pre = indentation + matched[1] + "\n";
                text = matched[4];
                if (matched[5]) {
                  post = indentation + matched[5];
                }
                text = text.replace(/\n[ \t]*$/, "");
                if (matched[2] || matched[3].indexOf("\n") !== -1) {
                  matched = matched[3].match(/[ \t]+$/);
                  if (matched) {
                    raw_token.whitespace_before = matched[0];
                  }
                }
              }
              if (text) {
                if (_beautifier) {
                  var Child_options = function() {
                    this.eol = "\n";
                  };
                  Child_options.prototype = this._options.raw_options;
                  var child_options = new Child_options();
                  text = _beautifier(indentation + text, child_options);
                } else {
                  var white = raw_token.whitespace_before;
                  if (white) {
                    text = text.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
                  }
                  text = indentation + text.replace(/\n/g, "\n" + indentation);
                }
              }
              if (pre) {
                if (!text) {
                  text = pre + post;
                } else {
                  text = pre + text + "\n" + post;
                }
              }
              printer.print_newline(false);
              if (text) {
                raw_token.text = text;
                raw_token.whitespace_before = "";
                raw_token.newlines = 0;
                printer.add_raw_token(raw_token);
                printer.print_newline(true);
              }
            }
          };
          Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {
            var parser_token = this._get_tag_open_token(raw_token);
            if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && raw_token.text.indexOf("</") === 0) {
              printer.add_raw_token(raw_token);
              parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
            } else {
              printer.traverse_whitespace(raw_token);
              this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
              if (!parser_token.is_inline_element) {
                printer.set_wrap_point();
              }
              printer.print_token(raw_token);
            }
            if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
              parser_token.alignment_size = raw_token.text.length + 1;
            }
            if (!parser_token.tag_complete && !parser_token.is_unformatted) {
              printer.alignment_size = parser_token.alignment_size;
            }
            return parser_token;
          };
          var TagOpenParserToken = function(parent, raw_token) {
            this.parent = parent || null;
            this.text = "";
            this.type = "TK_TAG_OPEN";
            this.tag_name = "";
            this.is_inline_element = false;
            this.is_unformatted = false;
            this.is_content_unformatted = false;
            this.is_empty_element = false;
            this.is_start_tag = false;
            this.is_end_tag = false;
            this.indent_content = false;
            this.multiline_content = false;
            this.custom_beautifier_name = null;
            this.start_tag_token = null;
            this.attr_count = 0;
            this.has_wrapped_attrs = false;
            this.alignment_size = 0;
            this.tag_complete = false;
            this.tag_start_char = "";
            this.tag_check = "";
            if (!raw_token) {
              this.tag_complete = true;
            } else {
              var tag_check_match;
              this.tag_start_char = raw_token.text[0];
              this.text = raw_token.text;
              if (this.tag_start_char === "<") {
                tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
                this.tag_check = tag_check_match ? tag_check_match[1] : "";
              } else {
                tag_check_match = raw_token.text.match(/^{{(?:[\^]|#\*?)?([^\s}]+)/);
                this.tag_check = tag_check_match ? tag_check_match[1] : "";
                if (raw_token.text === "{{#>" && this.tag_check === ">" && raw_token.next !== null) {
                  this.tag_check = raw_token.next.text;
                }
              }
              this.tag_check = this.tag_check.toLowerCase();
              if (raw_token.type === TOKEN.COMMENT) {
                this.tag_complete = true;
              }
              this.is_start_tag = this.tag_check.charAt(0) !== "/";
              this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
              this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
              this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(2)));
            }
          };
          Beautifier.prototype._get_tag_open_token = function(raw_token) {
            var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
            parser_token.alignment_size = this._options.wrap_attributes_indent_size;
            parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
            parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
            parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
            parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
            parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || parser_token.tag_start_char === "{";
            return parser_token;
          };
          Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
            if (!parser_token.is_empty_element) {
              if (parser_token.is_end_tag) {
                parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
              } else {
                if (this._do_optional_end_element(parser_token)) {
                  if (!parser_token.is_inline_element) {
                    printer.print_newline(false);
                  }
                }
                this._tag_stack.record_tag(parser_token);
                if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
                  parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
                }
              }
            }
            if (in_array(parser_token.tag_check, this._options.extra_liners)) {
              printer.print_newline(false);
              if (!printer._output.just_added_blankline()) {
                printer.print_newline(true);
              }
            }
            if (parser_token.is_empty_element) {
              if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
                this._tag_stack.indent_to_tag(["if", "unless", "each"]);
                parser_token.indent_content = true;
                var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
                if (!foundIfOnCurrentLine) {
                  printer.print_newline(false);
                }
              }
              if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1) {
              } else {
                if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
                  printer.print_newline(false);
                }
                this._calcluate_parent_multiline(printer, parser_token);
              }
            } else if (parser_token.is_end_tag) {
              var do_end_expand = false;
              do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
              do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
              if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
                do_end_expand = false;
              }
              if (do_end_expand) {
                printer.print_newline(false);
              }
            } else {
              parser_token.indent_content = !parser_token.custom_beautifier_name;
              if (parser_token.tag_start_char === "<") {
                if (parser_token.tag_name === "html") {
                  parser_token.indent_content = this._options.indent_inner_html;
                } else if (parser_token.tag_name === "head") {
                  parser_token.indent_content = this._options.indent_head_inner_html;
                } else if (parser_token.tag_name === "body") {
                  parser_token.indent_content = this._options.indent_body_inner_html;
                }
              }
              if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
                printer.print_newline(false);
              }
              this._calcluate_parent_multiline(printer, parser_token);
            }
          };
          Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
            if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
              parser_token.parent.multiline_content = true;
            }
          };
          var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"];
          var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
          Beautifier.prototype._do_optional_end_element = function(parser_token) {
            var result = null;
            if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
              return;
            }
            if (parser_token.tag_name === "body") {
              result = result || this._tag_stack.try_pop("head");
            } else if (parser_token.tag_name === "li") {
              result = result || this._tag_stack.try_pop("li", ["ol", "ul"]);
            } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
              result = result || this._tag_stack.try_pop("dt", ["dl"]);
              result = result || this._tag_stack.try_pop("dd", ["dl"]);
            } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
              var p_parent = parser_token.parent.parent;
              if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
                result = result || this._tag_stack.try_pop("p");
              }
            } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
              result = result || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
              result = result || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
            } else if (parser_token.tag_name === "optgroup") {
              result = result || this._tag_stack.try_pop("optgroup", ["select"]);
            } else if (parser_token.tag_name === "option") {
              result = result || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
            } else if (parser_token.tag_name === "colgroup") {
              result = result || this._tag_stack.try_pop("caption", ["table"]);
            } else if (parser_token.tag_name === "thead") {
              result = result || this._tag_stack.try_pop("caption", ["table"]);
              result = result || this._tag_stack.try_pop("colgroup", ["table"]);
            } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
              result = result || this._tag_stack.try_pop("caption", ["table"]);
              result = result || this._tag_stack.try_pop("colgroup", ["table"]);
              result = result || this._tag_stack.try_pop("thead", ["table"]);
              result = result || this._tag_stack.try_pop("tbody", ["table"]);
            } else if (parser_token.tag_name === "tr") {
              result = result || this._tag_stack.try_pop("caption", ["table"]);
              result = result || this._tag_stack.try_pop("colgroup", ["table"]);
              result = result || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
            } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
              result = result || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
              result = result || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
            }
            parser_token.parent = this._tag_stack.get_parser_token();
            return result;
          };
          module2.exports.Beautifier = Beautifier;
        },
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var BaseOptions = __webpack_require__2(6).Options;
          function Options(options) {
            BaseOptions.call(this, options, "html");
            if (this.templating.length === 1 && this.templating[0] === "auto") {
              this.templating = ["django", "erb", "handlebars", "php"];
            }
            this.indent_inner_html = this._get_boolean("indent_inner_html");
            this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
            this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
            this.indent_handlebars = this._get_boolean("indent_handlebars", true);
            this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]);
            this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
            this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
            this.inline = this._get_array("inline", [
              "a",
              "abbr",
              "area",
              "audio",
              "b",
              "bdi",
              "bdo",
              "br",
              "button",
              "canvas",
              "cite",
              "code",
              "data",
              "datalist",
              "del",
              "dfn",
              "em",
              "embed",
              "i",
              "iframe",
              "img",
              "input",
              "ins",
              "kbd",
              "keygen",
              "label",
              "map",
              "mark",
              "math",
              "meter",
              "noscript",
              "object",
              "output",
              "progress",
              "q",
              "ruby",
              "s",
              "samp",
              "select",
              "small",
              "span",
              "strong",
              "sub",
              "sup",
              "svg",
              "template",
              "textarea",
              "time",
              "u",
              "var",
              "video",
              "wbr",
              "text",
              "acronym",
              "big",
              "strike",
              "tt"
            ]);
            this.void_elements = this._get_array("void_elements", [
              "area",
              "base",
              "br",
              "col",
              "embed",
              "hr",
              "img",
              "input",
              "keygen",
              "link",
              "menuitem",
              "meta",
              "param",
              "source",
              "track",
              "wbr",
              "!doctype",
              "?xml",
              "basefont",
              "isindex"
            ]);
            this.unformatted = this._get_array("unformatted", []);
            this.content_unformatted = this._get_array("content_unformatted", [
              "pre",
              "textarea"
            ]);
            this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
            this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
          }
          Options.prototype = new BaseOptions();
          module2.exports.Options = Options;
        },
        function(module2, __unused_webpack_exports, __webpack_require__2) {
          var BaseTokenizer = __webpack_require__2(9).Tokenizer;
          var BASETOKEN = __webpack_require__2(9).TOKEN;
          var Directives = __webpack_require__2(13).Directives;
          var TemplatablePattern = __webpack_require__2(14).TemplatablePattern;
          var Pattern = __webpack_require__2(12).Pattern;
          var TOKEN = {
            TAG_OPEN: "TK_TAG_OPEN",
            TAG_CLOSE: "TK_TAG_CLOSE",
            ATTRIBUTE: "TK_ATTRIBUTE",
            EQUALS: "TK_EQUALS",
            VALUE: "TK_VALUE",
            COMMENT: "TK_COMMENT",
            TEXT: "TK_TEXT",
            UNKNOWN: "TK_UNKNOWN",
            START: BASETOKEN.START,
            RAW: BASETOKEN.RAW,
            EOF: BASETOKEN.EOF
          };
          var directives_core = new Directives(/<\!--/, /-->/);
          var Tokenizer = function(input_string, options) {
            BaseTokenizer.call(this, input_string, options);
            this._current_tag_name = "";
            var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
            var pattern_reader = new Pattern(this._input);
            this.__patterns = {
              word: templatable_reader.until(/[\n\r\t <]/),
              single_quote: templatable_reader.until_after(/'/),
              double_quote: templatable_reader.until_after(/"/),
              attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
              element_name: templatable_reader.until(/[\n\r\t >\/]/),
              handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
              handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
              handlebars_open: pattern_reader.until(/[\n\r\t }]/),
              handlebars_raw_close: pattern_reader.until(/}}/),
              comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
              cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
              conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
              processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
            };
            if (this._options.indent_handlebars) {
              this.__patterns.word = this.__patterns.word.exclude("handlebars");
            }
            this._unformatted_content_delimiter = null;
            if (this._options.unformatted_content_delimiter) {
              var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
              this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
            }
          };
          Tokenizer.prototype = new BaseTokenizer();
          Tokenizer.prototype._is_comment = function(current_token) {
            return false;
          };
          Tokenizer.prototype._is_opening = function(current_token) {
            return current_token.type === TOKEN.TAG_OPEN;
          };
          Tokenizer.prototype._is_closing = function(current_token, open_token) {
            return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{"));
          };
          Tokenizer.prototype._reset = function() {
            this._current_tag_name = "";
          };
          Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
            var token = null;
            this._readWhitespace();
            var c = this._input.peek();
            if (c === null) {
              return this._create_token(TOKEN.EOF, "");
            }
            token = token || this._read_open_handlebars(c, open_token);
            token = token || this._read_attribute(c, previous_token, open_token);
            token = token || this._read_close(c, open_token);
            token = token || this._read_raw_content(c, previous_token, open_token);
            token = token || this._read_content_word(c);
            token = token || this._read_comment_or_cdata(c);
            token = token || this._read_processing(c);
            token = token || this._read_open(c, open_token);
            token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());
            return token;
          };
          Tokenizer.prototype._read_comment_or_cdata = function(c) {
            var token = null;
            var resulting_string = null;
            var directives = null;
            if (c === "<") {
              var peek1 = this._input.peek(1);
              if (peek1 === "!") {
                resulting_string = this.__patterns.comment.read();
                if (resulting_string) {
                  directives = directives_core.get_directives(resulting_string);
                  if (directives && directives.ignore === "start") {
                    resulting_string += directives_core.readIgnored(this._input);
                  }
                } else {
                  resulting_string = this.__patterns.cdata.read();
                }
              }
              if (resulting_string) {
                token = this._create_token(TOKEN.COMMENT, resulting_string);
                token.directives = directives;
              }
            }
            return token;
          };
          Tokenizer.prototype._read_processing = function(c) {
            var token = null;
            var resulting_string = null;
            var directives = null;
            if (c === "<") {
              var peek1 = this._input.peek(1);
              if (peek1 === "!" || peek1 === "?") {
                resulting_string = this.__patterns.conditional_comment.read();
                resulting_string = resulting_string || this.__patterns.processing.read();
              }
              if (resulting_string) {
                token = this._create_token(TOKEN.COMMENT, resulting_string);
                token.directives = directives;
              }
            }
            return token;
          };
          Tokenizer.prototype._read_open = function(c, open_token) {
            var resulting_string = null;
            var token = null;
            if (!open_token) {
              if (c === "<") {
                resulting_string = this._input.next();
                if (this._input.peek() === "/") {
                  resulting_string += this._input.next();
                }
                resulting_string += this.__patterns.element_name.read();
                token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
              }
            }
            return token;
          };
          Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
            var resulting_string = null;
            var token = null;
            if (!open_token) {
              if (this._options.indent_handlebars && c === "{" && this._input.peek(1) === "{") {
                if (this._input.peek(2) === "!") {
                  resulting_string = this.__patterns.handlebars_comment.read();
                  resulting_string = resulting_string || this.__patterns.handlebars.read();
                  token = this._create_token(TOKEN.COMMENT, resulting_string);
                } else {
                  resulting_string = this.__patterns.handlebars_open.read();
                  token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
                }
              }
            }
            return token;
          };
          Tokenizer.prototype._read_close = function(c, open_token) {
            var resulting_string = null;
            var token = null;
            if (open_token) {
              if (open_token.text[0] === "<" && (c === ">" || c === "/" && this._input.peek(1) === ">")) {
                resulting_string = this._input.next();
                if (c === "/") {
                  resulting_string += this._input.next();
                }
                token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
              } else if (open_token.text[0] === "{" && c === "}" && this._input.peek(1) === "}") {
                this._input.next();
                this._input.next();
                token = this._create_token(TOKEN.TAG_CLOSE, "}}");
              }
            }
            return token;
          };
          Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
            var token = null;
            var resulting_string = "";
            if (open_token && open_token.text[0] === "<") {
              if (c === "=") {
                token = this._create_token(TOKEN.EQUALS, this._input.next());
              } else if (c === '"' || c === "'") {
                var content = this._input.next();
                if (c === '"') {
                  content += this.__patterns.double_quote.read();
                } else {
                  content += this.__patterns.single_quote.read();
                }
                token = this._create_token(TOKEN.VALUE, content);
              } else {
                resulting_string = this.__patterns.attribute.read();
                if (resulting_string) {
                  if (previous_token.type === TOKEN.EQUALS) {
                    token = this._create_token(TOKEN.VALUE, resulting_string);
                  } else {
                    token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
                  }
                }
              }
            }
            return token;
          };
          Tokenizer.prototype._is_content_unformatted = function(tag_name) {
            return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
          };
          Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {
            var resulting_string = "";
            if (open_token && open_token.text[0] === "{") {
              resulting_string = this.__patterns.handlebars_raw_close.read();
            } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
              var tag_name = previous_token.opened.text.substr(1).toLowerCase();
              if (tag_name === "script" || tag_name === "style") {
                var token = this._read_comment_or_cdata(c);
                if (token) {
                  token.type = TOKEN.TEXT;
                  return token;
                }
                resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
              } else if (this._is_content_unformatted(tag_name)) {
                resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
              }
            }
            if (resulting_string) {
              return this._create_token(TOKEN.TEXT, resulting_string);
            }
            return null;
          };
          Tokenizer.prototype._read_content_word = function(c) {
            var resulting_string = "";
            if (this._options.unformatted_content_delimiter) {
              if (c === this._options.unformatted_content_delimiter[0]) {
                resulting_string = this.__patterns.unformatted_content_delimiter.read();
              }
            }
            if (!resulting_string) {
              resulting_string = this.__patterns.word.read();
            }
            if (resulting_string) {
              return this._create_token(TOKEN.TEXT, resulting_string);
            }
          };
          module2.exports.Tokenizer = Tokenizer;
          module2.exports.TOKEN = TOKEN;
        }
      ];
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          exports: {}
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      var __webpack_exports__ = __webpack_require__(18);
      legacy_beautify_html = __webpack_exports__;
    })();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlFormatter.js
function format(document, range, options) {
  var value = document.getText();
  var includesEnd = true;
  var initialIndentLevel = 0;
  var tabSize = options.tabSize || 4;
  if (range) {
    var startOffset = document.offsetAt(range.start);
    var extendedStart = startOffset;
    while (extendedStart > 0 && isWhitespace(value, extendedStart - 1)) {
      extendedStart--;
    }
    if (extendedStart === 0 || isEOL(value, extendedStart - 1)) {
      startOffset = extendedStart;
    } else {
      if (extendedStart < startOffset) {
        startOffset = extendedStart + 1;
      }
    }
    var endOffset = document.offsetAt(range.end);
    var extendedEnd = endOffset;
    while (extendedEnd < value.length && isWhitespace(value, extendedEnd)) {
      extendedEnd++;
    }
    if (extendedEnd === value.length || isEOL(value, extendedEnd)) {
      endOffset = extendedEnd;
    }
    range = Range2.create(document.positionAt(startOffset), document.positionAt(endOffset));
    var firstHalf = value.substring(0, startOffset);
    if (new RegExp(/.*[<][^>]*$/).test(firstHalf)) {
      value = value.substring(startOffset, endOffset);
      return [{
        range,
        newText: value
      }];
    }
    includesEnd = endOffset === value.length;
    value = value.substring(startOffset, endOffset);
    if (startOffset !== 0) {
      var startOfLineOffset = document.offsetAt(Position2.create(range.start.line, 0));
      initialIndentLevel = computeIndentLevel(document.getText(), startOfLineOffset, options);
    }
  } else {
    range = Range2.create(Position2.create(0, 0), document.positionAt(value.length));
  }
  var htmlOptions = {
    indent_size: tabSize,
    indent_char: options.insertSpaces ? " " : "	",
    indent_empty_lines: getFormatOption(options, "indentEmptyLines", false),
    wrap_line_length: getFormatOption(options, "wrapLineLength", 120),
    unformatted: getTagsFormatOption(options, "unformatted", void 0),
    content_unformatted: getTagsFormatOption(options, "contentUnformatted", void 0),
    indent_inner_html: getFormatOption(options, "indentInnerHtml", false),
    preserve_newlines: getFormatOption(options, "preserveNewLines", true),
    max_preserve_newlines: getFormatOption(options, "maxPreserveNewLines", 32786),
    indent_handlebars: getFormatOption(options, "indentHandlebars", false),
    end_with_newline: includesEnd && getFormatOption(options, "endWithNewline", false),
    extra_liners: getTagsFormatOption(options, "extraLiners", void 0),
    wrap_attributes: getFormatOption(options, "wrapAttributes", "auto"),
    wrap_attributes_indent_size: getFormatOption(options, "wrapAttributesIndentSize", void 0),
    eol: "\n",
    indent_scripts: getFormatOption(options, "indentScripts", "normal"),
    templating: getTemplatingFormatOption(options, "all"),
    unformatted_content_delimiter: getFormatOption(options, "unformattedContentDelimiter", "")
  };
  var result = html_beautify(trimLeft(value), htmlOptions);
  if (initialIndentLevel > 0) {
    var indent = options.insertSpaces ? repeat(" ", tabSize * initialIndentLevel) : repeat("	", initialIndentLevel);
    result = result.split("\n").join("\n" + indent);
    if (range.start.character === 0) {
      result = indent + result;
    }
  }
  return [{
    range,
    newText: result
  }];
}
function trimLeft(str) {
  return str.replace(/^\s+/, "");
}
function getFormatOption(options, key, dflt) {
  if (options && options.hasOwnProperty(key)) {
    var value = options[key];
    if (value !== null) {
      return value;
    }
  }
  return dflt;
}
function getTagsFormatOption(options, key, dflt) {
  var list = getFormatOption(options, key, null);
  if (typeof list === "string") {
    if (list.length > 0) {
      return list.split(",").map(function(t) {
        return t.trim().toLowerCase();
      });
    }
    return [];
  }
  return dflt;
}
function getTemplatingFormatOption(options, dflt) {
  var value = getFormatOption(options, "templating", dflt);
  if (value === true) {
    return ["auto"];
  }
  return ["none"];
}
function computeIndentLevel(content, offset, options) {
  var i = offset;
  var nChars = 0;
  var tabSize = options.tabSize || 4;
  while (i < content.length) {
    var ch = content.charAt(i);
    if (ch === " ") {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}
function isWhitespace(text, offset) {
  return " 	".indexOf(text.charAt(offset)) !== -1;
}
var init_htmlFormatter = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlFormatter.js"() {
    init_htmlLanguageTypes();
    init_beautify_html();
    init_strings();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlLinks.js
function normalizeRef(url) {
  var first = url[0];
  var last = url[url.length - 1];
  if (first === last && (first === "'" || first === '"')) {
    url = url.substr(1, url.length - 2);
  }
  return url;
}
function validateRef(url, languageId) {
  if (!url.length) {
    return false;
  }
  if (languageId === "handlebars" && /{{|}}/.test(url)) {
    return false;
  }
  return /\b(w[\w\d+.-]*:\/\/)?[^\s()<>]+(?:\([\w\d]+\)|([^[:punct:]\s]|\/?))/.test(url);
}
function getWorkspaceUrl(documentUri, tokenContent, documentContext, base) {
  if (/^\s*javascript\:/i.test(tokenContent) || /[\n\r]/.test(tokenContent)) {
    return void 0;
  }
  tokenContent = tokenContent.replace(/^\s*/g, "");
  if (/^https?:\/\//i.test(tokenContent) || /^file:\/\//i.test(tokenContent)) {
    return tokenContent;
  }
  if (/^\#/i.test(tokenContent)) {
    return documentUri + tokenContent;
  }
  if (/^\/\//i.test(tokenContent)) {
    var pickedScheme = startsWith(documentUri, "https://") ? "https" : "http";
    return pickedScheme + ":" + tokenContent.replace(/^\s*/g, "");
  }
  if (documentContext) {
    return documentContext.resolveReference(tokenContent, base || documentUri);
  }
  return tokenContent;
}
function createLink(document, documentContext, attributeValue, startOffset, endOffset, base) {
  var tokenContent = normalizeRef(attributeValue);
  if (!validateRef(tokenContent, document.languageId)) {
    return void 0;
  }
  if (tokenContent.length < attributeValue.length) {
    startOffset++;
    endOffset--;
  }
  var workspaceUrl = getWorkspaceUrl(document.uri, tokenContent, documentContext, base);
  if (!workspaceUrl || !isValidURI(workspaceUrl)) {
    return void 0;
  }
  return {
    range: Range2.create(document.positionAt(startOffset), document.positionAt(endOffset)),
    target: workspaceUrl
  };
}
function isValidURI(uri) {
  try {
    URI2.parse(uri);
    return true;
  } catch (e) {
    return false;
  }
}
function findDocumentLinks(document, documentContext) {
  var newLinks = [];
  var scanner = createScanner(document.getText(), 0);
  var token = scanner.scan();
  var lastAttributeName = void 0;
  var afterBase = false;
  var base = void 0;
  var idLocations = {};
  while (token !== TokenType.EOS) {
    switch (token) {
      case TokenType.StartTag:
        if (!base) {
          var tagName = scanner.getTokenText().toLowerCase();
          afterBase = tagName === "base";
        }
        break;
      case TokenType.AttributeName:
        lastAttributeName = scanner.getTokenText().toLowerCase();
        break;
      case TokenType.AttributeValue:
        if (lastAttributeName === "src" || lastAttributeName === "href") {
          var attributeValue = scanner.getTokenText();
          if (!afterBase) {
            var link = createLink(document, documentContext, attributeValue, scanner.getTokenOffset(), scanner.getTokenEnd(), base);
            if (link) {
              newLinks.push(link);
            }
          }
          if (afterBase && typeof base === "undefined") {
            base = normalizeRef(attributeValue);
            if (base && documentContext) {
              base = documentContext.resolveReference(base, document.uri);
            }
          }
          afterBase = false;
          lastAttributeName = void 0;
        } else if (lastAttributeName === "id") {
          var id = normalizeRef(scanner.getTokenText());
          idLocations[id] = scanner.getTokenOffset();
        }
        break;
    }
    token = scanner.scan();
  }
  for (var _i = 0, newLinks_1 = newLinks; _i < newLinks_1.length; _i++) {
    var link = newLinks_1[_i];
    var localWithHash = document.uri + "#";
    if (link.target && startsWith(link.target, localWithHash)) {
      var target = link.target.substr(localWithHash.length);
      var offset = idLocations[target];
      if (offset !== void 0) {
        var pos = document.positionAt(offset);
        link.target = "" + localWithHash + (pos.line + 1) + "," + (pos.character + 1);
      }
    }
  }
  return newLinks;
}
var init_htmlLinks = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlLinks.js"() {
    init_htmlScanner();
    init_strings();
    init_esm();
    init_htmlLanguageTypes();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlHighlighting.js
function findDocumentHighlights(document, position, htmlDocument) {
  var offset = document.offsetAt(position);
  var node = htmlDocument.findNodeAt(offset);
  if (!node.tag) {
    return [];
  }
  var result = [];
  var startTagRange = getTagNameRange(TokenType.StartTag, document, node.start);
  var endTagRange = typeof node.endTagStart === "number" && getTagNameRange(TokenType.EndTag, document, node.endTagStart);
  if (startTagRange && covers(startTagRange, position) || endTagRange && covers(endTagRange, position)) {
    if (startTagRange) {
      result.push({ kind: DocumentHighlightKind2.Read, range: startTagRange });
    }
    if (endTagRange) {
      result.push({ kind: DocumentHighlightKind2.Read, range: endTagRange });
    }
  }
  return result;
}
function isBeforeOrEqual(pos1, pos2) {
  return pos1.line < pos2.line || pos1.line === pos2.line && pos1.character <= pos2.character;
}
function covers(range, position) {
  return isBeforeOrEqual(range.start, position) && isBeforeOrEqual(position, range.end);
}
function getTagNameRange(tokenType, document, startOffset) {
  var scanner = createScanner(document.getText(), startOffset);
  var token = scanner.scan();
  while (token !== TokenType.EOS && token !== tokenType) {
    token = scanner.scan();
  }
  if (token !== TokenType.EOS) {
    return { start: document.positionAt(scanner.getTokenOffset()), end: document.positionAt(scanner.getTokenEnd()) };
  }
  return null;
}
var init_htmlHighlighting = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlHighlighting.js"() {
    init_htmlScanner();
    init_htmlLanguageTypes();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlSymbolsProvider.js
function findDocumentSymbols(document, htmlDocument) {
  var symbols = [];
  htmlDocument.roots.forEach(function(node) {
    provideFileSymbolsInternal(document, node, "", symbols);
  });
  return symbols;
}
function provideFileSymbolsInternal(document, node, container, symbols) {
  var name = nodeToName(node);
  var location = Location2.create(document.uri, Range2.create(document.positionAt(node.start), document.positionAt(node.end)));
  var symbol = {
    name,
    location,
    containerName: container,
    kind: SymbolKind2.Field
  };
  symbols.push(symbol);
  node.children.forEach(function(child) {
    provideFileSymbolsInternal(document, child, name, symbols);
  });
}
function nodeToName(node) {
  var name = node.tag;
  if (node.attributes) {
    var id = node.attributes["id"];
    var classes = node.attributes["class"];
    if (id) {
      name += "#" + id.replace(/[\"\']/g, "");
    }
    if (classes) {
      name += classes.replace(/[\"\']/g, "").split(/\s+/).map(function(className) {
        return "." + className;
      }).join("");
    }
  }
  return name || "?";
}
var init_htmlSymbolsProvider = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlSymbolsProvider.js"() {
    init_htmlLanguageTypes();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlRename.js
function doRename(document, position, newName, htmlDocument) {
  var _a2;
  var offset = document.offsetAt(position);
  var node = htmlDocument.findNodeAt(offset);
  if (!node.tag) {
    return null;
  }
  if (!isWithinTagRange(node, offset, node.tag)) {
    return null;
  }
  var edits = [];
  var startTagRange = {
    start: document.positionAt(node.start + "<".length),
    end: document.positionAt(node.start + "<".length + node.tag.length)
  };
  edits.push({
    range: startTagRange,
    newText: newName
  });
  if (node.endTagStart) {
    var endTagRange = {
      start: document.positionAt(node.endTagStart + "</".length),
      end: document.positionAt(node.endTagStart + "</".length + node.tag.length)
    };
    edits.push({
      range: endTagRange,
      newText: newName
    });
  }
  var changes = (_a2 = {}, _a2[document.uri.toString()] = edits, _a2);
  return {
    changes
  };
}
function isWithinTagRange(node, offset, nodeTag) {
  if (node.endTagStart) {
    if (node.endTagStart + "</".length <= offset && offset <= node.endTagStart + "</".length + nodeTag.length) {
      return true;
    }
  }
  return node.start + "<".length <= offset && offset <= node.start + "<".length + nodeTag.length;
}
var init_htmlRename = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlRename.js"() {
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlMatchingTagPosition.js
function findMatchingTagPosition(document, position, htmlDocument) {
  var offset = document.offsetAt(position);
  var node = htmlDocument.findNodeAt(offset);
  if (!node.tag) {
    return null;
  }
  if (!node.endTagStart) {
    return null;
  }
  if (node.start + "<".length <= offset && offset <= node.start + "<".length + node.tag.length) {
    var mirrorOffset = offset - "<".length - node.start + node.endTagStart + "</".length;
    return document.positionAt(mirrorOffset);
  }
  if (node.endTagStart + "</".length <= offset && offset <= node.endTagStart + "</".length + node.tag.length) {
    var mirrorOffset = offset - "</".length - node.endTagStart + node.start + "<".length;
    return document.positionAt(mirrorOffset);
  }
  return null;
}
var init_htmlMatchingTagPosition = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlMatchingTagPosition.js"() {
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlLinkedEditing.js
function findLinkedEditingRanges(document, position, htmlDocument) {
  var offset = document.offsetAt(position);
  var node = htmlDocument.findNodeAt(offset);
  var tagLength = node.tag ? node.tag.length : 0;
  if (!node.endTagStart) {
    return null;
  }
  if (node.start + "<".length <= offset && offset <= node.start + "<".length + tagLength || node.endTagStart + "</".length <= offset && offset <= node.endTagStart + "</".length + tagLength) {
    return [
      Range2.create(document.positionAt(node.start + "<".length), document.positionAt(node.start + "<".length + tagLength)),
      Range2.create(document.positionAt(node.endTagStart + "</".length), document.positionAt(node.endTagStart + "</".length + tagLength))
    ];
  }
  return null;
}
var init_htmlLinkedEditing = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlLinkedEditing.js"() {
    init_htmlLanguageTypes();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlFolding.js
function limitRanges(ranges, rangeLimit) {
  ranges = ranges.sort(function(r1, r2) {
    var diff = r1.startLine - r2.startLine;
    if (diff === 0) {
      diff = r1.endLine - r2.endLine;
    }
    return diff;
  });
  var top = void 0;
  var previous = [];
  var nestingLevels = [];
  var nestingLevelCounts = [];
  var setNestingLevel = function(index, level2) {
    nestingLevels[index] = level2;
    if (level2 < 30) {
      nestingLevelCounts[level2] = (nestingLevelCounts[level2] || 0) + 1;
    }
  };
  for (var i = 0; i < ranges.length; i++) {
    var entry = ranges[i];
    if (!top) {
      top = entry;
      setNestingLevel(i, 0);
    } else {
      if (entry.startLine > top.startLine) {
        if (entry.endLine <= top.endLine) {
          previous.push(top);
          top = entry;
          setNestingLevel(i, previous.length);
        } else if (entry.startLine > top.endLine) {
          do {
            top = previous.pop();
          } while (top && entry.startLine > top.endLine);
          if (top) {
            previous.push(top);
          }
          top = entry;
          setNestingLevel(i, previous.length);
        }
      }
    }
  }
  var entries = 0;
  var maxLevel = 0;
  for (var i = 0; i < nestingLevelCounts.length; i++) {
    var n = nestingLevelCounts[i];
    if (n) {
      if (n + entries > rangeLimit) {
        maxLevel = i;
        break;
      }
      entries += n;
    }
  }
  var result = [];
  for (var i = 0; i < ranges.length; i++) {
    var level = nestingLevels[i];
    if (typeof level === "number") {
      if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {
        result.push(ranges[i]);
      }
    }
  }
  return result;
}
function getFoldingRanges(document, context) {
  var scanner = createScanner(document.getText());
  var token = scanner.scan();
  var ranges = [];
  var stack = [];
  var lastTagName = null;
  var prevStart = -1;
  function addRange(range) {
    ranges.push(range);
    prevStart = range.startLine;
  }
  while (token !== TokenType.EOS) {
    switch (token) {
      case TokenType.StartTag: {
        var tagName = scanner.getTokenText();
        var startLine = document.positionAt(scanner.getTokenOffset()).line;
        stack.push({ startLine, tagName });
        lastTagName = tagName;
        break;
      }
      case TokenType.EndTag: {
        lastTagName = scanner.getTokenText();
        break;
      }
      case TokenType.StartTagClose:
        if (!lastTagName || !isVoidElement(lastTagName)) {
          break;
        }
      case TokenType.EndTagClose:
      case TokenType.StartTagSelfClose: {
        var i = stack.length - 1;
        while (i >= 0 && stack[i].tagName !== lastTagName) {
          i--;
        }
        if (i >= 0) {
          var stackElement = stack[i];
          stack.length = i;
          var line = document.positionAt(scanner.getTokenOffset()).line;
          var startLine = stackElement.startLine;
          var endLine = line - 1;
          if (endLine > startLine && prevStart !== startLine) {
            addRange({ startLine, endLine });
          }
        }
        break;
      }
      case TokenType.Comment: {
        var startLine = document.positionAt(scanner.getTokenOffset()).line;
        var text = scanner.getTokenText();
        var m = text.match(/^\s*#(region\b)|(endregion\b)/);
        if (m) {
          if (m[1]) {
            stack.push({ startLine, tagName: "" });
          } else {
            var i = stack.length - 1;
            while (i >= 0 && stack[i].tagName.length) {
              i--;
            }
            if (i >= 0) {
              var stackElement = stack[i];
              stack.length = i;
              var endLine = startLine;
              startLine = stackElement.startLine;
              if (endLine > startLine && prevStart !== startLine) {
                addRange({ startLine, endLine, kind: FoldingRangeKind2.Region });
              }
            }
          }
        } else {
          var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;
          if (startLine < endLine) {
            addRange({ startLine, endLine, kind: FoldingRangeKind2.Comment });
          }
        }
        break;
      }
    }
    token = scanner.scan();
  }
  var rangeLimit = context && context.rangeLimit || Number.MAX_VALUE;
  if (ranges.length > rangeLimit) {
    return limitRanges(ranges, rangeLimit);
  }
  return ranges;
}
var init_htmlFolding = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlFolding.js"() {
    init_htmlLanguageTypes();
    init_htmlScanner();
    init_fact();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlSelectionRange.js
function getSelectionRanges(document, positions) {
  function getSelectionRange(position) {
    var applicableRanges = getApplicableRanges(document, position);
    var prev = void 0;
    var current = void 0;
    for (var index = applicableRanges.length - 1; index >= 0; index--) {
      var range = applicableRanges[index];
      if (!prev || range[0] !== prev[0] || range[1] !== prev[1]) {
        current = SelectionRange2.create(Range2.create(document.positionAt(applicableRanges[index][0]), document.positionAt(applicableRanges[index][1])), current);
      }
      prev = range;
    }
    if (!current) {
      current = SelectionRange2.create(Range2.create(position, position));
    }
    return current;
  }
  return positions.map(getSelectionRange);
}
function getApplicableRanges(document, position) {
  var htmlDoc = parse(document.getText());
  var currOffset = document.offsetAt(position);
  var currNode = htmlDoc.findNodeAt(currOffset);
  var result = getAllParentTagRanges(currNode);
  if (currNode.startTagEnd && !currNode.endTagStart) {
    if (currNode.startTagEnd !== currNode.end) {
      return [[currNode.start, currNode.end]];
    }
    var closeRange = Range2.create(document.positionAt(currNode.startTagEnd - 2), document.positionAt(currNode.startTagEnd));
    var closeText = document.getText(closeRange);
    if (closeText === "/>") {
      result.unshift([currNode.start + 1, currNode.startTagEnd - 2]);
    } else {
      result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);
    }
    var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);
    result = attributeLevelRanges.concat(result);
    return result;
  }
  if (!currNode.startTagEnd || !currNode.endTagStart) {
    return result;
  }
  result.unshift([currNode.start, currNode.end]);
  if (currNode.start < currOffset && currOffset < currNode.startTagEnd) {
    result.unshift([currNode.start + 1, currNode.startTagEnd - 1]);
    var attributeLevelRanges = getAttributeLevelRanges(document, currNode, currOffset);
    result = attributeLevelRanges.concat(result);
    return result;
  } else if (currNode.startTagEnd <= currOffset && currOffset <= currNode.endTagStart) {
    result.unshift([currNode.startTagEnd, currNode.endTagStart]);
    return result;
  } else {
    if (currOffset >= currNode.endTagStart + 2) {
      result.unshift([currNode.endTagStart + 2, currNode.end - 1]);
    }
    return result;
  }
}
function getAllParentTagRanges(initialNode) {
  var currNode = initialNode;
  var getNodeRanges = function(n) {
    if (n.startTagEnd && n.endTagStart && n.startTagEnd < n.endTagStart) {
      return [
        [n.startTagEnd, n.endTagStart],
        [n.start, n.end]
      ];
    }
    return [
      [n.start, n.end]
    ];
  };
  var result = [];
  while (currNode.parent) {
    currNode = currNode.parent;
    getNodeRanges(currNode).forEach(function(r) {
      return result.push(r);
    });
  }
  return result;
}
function getAttributeLevelRanges(document, currNode, currOffset) {
  var currNodeRange = Range2.create(document.positionAt(currNode.start), document.positionAt(currNode.end));
  var currNodeText = document.getText(currNodeRange);
  var relativeOffset = currOffset - currNode.start;
  var scanner = createScanner(currNodeText);
  var token = scanner.scan();
  var positionOffset = currNode.start;
  var result = [];
  var isInsideAttribute = false;
  var attrStart = -1;
  while (token !== TokenType.EOS) {
    switch (token) {
      case TokenType.AttributeName: {
        if (relativeOffset < scanner.getTokenOffset()) {
          isInsideAttribute = false;
          break;
        }
        if (relativeOffset <= scanner.getTokenEnd()) {
          result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);
        }
        isInsideAttribute = true;
        attrStart = scanner.getTokenOffset();
        break;
      }
      case TokenType.AttributeValue: {
        if (!isInsideAttribute) {
          break;
        }
        var valueText = scanner.getTokenText();
        if (relativeOffset < scanner.getTokenOffset()) {
          result.push([attrStart, scanner.getTokenEnd()]);
          break;
        }
        if (relativeOffset >= scanner.getTokenOffset() && relativeOffset <= scanner.getTokenEnd()) {
          result.unshift([scanner.getTokenOffset(), scanner.getTokenEnd()]);
          if (valueText[0] === '"' && valueText[valueText.length - 1] === '"' || valueText[0] === "'" && valueText[valueText.length - 1] === "'") {
            if (relativeOffset >= scanner.getTokenOffset() + 1 && relativeOffset <= scanner.getTokenEnd() - 1) {
              result.unshift([scanner.getTokenOffset() + 1, scanner.getTokenEnd() - 1]);
            }
          }
          result.push([attrStart, scanner.getTokenEnd()]);
        }
        break;
      }
    }
    token = scanner.scan();
  }
  return result.map(function(pair) {
    return [pair[0] + positionOffset, pair[1] + positionOffset];
  });
}
var init_htmlSelectionRange = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/services/htmlSelectionRange.js"() {
    init_htmlScanner();
    init_htmlParser();
    init_htmlLanguageTypes();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/languageFacts/data/webCustomData.js
var htmlData;
var init_webCustomData = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/languageFacts/data/webCustomData.js"() {
    htmlData = {
      "version": 1.1,
      "tags": [
        {
          "name": "html",
          "description": {
            "kind": "markdown",
            "value": "The html element represents the root of an HTML document."
          },
          "attributes": [
            {
              "name": "manifest",
              "description": {
                "kind": "markdown",
                "value": "Specifies the URI of a resource manifest indicating resources that should be cached locally. See [Using the application cache](https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache) for details."
              }
            },
            {
              "name": "version",
              "description": 'Specifies the version of the HTML [Document Type Definition](https://developer.mozilla.org/en-US/docs/Glossary/DTD "Document Type Definition: In HTML, the doctype is the required "<!DOCTYPE html>" preamble found at the top of all documents. Its sole purpose is to prevent a browser from switching into so-called \u201Cquirks mode\u201D when rendering a document; that is, the "<!DOCTYPE html>" doctype ensures that the browser makes a best-effort attempt at following the relevant specifications, rather than using a different rendering mode that is incompatible with some specifications.") that governs the current document. This attribute is not needed, because it is redundant with the version information in the document type declaration.'
            },
            {
              "name": "xmlns",
              "description": 'Specifies the XML Namespace of the document. Default value is `"http://www.w3.org/1999/xhtml"`. This is required in documents parsed with XML parsers, and optional in text/html documents.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/html"
            }
          ]
        },
        {
          "name": "head",
          "description": {
            "kind": "markdown",
            "value": "The head element represents a collection of metadata for the Document."
          },
          "attributes": [
            {
              "name": "profile",
              "description": "The URIs of one or more metadata profiles, separated by white space."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/head"
            }
          ]
        },
        {
          "name": "title",
          "description": {
            "kind": "markdown",
            "value": "The title element represents the document's title or name. Authors should use titles that identify their documents even when they are used out of context, for example in a user's history or bookmarks, or in search results. The document's title is often different from its first heading, since the first heading does not have to stand alone when taken out of context."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/title"
            }
          ]
        },
        {
          "name": "base",
          "description": {
            "kind": "markdown",
            "value": "The base element allows authors to specify the document base URL for the purposes of resolving relative URLs, and the name of the default browsing context for the purposes of following hyperlinks. The element does not represent any content beyond this information."
          },
          "attributes": [
            {
              "name": "href",
              "description": {
                "kind": "markdown",
                "value": "The base URL to be used throughout the document for relative URL addresses. If this attribute is specified, this element must come before any other elements with attributes whose values are URLs. Absolute and relative URLs are allowed."
              }
            },
            {
              "name": "target",
              "description": {
                "kind": "markdown",
                "value": "A name or keyword indicating the default location to display the result when hyperlinks or forms cause navigation, for elements that do not have an explicit target reference. It is a name of, or keyword for, a _browsing context_ (for example: tab, window, or inline frame). The following keywords have special meanings:\n\n*   `_self`: Load the result into the same browsing context as the current one. This value is the default if the attribute is not specified.\n*   `_blank`: Load the result into a new unnamed browsing context.\n*   `_parent`: Load the result into the parent browsing context of the current one. If there is no parent, this option behaves the same way as `_self`.\n*   `_top`: Load the result into the top-level browsing context (that is, the browsing context that is an ancestor of the current one, and has no parent). If there is no parent, this option behaves the same way as `_self`.\n\nIf this attribute is specified, this element must come before any other elements with attributes whose values are URLs."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/base"
            }
          ]
        },
        {
          "name": "link",
          "description": {
            "kind": "markdown",
            "value": "The link element allows authors to link their document to other resources."
          },
          "attributes": [
            {
              "name": "href",
              "description": {
                "kind": "markdown",
                "value": 'This attribute specifies the [URL](https://developer.mozilla.org/en-US/docs/Glossary/URL "URL: Uniform Resource Locator (URL) is a text string specifying where a resource can be found on the Internet.") of the linked resource. A URL can be absolute or relative.'
              }
            },
            {
              "name": "crossorigin",
              "valueSet": "xo",
              "description": {
                "kind": "markdown",
                "value": 'This enumerated attribute indicates whether [CORS](https://developer.mozilla.org/en-US/docs/Glossary/CORS "CORS: CORS (Cross-Origin Resource Sharing) is a system, consisting of transmitting HTTP headers, that determines whether browsers block frontend JavaScript code from accessing responses for cross-origin requests.") must be used when fetching the resource. [CORS-enabled images](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_Enabled_Image) can be reused in the [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas "Use the HTML <canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations.") element without being _tainted_. The allowed values are:\n\n`anonymous`\n\nA cross-origin request (i.e. with an [`Origin`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin "The Origin request header indicates where a fetch originates from. It doesn\'t include any path information, but only the server name. It is sent with CORS requests, as well as with POST requests. It is similar to the Referer header, but, unlike this header, it doesn\'t disclose the whole path.") HTTP header) is performed, but no credential is sent (i.e. no cookie, X.509 certificate, or HTTP Basic authentication). If the server does not give credentials to the origin site (by not setting the [`Access-Control-Allow-Origin`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin "The Access-Control-Allow-Origin response header indicates whether the response can be shared with requesting code from the given origin.") HTTP header) the image will be tainted and its usage restricted.\n\n`use-credentials`\n\nA cross-origin request (i.e. with an `Origin` HTTP header) is performed along with a credential sent (i.e. a cookie, certificate, and/or HTTP Basic authentication is performed). If the server does not give credentials to the origin site (through [`Access-Control-Allow-Credentials`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials "The Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request\'s credentials mode (Request.credentials) is "include".") HTTP header), the resource will be _tainted_ and its usage restricted.\n\nIf the attribute is not present, the resource is fetched without a [CORS](https://developer.mozilla.org/en-US/docs/Glossary/CORS "CORS: CORS (Cross-Origin Resource Sharing) is a system, consisting of transmitting HTTP headers, that determines whether browsers block frontend JavaScript code from accessing responses for cross-origin requests.") request (i.e. without sending the `Origin` HTTP header), preventing its non-tainted usage. If invalid, it is handled as if the enumerated keyword **anonymous** was used. See [CORS settings attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for additional information.'
              }
            },
            {
              "name": "rel",
              "description": {
                "kind": "markdown",
                "value": "This attribute names a relationship of the linked document to the current document. The attribute must be a space-separated list of the [link types values](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types)."
              }
            },
            {
              "name": "media",
              "description": {
                "kind": "markdown",
                "value": "This attribute specifies the media that the linked resource applies to. Its value must be a media type / [media query](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_queries). This attribute is mainly useful when linking to external stylesheets \u2014 it allows the user agent to pick the best adapted one for the device it runs on.\n\n**Notes:**\n\n*   In HTML 4, this can only be a simple white-space-separated list of media description literals, i.e., [media types and groups](https://developer.mozilla.org/en-US/docs/Web/CSS/@media), where defined and allowed as values for this attribute, such as `print`, `screen`, `aural`, `braille`. HTML5 extended this to any kind of [media queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_queries), which are a superset of the allowed values of HTML 4.\n*   Browsers not supporting [CSS3 Media Queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_queries) won't necessarily recognize the adequate link; do not forget to set fallback links, the restricted set of media queries defined in HTML 4."
              }
            },
            {
              "name": "hreflang",
              "description": {
                "kind": "markdown",
                "value": "This attribute indicates the language of the linked resource. It is purely advisory. Allowed values are determined by [BCP47](https://www.ietf.org/rfc/bcp/bcp47.txt). Use this attribute only if the [`href`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-href) attribute is present."
              }
            },
            {
              "name": "type",
              "description": {
                "kind": "markdown",
                "value": 'This attribute is used to define the type of the content linked to. The value of the attribute should be a MIME type such as **text/html**, **text/css**, and so on. The common use of this attribute is to define the type of stylesheet being referenced (such as **text/css**), but given that CSS is the only stylesheet language used on the web, not only is it possible to omit the `type` attribute, but is actually now recommended practice. It is also used on `rel="preload"` link types, to make sure the browser only downloads file types that it supports.'
              }
            },
            {
              "name": "sizes",
              "description": {
                "kind": "markdown",
                "value": "This attribute defines the sizes of the icons for visual media contained in the resource. It must be present only if the [`rel`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel) contains a value of `icon` or a non-standard type such as Apple's `apple-touch-icon`. It may have the following values:\n\n*   `any`, meaning that the icon can be scaled to any size as it is in a vector format, like `image/svg+xml`.\n*   a white-space separated list of sizes, each in the format `_<width in pixels>_x_<height in pixels>_` or `_<width in pixels>_X_<height in pixels>_`. Each of these sizes must be contained in the resource.\n\n**Note:** Most icon formats are only able to store one single icon; therefore most of the time the [`sizes`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-sizes) contains only one entry. MS's ICO format does, as well as Apple's ICNS. ICO is more ubiquitous; you should definitely use it."
              }
            },
            {
              "name": "as",
              "description": 'This attribute is only used when `rel="preload"` or `rel="prefetch"` has been set on the `<link>` element. It specifies the type of content being loaded by the `<link>`, which is necessary for content prioritization, request matching, application of correct [content security policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP), and setting of correct [`Accept`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept "The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. Using content negotiation, the server then selects one of the proposals, uses it and informs the client of its choice with the Content-Type response header. Browsers set adequate values for this header depending on\xA0the context where the request is done: when fetching a CSS stylesheet a different value is set for the request than when fetching an image,\xA0video or a script.") request header.'
            },
            {
              "name": "importance",
              "description": "Indicates the relative importance of the resource. Priority hints are delegated using the values:"
            },
            {
              "name": "importance",
              "description": '**`auto`**: Indicates\xA0**no\xA0preference**. The browser may use its own heuristics to decide the priority of the resource.\n\n**`high`**: Indicates to the\xA0browser\xA0that the resource is of\xA0**high** priority.\n\n**`low`**:\xA0Indicates to the\xA0browser\xA0that the resource is of\xA0**low** priority.\n\n**Note:** The `importance` attribute may only be used for the `<link>` element if `rel="preload"` or `rel="prefetch"` is present.'
            },
            {
              "name": "integrity",
              "description": "Contains inline metadata \u2014 a base64-encoded cryptographic hash of the resource (file) you\u2019re telling the browser to fetch. The browser can use this to verify that the fetched resource has been delivered free of unexpected manipulation. See [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)."
            },
            {
              "name": "referrerpolicy",
              "description": 'A string indicating which referrer to use when fetching the resource:\n\n*   `no-referrer` means that the [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer "The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.") header will not be sent.\n*   `no-referrer-when-downgrade` means that no [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer "The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.") header will be sent when navigating to an origin without TLS (HTTPS). This is a user agent\u2019s default behavior, if no policy is otherwise specified.\n*   `origin` means that the referrer will be the origin of the page, which is roughly the scheme, the host, and the port.\n*   `origin-when-cross-origin` means that navigating to other origins will be limited to the scheme, the host, and the port, while navigating on the same origin will include the referrer\'s path.\n*   `unsafe-url` means that the referrer will include the origin and the path (but not the fragment, password, or username). This case is unsafe because it can leak origins and paths from TLS-protected resources to insecure origins.'
            },
            {
              "name": "title",
              "description": 'The `title` attribute has special semantics on the `<link>` element. When used on a `<link rel="stylesheet">` it defines a [preferred or an alternate stylesheet](https://developer.mozilla.org/en-US/docs/Web/CSS/Alternative_style_sheets). Incorrectly using it may [cause the stylesheet to be ignored](https://developer.mozilla.org/en-US/docs/Correctly_Using_Titles_With_External_Stylesheets).'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/link"
            }
          ]
        },
        {
          "name": "meta",
          "description": {
            "kind": "markdown",
            "value": "The meta element represents various kinds of metadata that cannot be expressed using the title, base, link, style, and script elements."
          },
          "attributes": [
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": 'This attribute defines the name of a piece of document-level metadata. It should not be set if one of the attributes [`itemprop`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-itemprop), [`http-equiv`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv) or [`charset`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-charset) is also set.\n\nThis metadata name is associated with the value contained by the [`content`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-content) attribute. The possible values for the name attribute are:\n\n*   `application-name` which defines the name of the application running in the web page.\n    \n    **Note:**\n    \n    *   Browsers may use this to identify the application. It is different from the [`<title>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title "The HTML Title element (<title>) defines the document\'s title that is shown in a browser\'s title bar or a page\'s tab.") element, which usually contain the application name, but may also contain information like the document name or a status.\n    *   Simple web pages shouldn\'t define an application-name.\n    \n*   `author` which defines the name of the document\'s author.\n*   `description` which contains a short and accurate summary of the content of the page. Several browsers, like Firefox and Opera, use this as the default description of bookmarked pages.\n*   `generator` which contains the identifier of the software that generated the page.\n*   `keywords` which contains words relevant to the page\'s content separated by commas.\n*   `referrer` which controls the [`Referer` HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) attached to requests sent from the document:\n    \n    Values for the `content` attribute of `<meta name="referrer">`\n    \n    `no-referrer`\n    \n    Do not send a HTTP `Referrer` header.\n    \n    `origin`\n    \n    Send the [origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) of the document.\n    \n    `no-referrer-when-downgrade`\n    \n    Send the [origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) as a referrer to URLs as secure as the current page, (https\u2192https), but does not send a referrer to less secure URLs (https\u2192http). This is the default behaviour.\n    \n    `origin-when-cross-origin`\n    \n    Send the full URL (stripped of parameters) for same-origin requests, but only send the [origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) for other cases.\n    \n    `same-origin`\n    \n    A referrer will be sent for [same-site origins](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy), but cross-origin requests will contain no referrer information.\n    \n    `strict-origin`\n    \n    Only send the origin of the document as the referrer to a-priori as-much-secure destination (HTTPS->HTTPS), but don\'t send it to a less secure destination (HTTPS->HTTP).\n    \n    `strict-origin-when-cross-origin`\n    \n    Send a full URL when performing a same-origin request, only send the origin of the document to a-priori as-much-secure destination (HTTPS->HTTPS), and send no header to a less secure destination (HTTPS->HTTP).\n    \n    `unsafe-URL`\n    \n    Send the full URL (stripped of parameters) for same-origin or cross-origin requests.\n    \n    **Notes:**\n    \n    *   Some browsers support the deprecated values of `always`, `default`, and `never` for referrer.\n    *   Dynamically inserting `<meta name="referrer">` (with [`document.write`](https://developer.mozilla.org/en-US/docs/Web/API/Document/write) or [`appendChild`](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)) makes the referrer behaviour unpredictable.\n    *   When several conflicting policies are defined, the no-referrer policy is applied.\n    \n\nThis attribute may also have a value taken from the extended list defined on [WHATWG Wiki MetaExtensions page](https://wiki.whatwg.org/wiki/MetaExtensions). Although none have been formally accepted yet, a few commonly used names are:\n\n*   `creator` which defines the name of the creator of the document, such as an organization or institution. If there are more than one, several [`<meta>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta "The HTML <meta> element represents metadata that cannot be represented by other HTML meta-related elements, like <base>, <link>, <script>, <style> or <title>.") elements should be used.\n*   `googlebot`, a synonym of `robots`, is only followed by Googlebot (the indexing crawler for Google).\n*   `publisher` which defines the name of the document\'s publisher.\n*   `robots` which defines the behaviour that cooperative crawlers, or "robots", should use with the page. It is a comma-separated list of the values below:\n    \n    Values for the content of `<meta name="robots">`\n    \n    Value\n    \n    Description\n    \n    Used by\n    \n    `index`\n    \n    Allows the robot to index the page (default).\n    \n    All\n    \n    `noindex`\n    \n    Requests the robot to not index the page.\n    \n    All\n    \n    `follow`\n    \n    Allows the robot to follow the links on the page (default).\n    \n    All\n    \n    `nofollow`\n    \n    Requests the robot to not follow the links on the page.\n    \n    All\n    \n    `none`\n    \n    Equivalent to `noindex, nofollow`\n    \n    [Google](https://support.google.com/webmasters/answer/79812)\n    \n    `noodp`\n    \n    Prevents using the [Open Directory Project](https://www.dmoz.org/) description, if any, as the page description in search engine results.\n    \n    [Google](https://support.google.com/webmasters/answer/35624#nodmoz), [Yahoo](https://help.yahoo.com/kb/search-for-desktop/meta-tags-robotstxt-yahoo-search-sln2213.html#cont5), [Bing](https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240)\n    \n    `noarchive`\n    \n    Requests the search engine not to cache the page content.\n    \n    [Google](https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives), [Yahoo](https://help.yahoo.com/kb/search-for-desktop/SLN2213.html), [Bing](https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240)\n    \n    `nosnippet`\n    \n    Prevents displaying any description of the page in search engine results.\n    \n    [Google](https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives), [Bing](https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240)\n    \n    `noimageindex`\n    \n    Requests this page not to appear as the referring page of an indexed image.\n    \n    [Google](https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag#valid-indexing--serving-directives)\n    \n    `nocache`\n    \n    Synonym of `noarchive`.\n    \n    [Bing](https://www.bing.com/webmaster/help/which-robots-metatags-does-bing-support-5198d240)\n    \n    **Notes:**\n    \n    *   Only cooperative robots follow these rules. Do not expect to prevent e-mail harvesters with them.\n    *   The robot still needs to access the page in order to read these rules. To prevent bandwidth consumption, use a _[robots.txt](https://developer.mozilla.org/en-US/docs/Glossary/robots.txt "robots.txt: Robots.txt is a file which is usually placed in the root of any website. It decides whether\xA0crawlers are permitted or forbidden access to the web site.")_ file.\n    *   If you want to remove a page, `noindex` will work, but only after the robot visits the page again. Ensure that the `robots.txt` file is not preventing revisits.\n    *   Some values are mutually exclusive, like `index` and `noindex`, or `follow` and `nofollow`. In these cases the robot\'s behaviour is undefined and may vary between them.\n    *   Some crawler robots, like Google, Yahoo and Bing, support the same values for the HTTP header `X-Robots-Tag`; this allows non-HTML documents like images to use these rules.\n    \n*   `slurp`, is a synonym of `robots`, but only for Slurp - the crawler for Yahoo Search.\n*   `viewport`, which gives hints about the size of the initial size of the [viewport](https://developer.mozilla.org/en-US/docs/Glossary/viewport "viewport: A viewport represents a polygonal (normally rectangular) area in computer graphics that is currently being viewed. In web browser terms, it refers to the part of the document you\'re viewing which is currently visible in its window (or the screen, if the document is being viewed in full screen mode). Content outside the viewport is not visible onscreen until scrolled into view."). Used by mobile devices only.\n    \n    Values for the content of `<meta name="viewport">`\n    \n    Value\n    \n    Possible subvalues\n    \n    Description\n    \n    `width`\n    \n    A positive integer number, or the text `device-width`\n    \n    Defines the pixel width of the viewport that you want the web site to be rendered at.\n    \n    `height`\n    \n    A positive integer, or the text `device-height`\n    \n    Defines the height of the viewport. Not used by any browser.\n    \n    `initial-scale`\n    \n    A positive number between `0.0` and `10.0`\n    \n    Defines the ratio between the device width (`device-width` in portrait mode or `device-height` in landscape mode) and the viewport size.\n    \n    `maximum-scale`\n    \n    A positive number between `0.0` and `10.0`\n    \n    Defines the maximum amount to zoom in. It must be greater or equal to the `minimum-scale` or the behaviour is undefined. Browser settings can ignore this rule and iOS10+ ignores it by default.\n    \n    `minimum-scale`\n    \n    A positive number between `0.0` and `10.0`\n    \n    Defines the minimum zoom level. It must be smaller or equal to the `maximum-scale` or the behaviour is undefined. Browser settings can ignore this rule and iOS10+ ignores it by default.\n    \n    `user-scalable`\n    \n    `yes` or `no`\n    \n    If set to `no`, the user is not able to zoom in the webpage. The default is `yes`. Browser settings can ignore this rule, and iOS10+ ignores it by default.\n    \n    Specification\n    \n    Status\n    \n    Comment\n    \n    [CSS Device Adaptation  \n    The definition of \'<meta name="viewport">\' in that specification.](https://drafts.csswg.org/css-device-adapt/#viewport-meta)\n    \n    Working Draft\n    \n    Non-normatively describes the Viewport META element\n    \n    See also: [`@viewport`](https://developer.mozilla.org/en-US/docs/Web/CSS/@viewport "The @viewport CSS at-rule lets you configure the viewport through which the document is viewed. It\'s primarily used for mobile devices, but is also used by desktop browsers that support features like "snap to edge" (such as Microsoft Edge).")\n    \n    **Notes:**\n    \n    *   Though unstandardized, this declaration is respected by most mobile browsers due to de-facto dominance.\n    *   The default values may vary between devices and browsers.\n    *   To learn about this declaration in Firefox for Mobile, see [this article](https://developer.mozilla.org/en-US/docs/Mobile/Viewport_meta_tag "Mobile/Viewport meta tag").'
              }
            },
            {
              "name": "http-equiv",
              "description": {
                "kind": "markdown",
                "value": 'Defines a pragma directive. The attribute is named `**http-equiv**(alent)` because all the allowed values are names of particular HTTP headers:\n\n*   `"content-language"`  \n    Defines the default language of the page. It can be overridden by the [lang](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang) attribute on any element.\n    \n    **Warning:** Do not use this value, as it is obsolete. Prefer the `lang` attribute on the [`<html>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html "The HTML <html> element represents the root (top-level element) of an HTML document, so it is also referred to as the root element. All other elements must be descendants of this element.") element.\n    \n*   `"content-security-policy"`  \n    Allows page authors to define a [content policy](https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives) for the current page. Content policies mostly specify allowed server origins and script endpoints which help guard against cross-site scripting attacks.\n*   `"content-type"`  \n    Defines the [MIME type](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type) of the document, followed by its character encoding. It follows the same syntax as the HTTP `content-type` entity-header field, but as it is inside a HTML page, most values other than `text/html` are impossible. Therefore the valid syntax for its `content` is the string \'`text/html`\' followed by a character set with the following syntax: \'`; charset=_IANAcharset_`\', where `IANAcharset` is the _preferred MIME name_ for a character set as [defined by the IANA.](https://www.iana.org/assignments/character-sets)\n    \n    **Warning:** Do not use this value, as it is obsolete. Use the [`charset`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-charset) attribute on the [`<meta>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta "The HTML <meta> element represents metadata that cannot be represented by other HTML meta-related elements, like <base>, <link>, <script>, <style> or <title>.") element.\n    \n    **Note:** As [`<meta>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta "The HTML <meta> element represents metadata that cannot be represented by other HTML meta-related elements, like <base>, <link>, <script>, <style> or <title>.") can\'t change documents\' types in XHTML or HTML5\'s XHTML serialization, never set the MIME type to an XHTML MIME type with `<meta>`.\n    \n*   `"refresh"`  \n    This instruction specifies:\n    *   The number of seconds until the page should be reloaded - only if the [`content`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-content) attribute contains a positive integer.\n    *   The number of seconds until the page should redirect to another - only if the [`content`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-content) attribute contains a positive integer followed by the string \'`;url=`\', and a valid URL.\n*   `"set-cookie"`  \n    Defines a [cookie](https://developer.mozilla.org/en-US/docs/cookie) for the page. Its content must follow the syntax defined in the [IETF HTTP Cookie Specification](https://tools.ietf.org/html/draft-ietf-httpstate-cookie-14).\n    \n    **Warning:** Do not use this instruction, as it is obsolete. Use the HTTP header [`Set-Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) instead.'
              }
            },
            {
              "name": "content",
              "description": {
                "kind": "markdown",
                "value": "This attribute contains the value for the [`http-equiv`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv) or [`name`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name) attribute, depending on which is used."
              }
            },
            {
              "name": "charset",
              "description": {
                "kind": "markdown",
                "value": 'This attribute declares the page\'s character encoding. It must contain a [standard IANA MIME name for character encodings](https://www.iana.org/assignments/character-sets). Although the standard doesn\'t request a specific encoding, it suggests:\n\n*   Authors are encouraged to use [`UTF-8`](https://developer.mozilla.org/en-US/docs/Glossary/UTF-8).\n*   Authors should not use ASCII-incompatible encodings to avoid security risk: browsers not supporting them may interpret harmful content as HTML. This happens with the `JIS_C6226-1983`, `JIS_X0212-1990`, `HZ-GB-2312`, `JOHAB`, the ISO-2022 family and the EBCDIC family.\n\n**Note:** ASCII-incompatible encodings are those that don\'t map the 8-bit code points `0x20` to `0x7E` to the `0x0020` to `0x007E` Unicode code points)\n\n*   Authors **must not** use `CESU-8`, `UTF-7`, `BOCU-1` and/or `SCSU` as [cross-site scripting](https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting) attacks with these encodings have been demonstrated.\n*   Authors should not use `UTF-32` because not all HTML5 encoding algorithms can distinguish it from `UTF-16`.\n\n**Notes:**\n\n*   The declared character encoding must match the one the page was saved with to avoid garbled characters and security holes.\n*   The [`<meta>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta "The HTML <meta> element represents metadata that cannot be represented by other HTML meta-related elements, like <base>, <link>, <script>, <style> or <title>.") element declaring the encoding must be inside the [`<head>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head "The HTML <head> element provides general information (metadata) about the document, including its title and links to its\xA0scripts and style sheets.") element and **within the first 1024 bytes** of the HTML as some browsers only look at those bytes before choosing an encoding.\n*   This [`<meta>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta "The HTML <meta> element represents metadata that cannot be represented by other HTML meta-related elements, like <base>, <link>, <script>, <style> or <title>.") element is only one part of the [algorithm to determine a page\'s character set](https://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#encoding-sniffing-algorithm "Algorithm charset page"). The [`Content-Type` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) and any [Byte-Order Marks](https://developer.mozilla.org/en-US/docs/Glossary/Byte-Order_Mark "The definition of that term (Byte-Order Marks) has not been written yet; please consider contributing it!") override this element.\n*   It is strongly recommended to define the character encoding. If a page\'s encoding is undefined, cross-scripting techniques are possible, such as the [`UTF-7` fallback cross-scripting technique](https://code.google.com/p/doctype-mirror/wiki/ArticleUtf7).\n*   The [`<meta>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta "The HTML <meta> element represents metadata that cannot be represented by other HTML meta-related elements, like <base>, <link>, <script>, <style> or <title>.") element with a `charset` attribute is a synonym for the pre-HTML5 `<meta http-equiv="Content-Type" content="text/html; charset=_IANAcharset_">`, where _`IANAcharset`_ contains the value of the equivalent [`charset`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-charset) attribute. This syntax is still allowed, although no longer recommended.'
              }
            },
            {
              "name": "scheme",
              "description": "This attribute defines the scheme in which metadata is described. A scheme is a context leading to the correct interpretations of the [`content`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-content) value, like a format.\n\n**Warning:** Do not use this value, as it is obsolete. There is no replacement as there was no real usage for it."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/meta"
            }
          ]
        },
        {
          "name": "style",
          "description": {
            "kind": "markdown",
            "value": "The style element allows authors to embed style information in their documents. The style element is one of several inputs to the styling processing model. The element does not represent content for the user."
          },
          "attributes": [
            {
              "name": "media",
              "description": {
                "kind": "markdown",
                "value": "This attribute defines which media the style should be applied to. Its value is a [media query](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Media_queries), which defaults to `all` if the attribute is missing."
              }
            },
            {
              "name": "nonce",
              "description": {
                "kind": "markdown",
                "value": "A cryptographic nonce (number used once) used to whitelist inline styles in a [style-src Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src). The server must generate a unique nonce value each time it transmits a policy. It is critical to provide a nonce that cannot be guessed as bypassing a resource\u2019s policy is otherwise trivial."
              }
            },
            {
              "name": "type",
              "description": {
                "kind": "markdown",
                "value": "This attribute defines the styling language as a MIME type (charset should not be specified). This attribute is optional and defaults to `text/css` if it is not specified \u2014 there is very little reason to include this in modern web documents."
              }
            },
            {
              "name": "scoped",
              "valueSet": "v"
            },
            {
              "name": "title",
              "description": "This attribute specifies [alternative style sheet](https://developer.mozilla.org/en-US/docs/Web/CSS/Alternative_style_sheets) sets."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/style"
            }
          ]
        },
        {
          "name": "body",
          "description": {
            "kind": "markdown",
            "value": "The body element represents the content of the document."
          },
          "attributes": [
            {
              "name": "onafterprint",
              "description": {
                "kind": "markdown",
                "value": "Function to call after the user has printed the document."
              }
            },
            {
              "name": "onbeforeprint",
              "description": {
                "kind": "markdown",
                "value": "Function to call when the user requests printing of the document."
              }
            },
            {
              "name": "onbeforeunload",
              "description": {
                "kind": "markdown",
                "value": "Function to call when the document is about to be unloaded."
              }
            },
            {
              "name": "onhashchange",
              "description": {
                "kind": "markdown",
                "value": "Function to call when the fragment identifier part (starting with the hash (`'#'`) character) of the document's current address has changed."
              }
            },
            {
              "name": "onlanguagechange",
              "description": {
                "kind": "markdown",
                "value": "Function to call when the preferred languages changed."
              }
            },
            {
              "name": "onmessage",
              "description": {
                "kind": "markdown",
                "value": "Function to call when the document has received a message."
              }
            },
            {
              "name": "onoffline",
              "description": {
                "kind": "markdown",
                "value": "Function to call when network communication has failed."
              }
            },
            {
              "name": "ononline",
              "description": {
                "kind": "markdown",
                "value": "Function to call when network communication has been restored."
              }
            },
            {
              "name": "onpagehide"
            },
            {
              "name": "onpageshow"
            },
            {
              "name": "onpopstate",
              "description": {
                "kind": "markdown",
                "value": "Function to call when the user has navigated session history."
              }
            },
            {
              "name": "onstorage",
              "description": {
                "kind": "markdown",
                "value": "Function to call when the storage area has changed."
              }
            },
            {
              "name": "onunload",
              "description": {
                "kind": "markdown",
                "value": "Function to call when the document is going away."
              }
            },
            {
              "name": "alink",
              "description": 'Color of text for hyperlinks when selected. _This method is non-conforming, use CSS [`color`](https://developer.mozilla.org/en-US/docs/Web/CSS/color "The color CSS property sets the foreground color value of an element\'s text and text decorations, and sets the currentcolor value.") property in conjunction with the [`:active`](https://developer.mozilla.org/en-US/docs/Web/CSS/:active "The :active CSS pseudo-class represents an element (such as a button) that is being activated by the user.") pseudo-class instead._'
            },
            {
              "name": "background",
              "description": 'URI of a image to use as a background. _This method is non-conforming, use CSS [`background`](https://developer.mozilla.org/en-US/docs/Web/CSS/background "The background shorthand CSS property sets all background style properties at once, such as color, image, origin and size, or repeat method.") property on the element instead._'
            },
            {
              "name": "bgcolor",
              "description": 'Background color for the document. _This method is non-conforming, use CSS [`background-color`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-color "The background-color CSS property sets the background color of an element.") property on the element instead._'
            },
            {
              "name": "bottommargin",
              "description": 'The margin of the bottom of the body. _This method is non-conforming, use CSS [`margin-bottom`](https://developer.mozilla.org/en-US/docs/Web/CSS/margin-bottom "The margin-bottom CSS property sets the margin area on the bottom of an element. A positive value places it farther from its neighbors, while a negative value places it closer.") property on the element instead._'
            },
            {
              "name": "leftmargin",
              "description": 'The margin of the left of the body. _This method is non-conforming, use CSS [`margin-left`](https://developer.mozilla.org/en-US/docs/Web/CSS/margin-left "The margin-left CSS property sets the margin area on the left side of an element. A positive value places it farther from its neighbors, while a negative value places it closer.") property on the element instead._'
            },
            {
              "name": "link",
              "description": 'Color of text for unvisited hypertext links. _This method is non-conforming, use CSS [`color`](https://developer.mozilla.org/en-US/docs/Web/CSS/color "The color CSS property sets the foreground color value of an element\'s text and text decorations, and sets the currentcolor value.") property in conjunction with the [`:link`](https://developer.mozilla.org/en-US/docs/Web/CSS/:link "The :link CSS pseudo-class represents an element that has not yet been visited. It matches every unvisited <a>, <area>, or <link> element that has an href attribute.") pseudo-class instead._'
            },
            {
              "name": "onblur",
              "description": "Function to call when the document loses focus."
            },
            {
              "name": "onerror",
              "description": "Function to call when the document fails to load properly."
            },
            {
              "name": "onfocus",
              "description": "Function to call when the document receives focus."
            },
            {
              "name": "onload",
              "description": "Function to call when the document has finished loading."
            },
            {
              "name": "onredo",
              "description": "Function to call when the user has moved forward in undo transaction history."
            },
            {
              "name": "onresize",
              "description": "Function to call when the document has been resized."
            },
            {
              "name": "onundo",
              "description": "Function to call when the user has moved backward in undo transaction history."
            },
            {
              "name": "rightmargin",
              "description": 'The margin of the right of the body. _This method is non-conforming, use CSS [`margin-right`](https://developer.mozilla.org/en-US/docs/Web/CSS/margin-right "The margin-right CSS property sets the margin area on the right side of an element. A positive value places it farther from its neighbors, while a negative value places it closer.") property on the element instead._'
            },
            {
              "name": "text",
              "description": 'Foreground color of text. _This method is non-conforming, use CSS [`color`](https://developer.mozilla.org/en-US/docs/Web/CSS/color "The color CSS property sets the foreground color value of an element\'s text and text decorations, and sets the currentcolor value.") property on the element instead._'
            },
            {
              "name": "topmargin",
              "description": 'The margin of the top of the body. _This method is non-conforming, use CSS [`margin-top`](https://developer.mozilla.org/en-US/docs/Web/CSS/margin-top "The margin-top CSS property sets the margin area on the top of an element. A positive value places it farther from its neighbors, while a negative value places it closer.") property on the element instead._'
            },
            {
              "name": "vlink",
              "description": 'Color of text for visited hypertext links. _This method is non-conforming, use CSS [`color`](https://developer.mozilla.org/en-US/docs/Web/CSS/color "The color CSS property sets the foreground color value of an element\'s text and text decorations, and sets the currentcolor value.") property in conjunction with the [`:visited`](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited "The :visited CSS pseudo-class represents links that the user has already visited. For privacy reasons, the styles that can be modified using this selector are very limited.") pseudo-class instead._'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/body"
            }
          ]
        },
        {
          "name": "article",
          "description": {
            "kind": "markdown",
            "value": "The article element represents a complete, or self-contained, composition in a document, page, application, or site and that is, in principle, independently distributable or reusable, e.g. in syndication. This could be a forum post, a magazine or newspaper article, a blog entry, a user-submitted comment, an interactive widget or gadget, or any other independent item of content. Each article should be identified, typically by including a heading (h1\u2013h6 element) as a child of the article element."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/article"
            }
          ]
        },
        {
          "name": "section",
          "description": {
            "kind": "markdown",
            "value": "The section element represents a generic section of a document or application. A section, in this context, is a thematic grouping of content. Each section should be identified, typically by including a heading ( h1- h6 element) as a child of the section element."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/section"
            }
          ]
        },
        {
          "name": "nav",
          "description": {
            "kind": "markdown",
            "value": "The nav element represents a section of a page that links to other pages or to parts within the page: a section with navigation links."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/nav"
            }
          ]
        },
        {
          "name": "aside",
          "description": {
            "kind": "markdown",
            "value": "The aside element represents a section of a page that consists of content that is tangentially related to the content around the aside element, and which could be considered separate from that content. Such sections are often represented as sidebars in printed typography."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/aside"
            }
          ]
        },
        {
          "name": "h1",
          "description": {
            "kind": "markdown",
            "value": "The h1 element represents a section heading."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/Heading_Elements"
            }
          ]
        },
        {
          "name": "h2",
          "description": {
            "kind": "markdown",
            "value": "The h2 element represents a section heading."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/Heading_Elements"
            }
          ]
        },
        {
          "name": "h3",
          "description": {
            "kind": "markdown",
            "value": "The h3 element represents a section heading."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/Heading_Elements"
            }
          ]
        },
        {
          "name": "h4",
          "description": {
            "kind": "markdown",
            "value": "The h4 element represents a section heading."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/Heading_Elements"
            }
          ]
        },
        {
          "name": "h5",
          "description": {
            "kind": "markdown",
            "value": "The h5 element represents a section heading."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/Heading_Elements"
            }
          ]
        },
        {
          "name": "h6",
          "description": {
            "kind": "markdown",
            "value": "The h6 element represents a section heading."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/Heading_Elements"
            }
          ]
        },
        {
          "name": "header",
          "description": {
            "kind": "markdown",
            "value": "The header element represents introductory content for its nearest ancestor sectioning content or sectioning root element. A header typically contains a group of introductory or navigational aids. When the nearest ancestor sectioning content or sectioning root element is the body element, then it applies to the whole page."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/header"
            }
          ]
        },
        {
          "name": "footer",
          "description": {
            "kind": "markdown",
            "value": "The footer element represents a footer for its nearest ancestor sectioning content or sectioning root element. A footer typically contains information about its section such as who wrote it, links to related documents, copyright data, and the like."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/footer"
            }
          ]
        },
        {
          "name": "address",
          "description": {
            "kind": "markdown",
            "value": "The address element represents the contact information for its nearest article or body element ancestor. If that is the body element, then the contact information applies to the document as a whole."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/address"
            }
          ]
        },
        {
          "name": "p",
          "description": {
            "kind": "markdown",
            "value": "The p element represents a paragraph."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/p"
            }
          ]
        },
        {
          "name": "hr",
          "description": {
            "kind": "markdown",
            "value": "The hr element represents a paragraph-level thematic break, e.g. a scene change in a story, or a transition to another topic within a section of a reference book."
          },
          "attributes": [
            {
              "name": "align",
              "description": "Sets the alignment of the rule on the page. If no value is specified, the default value is `left`."
            },
            {
              "name": "color",
              "description": "Sets the color of the rule through color name or hexadecimal value."
            },
            {
              "name": "noshade",
              "description": "Sets the rule to have no shading."
            },
            {
              "name": "size",
              "description": "Sets the height, in pixels, of the rule."
            },
            {
              "name": "width",
              "description": "Sets the length of the rule on the page through a pixel or percentage value."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/hr"
            }
          ]
        },
        {
          "name": "pre",
          "description": {
            "kind": "markdown",
            "value": "The pre element represents a block of preformatted text, in which structure is represented by typographic conventions rather than by elements."
          },
          "attributes": [
            {
              "name": "cols",
              "description": 'Contains the _preferred_ count of characters that a line should have. It was a non-standard synonym of [`width`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre#attr-width). To achieve such an effect, use CSS [`width`](https://developer.mozilla.org/en-US/docs/Web/CSS/width "The width CSS property sets an element\'s width. By default it sets the width of the content area, but if box-sizing is set to border-box, it sets the width of the border area.") instead.'
            },
            {
              "name": "width",
              "description": 'Contains the _preferred_ count of characters that a line should have. Though technically still implemented, this attribute has no visual effect; to achieve such an effect, use CSS [`width`](https://developer.mozilla.org/en-US/docs/Web/CSS/width "The width CSS property sets an element\'s width. By default it sets the width of the content area, but if box-sizing is set to border-box, it sets the width of the border area.") instead.'
            },
            {
              "name": "wrap",
              "description": 'Is a _hint_ indicating how the overflow must happen. In modern browser this hint is ignored and no visual effect results in its present; to achieve such an effect, use CSS [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space "The white-space CSS property sets how white space inside an element is handled.") instead.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/pre"
            }
          ]
        },
        {
          "name": "blockquote",
          "description": {
            "kind": "markdown",
            "value": "The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations."
          },
          "attributes": [
            {
              "name": "cite",
              "description": {
                "kind": "markdown",
                "value": "A URL that designates a source document or message for the information quoted. This attribute is intended to point to information explaining the context or the reference for the quote."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/blockquote"
            }
          ]
        },
        {
          "name": "ol",
          "description": {
            "kind": "markdown",
            "value": "The ol element represents a list of items, where the items have been intentionally ordered, such that changing the order would change the meaning of the document."
          },
          "attributes": [
            {
              "name": "reversed",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute specifies that the items of the list are specified in reversed order."
              }
            },
            {
              "name": "start",
              "description": {
                "kind": "markdown",
                "value": 'This integer attribute specifies the start value for numbering the individual list items. Although the ordering type of list elements might be Roman numerals, such as XXXI, or letters, the value of start is always represented as a number. To start numbering elements from the letter "C", use `<ol start="3">`.\n\n**Note**: This attribute was deprecated in HTML4, but reintroduced in HTML5.'
              }
            },
            {
              "name": "type",
              "valueSet": "lt",
              "description": {
                "kind": "markdown",
                "value": "Indicates the numbering type:\n\n*   `'a'` indicates lowercase letters,\n*   `'A'` indicates uppercase letters,\n*   `'i'` indicates lowercase Roman numerals,\n*   `'I'` indicates uppercase Roman numerals,\n*   and `'1'` indicates numbers (default).\n\nThe type set is used for the entire list unless a different [`type`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li#attr-type) attribute is used within an enclosed [`<li>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li \"The HTML <li> element is used to represent an item in a list. It must be contained in a parent element: an ordered list (<ol>), an unordered list (<ul>), or a menu (<menu>). In menus and unordered lists, list items are usually displayed using bullet points. In ordered lists, they are usually displayed with an ascending counter on the left, such as a number or letter.\") element.\n\n**Note:** This attribute was deprecated in HTML4, but reintroduced in HTML5.\n\nUnless the value of the list number matters (e.g. in legal or technical documents where items are to be referenced by their number/letter), the CSS [`list-style-type`](https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type \"The list-style-type CSS property sets the marker (such as a disc, character, or custom counter style) of a list item element.\") property should be used instead."
              }
            },
            {
              "name": "compact",
              "description": 'This Boolean attribute hints that the list should be rendered in a compact style. The interpretation of this attribute depends on the user agent and it doesn\'t work in all browsers.\n\n**Warning:** Do not use this attribute, as it has been deprecated: the [`<ol>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol "The HTML <ol> element represents an ordered list of items, typically rendered as a numbered list.") element should be styled using [CSS](https://developer.mozilla.org/en-US/docs/CSS). To give an effect similar to the `compact` attribute, the [CSS](https://developer.mozilla.org/en-US/docs/CSS) property [`line-height`](https://developer.mozilla.org/en-US/docs/Web/CSS/line-height "The line-height CSS property sets the amount of space used for lines, such as in text. On block-level elements, it specifies the minimum height of line boxes within the element. On non-replaced inline elements, it specifies the height that is used to calculate line box height.") can be used with a value of `80%`.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/ol"
            }
          ]
        },
        {
          "name": "ul",
          "description": {
            "kind": "markdown",
            "value": "The ul element represents a list of items, where the order of the items is not important \u2014 that is, where changing the order would not materially change the meaning of the document."
          },
          "attributes": [
            {
              "name": "compact",
              "description": 'This Boolean attribute hints that the list should be rendered in a compact style. The interpretation of this attribute depends on the user agent and it doesn\'t work in all browsers.\n\n**Usage note:\xA0**Do not use this attribute, as it has been deprecated: the [`<ul>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul "The HTML <ul> element represents an unordered list of items, typically rendered as a bulleted list.") element should be styled using [CSS](https://developer.mozilla.org/en-US/docs/CSS). To give a similar effect as the `compact` attribute, the [CSS](https://developer.mozilla.org/en-US/docs/CSS) property [line-height](https://developer.mozilla.org/en-US/docs/CSS/line-height) can be used with a value of `80%`.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/ul"
            }
          ]
        },
        {
          "name": "li",
          "description": {
            "kind": "markdown",
            "value": "The li element represents a list item. If its parent element is an ol, ul, or menu element, then the element is an item of the parent element's list, as defined for those elements. Otherwise, the list item has no defined list-related relationship to any other li element."
          },
          "attributes": [
            {
              "name": "value",
              "description": {
                "kind": "markdown",
                "value": 'This integer attribute indicates the current ordinal value of the list item as defined by the [`<ol>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol "The HTML <ol> element represents an ordered list of items, typically rendered as a numbered list.") element. The only allowed value for this attribute is a number, even if the list is displayed with Roman numerals or letters. List items that follow this one continue numbering from the value set. The **value** attribute has no meaning for unordered lists ([`<ul>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul "The HTML <ul> element represents an unordered list of items, typically rendered as a bulleted list.")) or for menus ([`<menu>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu "The HTML <menu> element represents a group of commands that a user can perform or activate. This includes both list menus, which might appear across the top of a screen, as well as context menus, such as those that might appear underneath a button after it has been clicked.")).\n\n**Note**: This attribute was deprecated in HTML4, but reintroduced in HTML5.\n\n**Note:** Prior to Gecko\xA09.0, negative values were incorrectly converted to 0. Starting in Gecko\xA09.0 all integer values are correctly parsed.'
              }
            },
            {
              "name": "type",
              "description": 'This character attribute indicates the numbering type:\n\n*   `a`: lowercase letters\n*   `A`: uppercase letters\n*   `i`: lowercase Roman numerals\n*   `I`: uppercase Roman numerals\n*   `1`: numbers\n\nThis type overrides the one used by its parent [`<ol>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol "The HTML <ol> element represents an ordered list of items, typically rendered as a numbered list.") element, if any.\n\n**Usage note:** This attribute has been deprecated: use the CSS [`list-style-type`](https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type "The list-style-type CSS property sets the marker (such as a disc, character, or custom counter style) of a list item element.") property instead.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/li"
            }
          ]
        },
        {
          "name": "dl",
          "description": {
            "kind": "markdown",
            "value": "The dl element represents an association list consisting of zero or more name-value groups (a description list). A name-value group consists of one or more names (dt elements) followed by one or more values (dd elements), ignoring any nodes other than dt and dd elements. Within a single dl element, there should not be more than one dt element for each name."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/dl"
            }
          ]
        },
        {
          "name": "dt",
          "description": {
            "kind": "markdown",
            "value": "The dt element represents the term, or name, part of a term-description group in a description list (dl element)."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/dt"
            }
          ]
        },
        {
          "name": "dd",
          "description": {
            "kind": "markdown",
            "value": "The dd element represents the description, definition, or value, part of a term-description group in a description list (dl element)."
          },
          "attributes": [
            {
              "name": "nowrap",
              "description": "If the value of this attribute is set to `yes`, the definition text will not wrap. The default value is `no`."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/dd"
            }
          ]
        },
        {
          "name": "figure",
          "description": {
            "kind": "markdown",
            "value": "The figure element represents some flow content, optionally with a caption, that is self-contained (like a complete sentence) and is typically referenced as a single unit from the main flow of the document."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/figure"
            }
          ]
        },
        {
          "name": "figcaption",
          "description": {
            "kind": "markdown",
            "value": "The figcaption element represents a caption or legend for the rest of the contents of the figcaption element's parent figure element, if any."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/figcaption"
            }
          ]
        },
        {
          "name": "main",
          "description": {
            "kind": "markdown",
            "value": "The main element represents the main content of the body of a document or application. The main content area consists of content that is directly related to or expands upon the central topic of a document or central functionality of an application."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/main"
            }
          ]
        },
        {
          "name": "div",
          "description": {
            "kind": "markdown",
            "value": "The div element has no special meaning at all. It represents its children. It can be used with the class, lang, and title attributes to mark up semantics common to a group of consecutive elements."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/div"
            }
          ]
        },
        {
          "name": "a",
          "description": {
            "kind": "markdown",
            "value": "If the a element has an href attribute, then it represents a hyperlink (a hypertext anchor) labeled by its contents."
          },
          "attributes": [
            {
              "name": "href",
              "description": {
                "kind": "markdown",
                "value": "Contains a URL or a URL fragment that the hyperlink points to."
              }
            },
            {
              "name": "target",
              "description": {
                "kind": "markdown",
                "value": 'Specifies where to display the linked URL. It is a name of, or keyword for, a _browsing context_: a tab, window, or `<iframe>`. The following keywords have special meanings:\n\n*   `_self`: Load the URL into the same browsing context as the current one. This is the default behavior.\n*   `_blank`: Load the URL into a new browsing context. This is usually a tab, but users can configure browsers to use new windows instead.\n*   `_parent`: Load the URL into the parent browsing context of the current one. If there is no parent, this behaves the same way as `_self`.\n*   `_top`: Load the URL into the top-level browsing context (that is, the "highest" browsing context that is an ancestor of the current one, and has no parent). If there is no parent, this behaves the same way as `_self`.\n\n**Note:** When using `target`, consider adding `rel="noreferrer"` to avoid exploitation of the `window.opener` API.\n\n**Note:** Linking to another page using `target="_blank"` will run the new page on the same process as your page. If the new page is executing expensive JS, your page\'s performance may suffer. To avoid this use `rel="noopener"`.'
              }
            },
            {
              "name": "download",
              "description": {
                "kind": "markdown",
                "value": "This attribute instructs browsers to download a URL instead of navigating to it, so the user will be prompted to save it as a local file. If the attribute has a value, it is used as the pre-filled file name in the Save prompt (the user can still change the file name if they want). There are no restrictions on allowed values, though `/` and `\\` are converted to underscores. Most file systems limit some punctuation in file names, and browsers will adjust the suggested name accordingly.\n\n**Notes:**\n\n*   This attribute only works for [same-origin URLs](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy).\n*   Although HTTP(s) URLs need to be in the same-origin, [`blob:` URLs](https://developer.mozilla.org/en-US/docs/Web/API/URL.createObjectURL) and [`data:` URLs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) are allowed so that content generated by JavaScript, such as pictures created in an image-editor Web app, can be downloaded.\n*   If the HTTP header [`Content-Disposition:`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) gives a different filename than this attribute, the HTTP header takes priority over this attribute.\n*   If `Content-Disposition:` is set to `inline`, Firefox prioritizes `Content-Disposition`, like the filename case, while Chrome prioritizes the `download` attribute."
              }
            },
            {
              "name": "ping",
              "description": {
                "kind": "markdown",
                "value": 'Contains a space-separated list of URLs to which, when the hyperlink is followed, [`POST`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST "The HTTP POST method sends data to the server. The type of the body of the request is indicated by the Content-Type header.") requests with the body `PING` will be sent by the browser (in the background). Typically used for tracking.'
              }
            },
            {
              "name": "rel",
              "description": {
                "kind": "markdown",
                "value": "Specifies the relationship of the target object to the link object. The value is a space-separated list of [link types](https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types)."
              }
            },
            {
              "name": "hreflang",
              "description": {
                "kind": "markdown",
                "value": 'This attribute indicates the human language of the linked resource. It is purely advisory, with no built-in functionality. Allowed values are determined by [BCP47](https://www.ietf.org/rfc/bcp/bcp47.txt "Tags for Identifying Languages").'
              }
            },
            {
              "name": "type",
              "description": {
                "kind": "markdown",
                "value": 'Specifies the media type in the form of a [MIME type](https://developer.mozilla.org/en-US/docs/Glossary/MIME_type "MIME type: A\xA0MIME type\xA0(now properly called "media type", but\xA0also sometimes "content type") is a string sent along\xA0with a file indicating the type of the file (describing the content format, for example, a sound file might be labeled\xA0audio/ogg, or an image file\xA0image/png).") for the linked URL. It is purely advisory, with no built-in functionality.'
              }
            },
            {
              "name": "referrerpolicy",
              "description": "Indicates which [referrer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer) to send when fetching the URL:\n\n*   `'no-referrer'` means the `Referer:` header will not be sent.\n*   `'no-referrer-when-downgrade'` means no `Referer:` header will be sent when navigating to an origin without HTTPS. This is the default behavior.\n*   `'origin'` means the referrer will be the [origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) of the page, not including information after the domain.\n*   `'origin-when-cross-origin'` meaning that navigations to other origins will be limited to the scheme, the host and the port, while navigations on the same origin will include the referrer's path.\n*   `'strict-origin-when-cross-origin'`\n*   `'unsafe-url'` means the referrer will include the origin and path, but not the fragment, password, or username. This is unsafe because it can leak data from secure URLs to insecure ones."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/a"
            }
          ]
        },
        {
          "name": "em",
          "description": {
            "kind": "markdown",
            "value": "The em element represents stress emphasis of its contents."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/em"
            }
          ]
        },
        {
          "name": "strong",
          "description": {
            "kind": "markdown",
            "value": "The strong element represents strong importance, seriousness, or urgency for its contents."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/strong"
            }
          ]
        },
        {
          "name": "small",
          "description": {
            "kind": "markdown",
            "value": "The small element represents side comments such as small print."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/small"
            }
          ]
        },
        {
          "name": "s",
          "description": {
            "kind": "markdown",
            "value": "The s element represents contents that are no longer accurate or no longer relevant."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/s"
            }
          ]
        },
        {
          "name": "cite",
          "description": {
            "kind": "markdown",
            "value": "The cite element represents a reference to a creative work. It must include the title of the work or the name of the author(person, people or organization) or an URL reference, or a reference in abbreviated form as per the conventions used for the addition of citation metadata."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/cite"
            }
          ]
        },
        {
          "name": "q",
          "description": {
            "kind": "markdown",
            "value": "The q element represents some phrasing content quoted from another source."
          },
          "attributes": [
            {
              "name": "cite",
              "description": {
                "kind": "markdown",
                "value": "The value of this attribute is a URL that designates a source document or message for the information quoted. This attribute is intended to point to information explaining the context or the reference for the quote."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/q"
            }
          ]
        },
        {
          "name": "dfn",
          "description": {
            "kind": "markdown",
            "value": "The dfn element represents the defining instance of a term. The paragraph, description list group, or section that is the nearest ancestor of the dfn element must also contain the definition(s) for the term given by the dfn element."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/dfn"
            }
          ]
        },
        {
          "name": "abbr",
          "description": {
            "kind": "markdown",
            "value": "The abbr element represents an abbreviation or acronym, optionally with its expansion. The title attribute may be used to provide an expansion of the abbreviation. The attribute, if specified, must contain an expansion of the abbreviation, and nothing else."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/abbr"
            }
          ]
        },
        {
          "name": "ruby",
          "description": {
            "kind": "markdown",
            "value": "The ruby element allows one or more spans of phrasing content to be marked with ruby annotations. Ruby annotations are short runs of text presented alongside base text, primarily used in East Asian typography as a guide for pronunciation or to include other annotations. In Japanese, this form of typography is also known as furigana. Ruby text can appear on either side, and sometimes both sides, of the base text, and it is possible to control its position using CSS. A more complete introduction to ruby can be found in the Use Cases & Exploratory Approaches for Ruby Markup document as well as in CSS Ruby Module Level 1. [RUBY-UC] [CSSRUBY]"
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/ruby"
            }
          ]
        },
        {
          "name": "rb",
          "description": {
            "kind": "markdown",
            "value": "The rb element marks the base text component of a ruby annotation. When it is the child of a ruby element, it doesn't represent anything itself, but its parent ruby element uses it as part of determining what it represents."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/rb"
            }
          ]
        },
        {
          "name": "rt",
          "description": {
            "kind": "markdown",
            "value": "The rt element marks the ruby text component of a ruby annotation. When it is the child of a ruby element or of an rtc element that is itself the child of a ruby element, it doesn't represent anything itself, but its ancestor ruby element uses it as part of determining what it represents."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/rt"
            }
          ]
        },
        {
          "name": "rp",
          "description": {
            "kind": "markdown",
            "value": "The rp element is used to provide fallback text to be shown by user agents that don't support ruby annotations. One widespread convention is to provide parentheses around the ruby text component of a ruby annotation."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/rp"
            }
          ]
        },
        {
          "name": "time",
          "description": {
            "kind": "markdown",
            "value": "The time element represents its contents, along with a machine-readable form of those contents in the datetime attribute. The kind of content is limited to various kinds of dates, times, time-zone offsets, and durations, as described below."
          },
          "attributes": [
            {
              "name": "datetime",
              "description": {
                "kind": "markdown",
                "value": "This attribute indicates the time and/or date of the element and must be in one of the formats described below."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/time"
            }
          ]
        },
        {
          "name": "code",
          "description": {
            "kind": "markdown",
            "value": "The code element represents a fragment of computer code. This could be an XML element name, a file name, a computer program, or any other string that a computer would recognize."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/code"
            }
          ]
        },
        {
          "name": "var",
          "description": {
            "kind": "markdown",
            "value": "The var element represents a variable. This could be an actual variable in a mathematical expression or programming context, an identifier representing a constant, a symbol identifying a physical quantity, a function parameter, or just be a term used as a placeholder in prose."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/var"
            }
          ]
        },
        {
          "name": "samp",
          "description": {
            "kind": "markdown",
            "value": "The samp element represents sample or quoted output from another program or computing system."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/samp"
            }
          ]
        },
        {
          "name": "kbd",
          "description": {
            "kind": "markdown",
            "value": "The kbd element represents user input (typically keyboard input, although it may also be used to represent other input, such as voice commands)."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/kbd"
            }
          ]
        },
        {
          "name": "sub",
          "description": {
            "kind": "markdown",
            "value": "The sub element represents a subscript."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/sub"
            }
          ]
        },
        {
          "name": "sup",
          "description": {
            "kind": "markdown",
            "value": "The sup element represents a superscript."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/sup"
            }
          ]
        },
        {
          "name": "i",
          "description": {
            "kind": "markdown",
            "value": "The i element represents a span of text in an alternate voice or mood, or otherwise offset from the normal prose in a manner indicating a different quality of text, such as a taxonomic designation, a technical term, an idiomatic phrase from another language, transliteration, a thought, or a ship name in Western texts."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/i"
            }
          ]
        },
        {
          "name": "b",
          "description": {
            "kind": "markdown",
            "value": "The b element represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/b"
            }
          ]
        },
        {
          "name": "u",
          "description": {
            "kind": "markdown",
            "value": "The u element represents a span of text with an unarticulated, though explicitly rendered, non-textual annotation, such as labeling the text as being a proper name in Chinese text (a Chinese proper name mark), or labeling the text as being misspelt."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/u"
            }
          ]
        },
        {
          "name": "mark",
          "description": {
            "kind": "markdown",
            "value": "The mark element represents a run of text in one document marked or highlighted for reference purposes, due to its relevance in another context. When used in a quotation or other block of text referred to from the prose, it indicates a highlight that was not originally present but which has been added to bring the reader's attention to a part of the text that might not have been considered important by the original author when the block was originally written, but which is now under previously unexpected scrutiny. When used in the main prose of a document, it indicates a part of the document that has been highlighted due to its likely relevance to the user's current activity."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/mark"
            }
          ]
        },
        {
          "name": "bdi",
          "description": {
            "kind": "markdown",
            "value": "The bdi element represents a span of text that is to be isolated from its surroundings for the purposes of bidirectional text formatting. [BIDI]"
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/bdi"
            }
          ]
        },
        {
          "name": "bdo",
          "description": {
            "kind": "markdown",
            "value": "The bdo element represents explicit text directionality formatting control for its children. It allows authors to override the Unicode bidirectional algorithm by explicitly specifying a direction override. [BIDI]"
          },
          "attributes": [
            {
              "name": "dir",
              "description": "The direction in which text should be rendered in this element's contents. Possible values are:\n\n*   `ltr`: Indicates that the text should go in a left-to-right direction.\n*   `rtl`: Indicates that the text should go in a right-to-left direction."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/bdo"
            }
          ]
        },
        {
          "name": "span",
          "description": {
            "kind": "markdown",
            "value": "The span element doesn't mean anything on its own, but can be useful when used together with the global attributes, e.g. class, lang, or dir. It represents its children."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/span"
            }
          ]
        },
        {
          "name": "br",
          "description": {
            "kind": "markdown",
            "value": "The br element represents a line break."
          },
          "attributes": [
            {
              "name": "clear",
              "description": "Indicates where to begin the next line after the break."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/br"
            }
          ]
        },
        {
          "name": "wbr",
          "description": {
            "kind": "markdown",
            "value": "The wbr element represents a line break opportunity."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/wbr"
            }
          ]
        },
        {
          "name": "ins",
          "description": {
            "kind": "markdown",
            "value": "The ins element represents an addition to the document."
          },
          "attributes": [
            {
              "name": "cite",
              "description": "This attribute defines the URI of a resource that explains the change, such as a link to meeting minutes or a ticket in a troubleshooting system."
            },
            {
              "name": "datetime",
              "description": 'This attribute indicates the time and date of the change and must be a valid date with an optional time string. If the value cannot be parsed as a date with an optional time string, the element does not have an associated time stamp. For the format of the string without a time, see [Format of a valid date string](https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#Format_of_a_valid_date_string "Certain HTML elements use date and/or time values. The formats of the strings that specify these are described in this article.") in [Date and time formats used in HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats "Certain HTML elements use date and/or time values. The formats of the strings that specify these are described in this article."). The format of the string if it includes both date and time is covered in [Format of a valid local date and time string](https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#Format_of_a_valid_local_date_and_time_string "Certain HTML elements use date and/or time values. The formats of the strings that specify these are described in this article.") in [Date and time formats used in HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats "Certain HTML elements use date and/or time values. The formats of the strings that specify these are described in this article.").'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/ins"
            }
          ]
        },
        {
          "name": "del",
          "description": {
            "kind": "markdown",
            "value": "The del element represents a removal from the document."
          },
          "attributes": [
            {
              "name": "cite",
              "description": {
                "kind": "markdown",
                "value": "A URI for a resource that explains the change (for example, meeting minutes)."
              }
            },
            {
              "name": "datetime",
              "description": {
                "kind": "markdown",
                "value": 'This attribute indicates the time and date of the change and must be a valid date string with an optional time. If the value cannot be parsed as a date with an optional time string, the element does not have an associated time stamp. For the format of the string without a time, see [Format of a valid date string](https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#Format_of_a_valid_date_string "Certain HTML elements use date and/or time values. The formats of the strings that specify these are described in this article.") in [Date and time formats used in HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats "Certain HTML elements use date and/or time values. The formats of the strings that specify these are described in this article."). The format of the string if it includes both date and time is covered in [Format of a valid local date and time string](https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#Format_of_a_valid_local_date_and_time_string "Certain HTML elements use date and/or time values. The formats of the strings that specify these are described in this article.") in [Date and time formats used in HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats "Certain HTML elements use date and/or time values. The formats of the strings that specify these are described in this article.").'
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/del"
            }
          ]
        },
        {
          "name": "picture",
          "description": {
            "kind": "markdown",
            "value": "The picture element is a container which provides multiple sources to its contained img element to allow authors to declaratively control or give hints to the user agent about which image resource to use, based on the screen pixel density, viewport size, image format, and other factors. It represents its children."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/picture"
            }
          ]
        },
        {
          "name": "img",
          "description": {
            "kind": "markdown",
            "value": "An img element represents an image."
          },
          "attributes": [
            {
              "name": "alt",
              "description": {
                "kind": "markdown",
                "value": 'This attribute defines an alternative text description of the image.\n\n**Note:** Browsers do not always display the image referenced by the element. This is the case for non-graphical browsers (including those used by people with visual impairments), if the user chooses not to display images, or if the browser cannot display the image because it is invalid or an [unsupported type](#Supported_image_formats). In these cases, the browser may replace the image with the text defined in this element\'s `alt` attribute. You should, for these reasons and others, provide a useful value for `alt` whenever possible.\n\n**Note:** Omitting this attribute altogether indicates that the image is a key part of the content, and no textual equivalent is available. Setting this attribute to an empty string (`alt=""`) indicates that this image is _not_ a key part of the content (decorative), and that non-visual browsers may omit it from rendering.'
              }
            },
            {
              "name": "src",
              "description": {
                "kind": "markdown",
                "value": "The image URL. This attribute is mandatory for the `<img>` element. On browsers supporting `srcset`, `src` is treated like a candidate image with a pixel density descriptor `1x` unless an image with this pixel density descriptor is already defined in `srcset,` or unless `srcset` contains '`w`' descriptors."
              }
            },
            {
              "name": "srcset",
              "description": {
                "kind": "markdown",
                "value": "A list of one or more strings separated by commas indicating a set of possible image sources for the user agent to use. Each string is composed of:\n\n1.  a URL to an image,\n2.  optionally, whitespace followed by one of:\n    *   A width descriptor, or a positive integer directly followed by '`w`'. The width descriptor is divided by the source size given in the `sizes` attribute to calculate the effective pixel density.\n    *   A pixel density descriptor, which is a positive floating point number directly followed by '`x`'.\n\nIf no descriptor is specified, the source is assigned the default descriptor: `1x`.\n\nIt is incorrect to mix width descriptors and pixel density descriptors in the same `srcset` attribute. Duplicate descriptors (for instance, two sources in the same `srcset` which are both described with '`2x`') are also invalid.\n\nThe user agent selects any one of the available sources at its discretion. This provides them with significant leeway to tailor their selection based on things like user preferences or bandwidth conditions. See our [Responsive images](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) tutorial for an example."
              }
            },
            {
              "name": "crossorigin",
              "valueSet": "xo",
              "description": {
                "kind": "markdown",
                "value": 'This enumerated attribute indicates if the fetching of the related image must be done using CORS or not. [CORS-enabled images](https://developer.mozilla.org/en-US/docs/CORS_Enabled_Image) can be reused in the [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas "Use the HTML <canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations.") element without being "[tainted](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image#What_is_a_tainted_canvas)." The allowed values are:'
              }
            },
            {
              "name": "usemap",
              "description": {
                "kind": "markdown",
                "value": 'The partial URL (starting with \'#\') of an [image map](https://developer.mozilla.org/en-US/docs/HTML/Element/map) associated with the element.\n\n**Note:** You cannot use this attribute if the `<img>` element is a descendant of an [`<a>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a "The HTML <a> element (or anchor element) creates a hyperlink to other web pages, files, locations within the same page, email addresses, or any other URL.") or [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") element.'
              }
            },
            {
              "name": "ismap",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'This Boolean attribute indicates that the image is part of a server-side map. If so, the precise coordinates of a click are sent to the server.\n\n**Note:** This attribute is allowed only if the `<img>` element is a descendant of an [`<a>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a "The HTML <a> element (or anchor element) creates a hyperlink to other web pages, files, locations within the same page, email addresses, or any other URL.") element with a valid [`href`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-href) attribute.'
              }
            },
            {
              "name": "width",
              "description": {
                "kind": "markdown",
                "value": "The intrinsic width of the image in pixels."
              }
            },
            {
              "name": "height",
              "description": {
                "kind": "markdown",
                "value": "The intrinsic height of the image in pixels."
              }
            },
            {
              "name": "decoding",
              "description": "Provides an image decoding hint to the browser. The allowed values are:"
            },
            {
              "name": "decoding",
              "description": "`sync`\n\nDecode the image synchronously for atomic presentation with other content.\n\n`async`\n\nDecode the image asynchronously to reduce delay in presenting other content.\n\n`auto`\n\nDefault mode, which indicates no preference for the decoding mode. The browser decides what is best for the user."
            },
            {
              "name": "importance",
              "description": "Indicates the relative importance of the resource. Priority hints are delegated using the values:"
            },
            {
              "name": "importance",
              "description": "`auto`: Indicates\xA0**no\xA0preference**. The browser may use its own heuristics to decide the priority of the image.\n\n`high`: Indicates to the\xA0browser\xA0that the image is of\xA0**high** priority.\n\n`low`:\xA0Indicates to the\xA0browser\xA0that the image is of\xA0**low** priority."
            },
            {
              "name": "intrinsicsize",
              "description": "This attribute tells the browser to ignore the actual intrinsic size of the image and pretend it\u2019s the size specified in the attribute. Specifically, the image would raster at these dimensions and `naturalWidth`/`naturalHeight` on images would return the values specified in this attribute. [Explainer](https://github.com/ojanvafai/intrinsicsize-attribute), [examples](https://googlechrome.github.io/samples/intrinsic-size/index.html)"
            },
            {
              "name": "referrerpolicy",
              "description": "A string indicating which referrer to use when fetching the resource:\n\n*   `no-referrer:` The [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer \"The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.\") header will not be sent.\n*   `no-referrer-when-downgrade:` No `Referer` header will be sent when navigating to an origin without TLS (HTTPS). This is a user agent\u2019s default behavior if no policy is otherwise specified.\n*   `origin:` The `Referer` header will include the page of origin's scheme, the host, and the port.\n*   `origin-when-cross-origin:` Navigating to other origins will limit the included referral data to the scheme, the host and the port, while navigating from the same origin will include the referrer's full path.\n*   `unsafe-url:` The `Referer` header will include the origin and the path, but not the fragment, password, or username. This case is unsafe because it can leak origins and paths from TLS-protected resources to insecure origins."
            },
            {
              "name": "sizes",
              "description": "A list of one or more strings separated by commas indicating a set of source sizes. Each source size consists of:\n\n1.  a media condition. This must be omitted for the last item.\n2.  a source size value.\n\nSource size values specify the intended display size of the image. User agents use the current source size to select one of the sources supplied by the `srcset` attribute, when those sources are described using width ('`w`') descriptors. The selected source size affects the intrinsic size of the image (the image\u2019s display size if no CSS styling is applied). If the `srcset` attribute is absent, or contains no values with a width (`w`) descriptor, then the `sizes` attribute has no effect."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/img"
            }
          ]
        },
        {
          "name": "iframe",
          "description": {
            "kind": "markdown",
            "value": "The iframe element represents a nested browsing context."
          },
          "attributes": [
            {
              "name": "src",
              "description": {
                "kind": "markdown",
                "value": 'The URL of the page to embed. Use a value of `about:blank` to embed an empty page that conforms to the [same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#Inherited_origins). Also note that programatically removing an `<iframe>`\'s src attribute (e.g. via [`Element.removeAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute "The Element method removeAttribute() removes the attribute with the specified name from the element.")) causes `about:blank` to be loaded in the frame in Firefox (from version 65), Chromium-based browsers, and Safari/iOS.'
              }
            },
            {
              "name": "srcdoc",
              "description": {
                "kind": "markdown",
                "value": "Inline HTML to embed, overriding the `src` attribute. If a browser does not support the `srcdoc` attribute, it will fall back to the URL in the `src` attribute."
              }
            },
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": 'A targetable name for the embedded browsing context. This can be used in the `target` attribute of the [`<a>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a "The HTML <a> element (or anchor element) creates a hyperlink to other web pages, files, locations within the same page, email addresses, or any other URL."), [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server."), or [`<base>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base "The HTML <base> element specifies the base URL to use for all relative URLs contained within a document. There can be only one <base> element in a document.") elements; the `formtarget` attribute of the [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") or [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") elements; or the `windowName` parameter in the [`window.open()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/open "The\xA0Window interface\'s open() method loads the specified resource into the browsing context (window, <iframe> or tab) with the specified name. If the name doesn\'t exist, then a new window is opened and the specified resource is loaded into its browsing context.") method.'
              }
            },
            {
              "name": "sandbox",
              "valueSet": "sb",
              "description": {
                "kind": "markdown",
                "value": 'Applies extra restrictions to the content in the frame. The value of the attribute can either be empty to apply all restrictions, or space-separated tokens to lift particular restrictions:\n\n*   `allow-forms`: Allows the resource to submit forms. If this keyword is not used, form submission is blocked.\n*   `allow-modals`: Lets the resource [open modal windows](https://html.spec.whatwg.org/multipage/origin.html#sandboxed-modals-flag).\n*   `allow-orientation-lock`: Lets the resource [lock the screen orientation](https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation).\n*   `allow-pointer-lock`: Lets the resource use the [Pointer Lock API](https://developer.mozilla.org/en-US/docs/WebAPI/Pointer_Lock).\n*   `allow-popups`: Allows popups (such as `window.open()`, `target="_blank"`, or `showModalDialog()`). If this keyword is not used, the popup will silently fail to open.\n*   `allow-popups-to-escape-sandbox`: Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.\n*   `allow-presentation`: Lets the resource start a [presentation session](https://developer.mozilla.org/en-US/docs/Web/API/PresentationRequest).\n*   `allow-same-origin`: If this token is not used, the resource is treated as being from a special origin that always fails the [same-origin policy](https://developer.mozilla.org/en-US/docs/Glossary/same-origin_policy "same-origin policy: The same-origin policy is a critical security mechanism that restricts how a document or script loaded from one origin can interact with a resource from another origin.").\n*   `allow-scripts`: Lets the resource run scripts (but not create popup windows).\n*   `allow-storage-access-by-user-activation` : Lets the resource request access to the parent\'s storage capabilities with the [Storage Access API](https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API).\n*   `allow-top-navigation`: Lets the resource navigate the top-level browsing context (the one named `_top`).\n*   `allow-top-navigation-by-user-activation`: Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.\n\n**Notes about sandboxing:**\n\n*   When the embedded document has the same origin as the embedding page, it is **strongly discouraged** to use both `allow-scripts` and `allow-same-origin`, as that lets the embedded document remove the `sandbox` attribute \u2014 making it no more secure than not using the `sandbox` attribute at all.\n*   Sandboxing is useless if the attacker can display content outside a sandboxed `iframe` \u2014 such as if the viewer opens the frame in a new tab. Such content should be also served from a _separate origin_ to limit potential damage.\n*   The `sandbox` attribute is unsupported in Internet Explorer 9 and earlier.'
              }
            },
            {
              "name": "seamless",
              "valueSet": "v"
            },
            {
              "name": "allowfullscreen",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'Set to `true` if the `<iframe>` can activate fullscreen mode by calling the [`requestFullscreen()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullscreen "The Element.requestFullscreen() method issues an asynchronous request to make the element be displayed in full-screen mode.") method.'
              }
            },
            {
              "name": "width",
              "description": {
                "kind": "markdown",
                "value": "The width of the frame in CSS pixels. Default is `300`."
              }
            },
            {
              "name": "height",
              "description": {
                "kind": "markdown",
                "value": "The height of the frame in CSS pixels. Default is `150`."
              }
            },
            {
              "name": "allow",
              "description": "Specifies a [feature policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Feature_Policy) for the `<iframe>`."
            },
            {
              "name": "allowpaymentrequest",
              "description": "Set to `true` if a cross-origin `<iframe>` should be allowed to invoke the [Payment Request API](https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API)."
            },
            {
              "name": "allowpaymentrequest",
              "description": 'This attribute is considered a legacy attribute and redefined as `allow="payment"`.'
            },
            {
              "name": "csp",
              "description": 'A [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) enforced for the embedded resource. See [`HTMLIFrameElement.csp`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/csp "The csp property of the HTMLIFrameElement interface specifies the Content Security Policy that an embedded document must agree to enforce upon itself.") for details.'
            },
            {
              "name": "importance",
              "description": "The download priority of the resource in the `<iframe>`'s `src` attribute. Allowed values:\n\n`auto` (default)\n\nNo preference. The browser uses its own heuristics to decide the priority of the resource.\n\n`high`\n\nThe resource should be downloaded before other lower-priority page resources.\n\n`low`\n\nThe resource should be downloaded after other higher-priority page resources."
            },
            {
              "name": "referrerpolicy",
              "description": 'Indicates which [referrer](https://developer.mozilla.org/en-US/docs/Web/API/Document/referrer) to send when fetching the frame\'s resource:\n\n*   `no-referrer`: The [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer "The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.") header will not be sent.\n*   `no-referrer-when-downgrade` (default): The [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer "The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.") header will not be sent to [origin](https://developer.mozilla.org/en-US/docs/Glossary/origin "origin: Web content\'s origin is defined by the scheme (protocol), host (domain), and port of the URL used to access it. Two objects have the same origin only when the scheme, host, and port all match.")s without [TLS](https://developer.mozilla.org/en-US/docs/Glossary/TLS "TLS: Transport Layer Security (TLS), previously known as Secure Sockets Layer (SSL), is a protocol used by applications to communicate securely across a network, preventing tampering with and eavesdropping on email, web browsing, messaging, and other protocols.") ([HTTPS](https://developer.mozilla.org/en-US/docs/Glossary/HTTPS "HTTPS: HTTPS (HTTP Secure) is an encrypted version of the HTTP protocol. It usually uses SSL or TLS to encrypt all communication between a client and a server. This secure connection allows clients to safely exchange sensitive data with a server, for example for banking activities or online shopping.")).\n*   `origin`: The sent referrer will be limited to the origin of the referring page: its [scheme](https://developer.mozilla.org/en-US/docs/Archive/Mozilla/URIScheme), [host](https://developer.mozilla.org/en-US/docs/Glossary/host "host: A host is a device connected to the Internet (or a local network). Some hosts called servers offer additional services like serving webpages or storing files and emails."), and [port](https://developer.mozilla.org/en-US/docs/Glossary/port "port: For a computer connected to a network with an IP address, a port is a communication endpoint. Ports are designated by numbers, and below 1024 each port is associated by default with a specific protocol.").\n*   `origin-when-cross-origin`: The referrer sent to other origins will be limited to the scheme, the host, and the port. Navigations on the same origin will still include the path.\n*   `same-origin`: A referrer will be sent for [same origin](https://developer.mozilla.org/en-US/docs/Glossary/Same-origin_policy "same origin: The same-origin policy is a critical security mechanism that restricts how a document or script loaded from one origin can interact with a resource from another origin."), but cross-origin requests will contain no referrer information.\n*   `strict-origin`: Only send the origin of the document as the referrer when the protocol security level stays the same (HTTPS\u2192HTTPS), but don\'t send it to a less secure destination (HTTPS\u2192HTTP).\n*   `strict-origin-when-cross-origin`: Send a full URL when performing a same-origin request, only send the origin when the protocol security level stays the same (HTTPS\u2192HTTPS), and send no header to a less secure destination (HTTPS\u2192HTTP).\n*   `unsafe-url`: The referrer will include the origin _and_ the path (but not the [fragment](https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash), [password](https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/password), or [username](https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/username)). **This value is unsafe**, because it leaks origins and paths from TLS-protected resources to insecure origins.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/iframe"
            }
          ]
        },
        {
          "name": "embed",
          "description": {
            "kind": "markdown",
            "value": "The embed element provides an integration point for an external (typically non-HTML) application or interactive content."
          },
          "attributes": [
            {
              "name": "src",
              "description": {
                "kind": "markdown",
                "value": "The URL\xA0of the resource being embedded."
              }
            },
            {
              "name": "type",
              "description": {
                "kind": "markdown",
                "value": "The MIME\xA0type to use to select the plug-in to instantiate."
              }
            },
            {
              "name": "width",
              "description": {
                "kind": "markdown",
                "value": "The displayed width of the resource, in [CSS pixels](https://drafts.csswg.org/css-values/#px). This must be an absolute value; percentages are _not_ allowed."
              }
            },
            {
              "name": "height",
              "description": {
                "kind": "markdown",
                "value": "The displayed height of the resource, in [CSS pixels](https://drafts.csswg.org/css-values/#px). This must be an absolute value; percentages are _not_ allowed."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/embed"
            }
          ]
        },
        {
          "name": "object",
          "description": {
            "kind": "markdown",
            "value": "The object element can represent an external resource, which, depending on the type of the resource, will either be treated as an image, as a nested browsing context, or as an external resource to be processed by a plugin."
          },
          "attributes": [
            {
              "name": "data",
              "description": {
                "kind": "markdown",
                "value": "The address of the resource as a valid URL. At least one of **data** and **type** must be defined."
              }
            },
            {
              "name": "type",
              "description": {
                "kind": "markdown",
                "value": "The [content type](https://developer.mozilla.org/en-US/docs/Glossary/Content_type) of the resource specified by **data**. At least one of **data** and **type** must be defined."
              }
            },
            {
              "name": "typemustmatch",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute indicates if the **type** attribute and the actual [content type](https://developer.mozilla.org/en-US/docs/Glossary/Content_type) of the resource must match to be used."
              }
            },
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": "The name of valid browsing context (HTML5), or the name of the control (HTML 4)."
              }
            },
            {
              "name": "usemap",
              "description": {
                "kind": "markdown",
                "value": "A hash-name reference to a [`<map>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map \"The HTML <map> element is used with <area> elements to define an image map (a clickable link area).\") element; that is a '#' followed by the value of a [`name`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map#attr-name) of a map element."
              }
            },
            {
              "name": "form",
              "description": {
                "kind": "markdown",
                "value": 'The form element, if any, that the object element is associated with (its _form owner_). The value of the attribute must be an ID of a [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") element in the same document.'
              }
            },
            {
              "name": "width",
              "description": {
                "kind": "markdown",
                "value": "The width of the display resource, in [CSS pixels](https://drafts.csswg.org/css-values/#px). -- (Absolute values only. [NO percentages](https://html.spec.whatwg.org/multipage/embedded-content.html#dimension-attributes))"
              }
            },
            {
              "name": "height",
              "description": {
                "kind": "markdown",
                "value": "The height of the displayed resource, in [CSS pixels](https://drafts.csswg.org/css-values/#px). -- (Absolute values only. [NO percentages](https://html.spec.whatwg.org/multipage/embedded-content.html#dimension-attributes))"
              }
            },
            {
              "name": "archive",
              "description": "A space-separated list of URIs for archives of resources for the object."
            },
            {
              "name": "border",
              "description": "The width of a border around the control, in pixels."
            },
            {
              "name": "classid",
              "description": "The URI of the object's implementation. It can be used together with, or in place of, the **data** attribute."
            },
            {
              "name": "codebase",
              "description": "The base path used to resolve relative URIs specified by **classid**, **data**, or **archive**. If not specified, the default is the base URI of the current document."
            },
            {
              "name": "codetype",
              "description": "The content type of the data specified by **classid**."
            },
            {
              "name": "declare",
              "description": "The presence of this Boolean attribute makes this element a declaration only. The object must be instantiated by a subsequent `<object>` element. In HTML5, repeat the <object> element completely each that that the resource is reused."
            },
            {
              "name": "standby",
              "description": "A message that the browser can show while loading the object's implementation and data."
            },
            {
              "name": "tabindex",
              "description": "The position of the element in the tabbing navigation order for the current document."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/object"
            }
          ]
        },
        {
          "name": "param",
          "description": {
            "kind": "markdown",
            "value": "The param element defines parameters for plugins invoked by object elements. It does not represent anything on its own."
          },
          "attributes": [
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": "Name of the parameter."
              }
            },
            {
              "name": "value",
              "description": {
                "kind": "markdown",
                "value": "Specifies the value of the parameter."
              }
            },
            {
              "name": "type",
              "description": 'Only used if the `valuetype` is set to "ref". Specifies the MIME type of values found at the URI specified by value.'
            },
            {
              "name": "valuetype",
              "description": 'Specifies the type of the `value` attribute. Possible values are:\n\n*   data: Default value. The value is passed to the object\'s implementation as a string.\n*   ref: The value is a URI to a resource where run-time values are stored.\n*   object: An ID of another [`<object>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object "The HTML <object> element represents an external resource, which can be treated as an image, a nested browsing context, or a resource to be handled by a plugin.") in the same document.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/param"
            }
          ]
        },
        {
          "name": "video",
          "description": {
            "kind": "markdown",
            "value": "A video element is used for playing videos or movies, and audio files with captions."
          },
          "attributes": [
            {
              "name": "src"
            },
            {
              "name": "crossorigin",
              "valueSet": "xo"
            },
            {
              "name": "poster"
            },
            {
              "name": "preload",
              "valueSet": "pl"
            },
            {
              "name": "autoplay",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "A Boolean attribute; if specified, the video automatically begins to play back as soon as it can do so without stopping to finish loading the data."
              }
            },
            {
              "name": "mediagroup"
            },
            {
              "name": "loop",
              "valueSet": "v"
            },
            {
              "name": "muted",
              "valueSet": "v"
            },
            {
              "name": "controls",
              "valueSet": "v"
            },
            {
              "name": "width"
            },
            {
              "name": "height"
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/video"
            }
          ]
        },
        {
          "name": "audio",
          "description": {
            "kind": "markdown",
            "value": "An audio element represents a sound or audio stream."
          },
          "attributes": [
            {
              "name": "src",
              "description": {
                "kind": "markdown",
                "value": 'The URL of the audio to embed. This is subject to [HTTP access controls](https://developer.mozilla.org/en-US/docs/HTTP_access_control). This is optional; you may instead use the [`<source>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source "The HTML <source> element specifies multiple media resources for the <picture>, the <audio> element, or the <video> element.") element within the audio block to specify the audio to embed.'
              }
            },
            {
              "name": "crossorigin",
              "valueSet": "xo",
              "description": {
                "kind": "markdown",
                "value": 'This enumerated attribute indicates whether to use CORS to fetch the related image. [CORS-enabled resources](https://developer.mozilla.org/en-US/docs/CORS_Enabled_Image) can be reused in the [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas "Use the HTML <canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations.") element without being _tainted_. The allowed values are:\n\nanonymous\n\nSends a cross-origin request without a credential. In other words, it sends the `Origin:` HTTP header without a cookie, X.509 certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (by not setting the `Access-Control-Allow-Origin:` HTTP header), the image will be _tainted_, and its usage restricted.\n\nuse-credentials\n\nSends a cross-origin request with a credential. In other words, it sends the `Origin:` HTTP header with a cookie, a certificate, or performing HTTP Basic authentication. If the server does not give credentials to the origin site (through `Access-Control-Allow-Credentials:` HTTP header), the image will be _tainted_ and its usage restricted.\n\nWhen not present, the resource is fetched without a CORS request (i.e. without sending the `Origin:` HTTP header), preventing its non-tainted used in [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas "Use the HTML <canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations.") elements. If invalid, it is handled as if the enumerated keyword **anonymous** was used. See [CORS settings attributes](https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes) for additional information.'
              }
            },
            {
              "name": "preload",
              "valueSet": "pl",
              "description": {
                "kind": "markdown",
                "value": "This enumerated attribute is intended to provide a hint to the browser about what the author thinks will lead to the best user experience. It may have one of the following values:\n\n*   `none`: Indicates that the audio should not be preloaded.\n*   `metadata`: Indicates that only audio metadata (e.g. length) is fetched.\n*   `auto`: Indicates that the whole audio file can be downloaded, even if the user is not expected to use it.\n*   _empty string_: A synonym of the `auto` value.\n\nIf not set, `preload`'s default value is browser-defined (i.e. each browser may have its own default value). The spec advises it to be set to `metadata`.\n\n**Usage notes:**\n\n*   The `autoplay` attribute has precedence over\xA0`preload`. If `autoplay` is specified, the browser would obviously need to start downloading the audio for playback.\n*   The browser is not forced by the specification to follow the value of this attribute; it is a mere hint."
              }
            },
            {
              "name": "autoplay",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "A Boolean attribute:\xA0if specified, the audio will automatically begin playback as soon as it can do so, without waiting for the entire audio file to finish downloading.\n\n**Note**: Sites that automatically play audio (or videos with an audio track) can be an unpleasant experience for users, so should be avoided when possible. If you must offer autoplay functionality, you should make it opt-in (requiring a user to specifically enable it). However, this can be useful when creating media elements whose source will be set at a later time, under user control."
              }
            },
            {
              "name": "mediagroup"
            },
            {
              "name": "loop",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "A Boolean attribute:\xA0if specified, the audio player will\xA0automatically seek back to the start\xA0upon reaching the end of the audio."
              }
            },
            {
              "name": "muted",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "A Boolean attribute that indicates whether the audio will be initially silenced. Its default value is `false`."
              }
            },
            {
              "name": "controls",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "If this attribute is present, the browser will offer controls to allow the user to control audio playback, including volume, seeking, and pause/resume playback."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/audio"
            }
          ]
        },
        {
          "name": "source",
          "description": {
            "kind": "markdown",
            "value": "The source element allows authors to specify multiple alternative media resources for media elements. It does not represent anything on its own."
          },
          "attributes": [
            {
              "name": "src",
              "description": {
                "kind": "markdown",
                "value": 'Required for [`<audio>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio "The HTML <audio> element is used to embed sound content in documents. It may contain one or more audio sources, represented using the src attribute or the <source> element:\xA0the browser will choose the most suitable one. It can also be the destination for streamed media, using a MediaStream.") and [`<video>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video "The HTML Video element (<video>) embeds a media player which supports video playback into the document."), address of the media resource. The value of this attribute is ignored when the `<source>` element is placed inside a [`<picture>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture "The HTML <picture> element contains zero or more <source> elements and one <img> element to provide versions of an image for different display/device scenarios.") element.'
              }
            },
            {
              "name": "type",
              "description": {
                "kind": "markdown",
                "value": "The MIME-type of the resource, optionally with a `codecs` parameter. See [RFC 4281](https://tools.ietf.org/html/rfc4281) for information about how to specify codecs."
              }
            },
            {
              "name": "sizes",
              "description": 'Is a list of source sizes that describes the final rendered width of the image represented by the source. Each source size consists of a comma-separated list of media condition-length pairs. This information is used by the browser to determine, before laying the page out, which image defined in [`srcset`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source#attr-srcset) to use.  \nThe `sizes` attribute has an effect only when the [`<source>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source "The HTML <source> element specifies multiple media resources for the <picture>, the <audio> element, or the <video> element.") element is the direct child of a [`<picture>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture "The HTML <picture> element contains zero or more <source> elements and one <img> element to provide versions of an image for different display/device scenarios.") element.'
            },
            {
              "name": "srcset",
              "description": "A list of one or more strings separated by commas indicating a set of possible images represented by the source for the browser to use. Each string is composed of:\n\n1.  one URL to an image,\n2.  a width descriptor, that is a positive integer directly followed by `'w'`. The default value, if missing, is the infinity.\n3.  a pixel density descriptor, that is a positive floating number directly followed by `'x'`. The default value, if missing, is `1x`.\n\nEach string in the list must have at least a width descriptor or a pixel density descriptor to be valid. Among the list, there must be only one string containing the same tuple of width descriptor and pixel density descriptor.  \nThe browser chooses the most adequate image to display at a given point of time.  \nThe `srcset` attribute has an effect only when the [`<source>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source \"The HTML <source> element specifies multiple media resources for the <picture>, the <audio> element, or the <video> element.\") element is the direct child of a [`<picture>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture \"The HTML <picture> element contains zero or more <source> elements and one <img> element to provide versions of an image for different display/device scenarios.\") element."
            },
            {
              "name": "media",
              "description": '[Media query](https://developer.mozilla.org/en-US/docs/CSS/Media_queries) of the resource\'s intended media; this should be used only in a [`<picture>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture "The HTML <picture> element contains zero or more <source> elements and one <img> element to provide versions of an image for different display/device scenarios.") element.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/source"
            }
          ]
        },
        {
          "name": "track",
          "description": {
            "kind": "markdown",
            "value": "The track element allows authors to specify explicit external timed text tracks for media elements. It does not represent anything on its own."
          },
          "attributes": [
            {
              "name": "default",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This attribute indicates that the track should be enabled unless the user's preferences indicate that another track is more appropriate. This may only be used on one `track` element per media element."
              }
            },
            {
              "name": "kind",
              "valueSet": "tk",
              "description": {
                "kind": "markdown",
                "value": "How the text track is meant to be used. If omitted the default kind is `subtitles`. If the attribute is not present, it will use the `subtitles`. If the attribute contains an invalid value, it will use `metadata`. (Versions of Chrome earlier than 52 treated an invalid value as `subtitles`.)\xA0The following keywords are allowed:\n\n*   `subtitles`\n    *   Subtitles provide translation of content that cannot be understood by the viewer. For example dialogue or text that is not English in an English language film.\n    *   Subtitles may contain additional content, usually extra background information. For example the text at the beginning of the Star Wars films, or the date, time, and location of a scene.\n*   `captions`\n    *   Closed captions provide a transcription and possibly a translation of audio.\n    *   It may include important non-verbal information such as music cues or sound effects. It may indicate the cue's source (e.g. music, text, character).\n    *   Suitable for users who are deaf or when the sound is muted.\n*   `descriptions`\n    *   Textual description of the video content.\n    *   Suitable for users who are blind or where the video cannot be seen.\n*   `chapters`\n    *   Chapter titles are intended to be used when the user is navigating the media resource.\n*   `metadata`\n    *   Tracks used by scripts. Not visible to the user."
              }
            },
            {
              "name": "label",
              "description": {
                "kind": "markdown",
                "value": "A user-readable title of the text track which is used by the browser when listing available text tracks."
              }
            },
            {
              "name": "src",
              "description": {
                "kind": "markdown",
                "value": 'Address of the track (`.vtt` file). Must be a valid URL. This attribute must be specified and its URL value must have the same origin as the document \u2014 unless the [`<audio>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio "The HTML <audio> element is used to embed sound content in documents. It may contain one or more audio sources, represented using the src attribute or the <source> element:\xA0the browser will choose the most suitable one. It can also be the destination for streamed media, using a MediaStream.") or [`<video>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video "The HTML Video element (<video>) embeds a media player which supports video playback into the document.") parent element of the `track` element has a [`crossorigin`](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) attribute.'
              }
            },
            {
              "name": "srclang",
              "description": {
                "kind": "markdown",
                "value": "Language of the track text data. It must be a valid [BCP 47](https://r12a.github.io/app-subtags/) language tag. If the `kind` attribute is set to\xA0`subtitles,` then `srclang` must be defined."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/track"
            }
          ]
        },
        {
          "name": "map",
          "description": {
            "kind": "markdown",
            "value": "The map element, in conjunction with an img element and any area element descendants, defines an image map. The element represents its children."
          },
          "attributes": [
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": "The name attribute gives the map a name so that it can be referenced. The attribute must be present and must have a non-empty value with no space characters. The value of the name attribute must not be a compatibility-caseless match for the value of the name attribute of another map element in the same document. If the id attribute is also specified, both attributes must have the same value."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/map"
            }
          ]
        },
        {
          "name": "area",
          "description": {
            "kind": "markdown",
            "value": "The area element represents either a hyperlink with some text and a corresponding area on an image map, or a dead area on an image map."
          },
          "attributes": [
            {
              "name": "alt"
            },
            {
              "name": "coords"
            },
            {
              "name": "shape",
              "valueSet": "sh"
            },
            {
              "name": "href"
            },
            {
              "name": "target"
            },
            {
              "name": "download"
            },
            {
              "name": "ping"
            },
            {
              "name": "rel"
            },
            {
              "name": "hreflang"
            },
            {
              "name": "type"
            },
            {
              "name": "accesskey",
              "description": "Specifies a keyboard navigation accelerator for the element. Pressing ALT or a similar key in association with the specified character selects the form control correlated with that key sequence. Page designers are forewarned to avoid key sequences already bound to browsers. This attribute is global since HTML5."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/area"
            }
          ]
        },
        {
          "name": "table",
          "description": {
            "kind": "markdown",
            "value": "The table element represents data with more than one dimension, in the form of a table."
          },
          "attributes": [
            {
              "name": "border"
            },
            {
              "name": "align",
              "description": 'This enumerated attribute indicates how the table must be aligned inside the containing document. It may have the following values:\n\n*   left: the table is displayed on the left side of the document;\n*   center: the table is displayed in the center of the document;\n*   right: the table is displayed on the right side of the document.\n\n**Usage Note**\n\n*   **Do not use this attribute**, as it has been deprecated. The [`<table>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table "The HTML <table> element represents tabular data \u2014 that is, information presented in a two-dimensional table comprised of rows and columns of cells containing data.") element should be styled using [CSS](https://developer.mozilla.org/en-US/docs/CSS). Set [`margin-left`](https://developer.mozilla.org/en-US/docs/Web/CSS/margin-left "The margin-left CSS property sets the margin area on the left side of an element. A positive value places it farther from its neighbors, while a negative value places it closer.") and [`margin-right`](https://developer.mozilla.org/en-US/docs/Web/CSS/margin-right "The margin-right CSS property sets the margin area on the right side of an element. A positive value places it farther from its neighbors, while a negative value places it closer.") to `auto` or [`margin`](https://developer.mozilla.org/en-US/docs/Web/CSS/margin "The margin CSS property sets the margin area on all four sides of an element. It is a shorthand for margin-top, margin-right, margin-bottom, and margin-left.") to `0 auto` to achieve an effect that is similar to the align attribute.\n*   Prior to Firefox 4, Firefox also supported the `middle`, `absmiddle`, and `abscenter` values as synonyms of `center`, in quirks mode only.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/table"
            }
          ]
        },
        {
          "name": "caption",
          "description": {
            "kind": "markdown",
            "value": "The caption element represents the title of the table that is its parent, if it has a parent and that is a table element."
          },
          "attributes": [
            {
              "name": "align",
              "description": 'This enumerated attribute indicates how the caption must be aligned with respect to the table. It may have one of the following values:\n\n`left`\n\nThe caption is displayed to the left of the table.\n\n`top`\n\nThe caption is displayed above the table.\n\n`right`\n\nThe caption is displayed to the right of the table.\n\n`bottom`\n\nThe caption is displayed below the table.\n\n**Usage note:** Do not use this attribute, as it has been deprecated. The [`<caption>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption "The HTML Table Caption element (<caption>) specifies the caption (or title) of a table, and if used is always the first child of a <table>.") element should be styled using the [CSS](https://developer.mozilla.org/en-US/docs/CSS) properties [`caption-side`](https://developer.mozilla.org/en-US/docs/Web/CSS/caption-side "The caption-side CSS property puts the content of a table\'s <caption> on the specified side. The values are relative to the writing-mode of the table.") and [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.").'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/caption"
            }
          ]
        },
        {
          "name": "colgroup",
          "description": {
            "kind": "markdown",
            "value": "The colgroup element represents a group of one or more columns in the table that is its parent, if it has a parent and that is a table element."
          },
          "attributes": [
            {
              "name": "span"
            },
            {
              "name": "align",
              "description": 'This enumerated attribute specifies how horizontal alignment of each column cell content will be handled. Possible values are:\n\n*   `left`, aligning the content to the left of the cell\n*   `center`, centering the content in the cell\n*   `right`, aligning the content to the right of the cell\n*   `justify`, inserting spaces into the textual content so that the content is justified in the cell\n*   `char`, aligning the textual content on a special character with a minimal offset, defined by the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col#attr-char) and [`charoff`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col#attr-charoff) attributes Unimplemented (see [bug\xA02212](https://bugzilla.mozilla.org/show_bug.cgi?id=2212 "character alignment not implemented (align=char, charoff=, text-align:<string>)")).\n\nIf this attribute is not set, the `left` value is assumed. The descendant [`<col>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col "The HTML <col> element defines a column within a table and is used for defining common semantics on all common cells. It is generally found within a <colgroup> element.") elements may override this value using their own [`align`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col#attr-align) attribute.\n\n**Note:** Do not use this attribute as it is obsolete (not supported) in the latest standard.\n\n*   To achieve the same effect as the `left`, `center`, `right` or `justify` values:\n    *   Do not try to set the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property on a selector giving a [`<colgroup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup "The HTML <colgroup> element defines a group of columns within a table.") element. Because [`<td>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td "The HTML <td> element defines a cell of a table that contains data. It participates in the table model.") elements are not descendant of the [`<colgroup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup "The HTML <colgroup> element defines a group of columns within a table.") element, they won\'t inherit it.\n    *   If the table doesn\'t use a [`colspan`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-colspan) attribute, use one `td:nth-child(an+b)` CSS selector per column, where a is the total number of the columns in the table and b is the ordinal position of this column in the table. Only after this selector the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property can be used.\n    *   If the table does use a [`colspan`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-colspan) attribute, the effect can be achieved by combining adequate CSS attribute selectors like `[colspan=n]`, though this is not trivial.\n*   To achieve the same effect as the `char` value, in CSS3, you can use the value of the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup#attr-char) as the value of the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property Unimplemented.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/colgroup"
            }
          ]
        },
        {
          "name": "col",
          "description": {
            "kind": "markdown",
            "value": "If a col element has a parent and that is a colgroup element that itself has a parent that is a table element, then the col element represents one or more columns in the column group represented by that colgroup."
          },
          "attributes": [
            {
              "name": "span"
            },
            {
              "name": "align",
              "description": 'This enumerated attribute specifies how horizontal alignment of each column cell content will be handled. Possible values are:\n\n*   `left`, aligning the content to the left of the cell\n*   `center`, centering the content in the cell\n*   `right`, aligning the content to the right of the cell\n*   `justify`, inserting spaces into the textual content so that the content is justified in the cell\n*   `char`, aligning the textual content on a special character with a minimal offset, defined by the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col#attr-char) and [`charoff`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col#attr-charoff) attributes Unimplemented (see [bug\xA02212](https://bugzilla.mozilla.org/show_bug.cgi?id=2212 "character alignment not implemented (align=char, charoff=, text-align:<string>)")).\n\nIf this attribute is not set, its value is inherited from the [`align`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup#attr-align) of the [`<colgroup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup "The HTML <colgroup> element defines a group of columns within a table.") element this `<col>` element belongs too. If there are none, the `left` value is assumed.\n\n**Note:** Do not use this attribute as it is obsolete (not supported) in the latest standard.\n\n*   To achieve the same effect as the `left`, `center`, `right` or `justify` values:\n    *   Do not try to set the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property on a selector giving a [`<col>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col "The HTML <col> element defines a column within a table and is used for defining common semantics on all common cells. It is generally found within a <colgroup> element.") element. Because [`<td>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td "The HTML <td> element defines a cell of a table that contains data. It participates in the table model.") elements are not descendant of the [`<col>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col "The HTML <col> element defines a column within a table and is used for defining common semantics on all common cells. It is generally found within a <colgroup> element.") element, they won\'t inherit it.\n    *   If the table doesn\'t use a [`colspan`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-colspan) attribute, use the `td:nth-child(an+b)` CSS selector. Set `a` to zero and `b` to the position of the column in the table, e.g. `td:nth-child(2) { text-align: right; }` to right-align the second column.\n    *   If the table does use a [`colspan`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-colspan) attribute, the effect can be achieved by combining adequate CSS attribute selectors like `[colspan=n]`, though this is not trivial.\n*   To achieve the same effect as the `char` value, in CSS3, you can use the value of the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col#attr-char) as the value of the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property Unimplemented.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/col"
            }
          ]
        },
        {
          "name": "tbody",
          "description": {
            "kind": "markdown",
            "value": "The tbody element represents a block of rows that consist of a body of data for the parent table element, if the tbody element has a parent and it is a table."
          },
          "attributes": [
            {
              "name": "align",
              "description": 'This enumerated attribute specifies how horizontal alignment of each cell content will be handled. Possible values are:\n\n*   `left`, aligning the content to the left of the cell\n*   `center`, centering the content in the cell\n*   `right`, aligning the content to the right of the cell\n*   `justify`, inserting spaces into the textual content so that the content is justified in the cell\n*   `char`, aligning the textual content on a special character with a minimal offset, defined by the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody#attr-char) and [`charoff`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody#attr-charoff) attributes.\n\nIf this attribute is not set, the `left` value is assumed.\n\n**Note:** Do not use this attribute as it is obsolete (not supported) in the latest standard.\n\n*   To achieve the same effect as the `left`, `center`, `right` or `justify` values, use the CSS [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property on it.\n*   To achieve the same effect as the `char` value, in CSS3, you can use the value of the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody#attr-char) as the value of the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property Unimplemented.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/tbody"
            }
          ]
        },
        {
          "name": "thead",
          "description": {
            "kind": "markdown",
            "value": "The thead element represents the block of rows that consist of the column labels (headers) for the parent table element, if the thead element has a parent and it is a table."
          },
          "attributes": [
            {
              "name": "align",
              "description": 'This enumerated attribute specifies how horizontal alignment of each cell content will be handled. Possible values are:\n\n*   `left`, aligning the content to the left of the cell\n*   `center`, centering the content in the cell\n*   `right`, aligning the content to the right of the cell\n*   `justify`, inserting spaces into the textual content so that the content is justified in the cell\n*   `char`, aligning the textual content on a special character with a minimal offset, defined by the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead#attr-char) and [`charoff`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead#attr-charoff) attributes Unimplemented (see [bug\xA02212](https://bugzilla.mozilla.org/show_bug.cgi?id=2212 "character alignment not implemented (align=char, charoff=, text-align:<string>)")).\n\nIf this attribute is not set, the `left` value is assumed.\n\n**Note:** Do not use this attribute as it is obsolete (not supported) in the latest standard.\n\n*   To achieve the same effect as the `left`, `center`, `right` or `justify` values, use the CSS [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property on it.\n*   To achieve the same effect as the `char` value, in CSS3, you can use the value of the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead#attr-char) as the value of the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property Unimplemented.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/thead"
            }
          ]
        },
        {
          "name": "tfoot",
          "description": {
            "kind": "markdown",
            "value": "The tfoot element represents the block of rows that consist of the column summaries (footers) for the parent table element, if the tfoot element has a parent and it is a table."
          },
          "attributes": [
            {
              "name": "align",
              "description": 'This enumerated attribute specifies how horizontal alignment of each cell content will be handled. Possible values are:\n\n*   `left`, aligning the content to the left of the cell\n*   `center`, centering the content in the cell\n*   `right`, aligning the content to the right of the cell\n*   `justify`, inserting spaces into the textual content so that the content is justified in the cell\n*   `char`, aligning the textual content on a special character with a minimal offset, defined by the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody#attr-char) and [`charoff`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody#attr-charoff) attributes Unimplemented (see [bug\xA02212](https://bugzilla.mozilla.org/show_bug.cgi?id=2212 "character alignment not implemented (align=char, charoff=, text-align:<string>)")).\n\nIf this attribute is not set, the `left` value is assumed.\n\n**Note:** Do not use this attribute as it is obsolete (not supported) in the latest standard.\n\n*   To achieve the same effect as the `left`, `center`, `right` or `justify` values, use the CSS [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property on it.\n*   To achieve the same effect as the `char` value, in CSS3, you can use the value of the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot#attr-char) as the value of the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property Unimplemented.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/tfoot"
            }
          ]
        },
        {
          "name": "tr",
          "description": {
            "kind": "markdown",
            "value": "The tr element represents a row of cells in a table."
          },
          "attributes": [
            {
              "name": "align",
              "description": 'A [`DOMString`](https://developer.mozilla.org/en-US/docs/Web/API/DOMString "DOMString is a UTF-16 String. As JavaScript already uses such strings, DOMString is mapped directly to a String.") which specifies how the cell\'s context should be aligned horizontally within the cells in the row; this is shorthand for using `align` on every cell in the row individually. Possible values are:\n\n`left`\n\nAlign the content of each cell at its left edge.\n\n`center`\n\nCenter the contents of each cell between their left and right edges.\n\n`right`\n\nAlign the content of each cell at its right edge.\n\n`justify`\n\nWiden whitespaces within the text of each cell so that the text fills the full width of each cell (full justification).\n\n`char`\n\nAlign each cell in the row on a specific character (such that each row in the column that is configured this way will horizontally align its cells on that character). This uses the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr#attr-char) and [`charoff`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr#attr-charoff) to establish the alignment character (typically "." or "," when aligning numerical data) and the number of characters that should follow the alignment character. This alignment type was never widely supported.\n\nIf no value is expressly set for `align`, the parent node\'s value is inherited.\n\nInstead of using the obsolete `align` attribute, you should instead use the CSS [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property to establish `left`, `center`, `right`, or `justify` alignment for the row\'s cells. To apply character-based alignment, set the CSS [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property to the alignment character (such as `"."` or `","`).'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/tr"
            }
          ]
        },
        {
          "name": "td",
          "description": {
            "kind": "markdown",
            "value": "The td element represents a data cell in a table."
          },
          "attributes": [
            {
              "name": "colspan"
            },
            {
              "name": "rowspan"
            },
            {
              "name": "headers"
            },
            {
              "name": "abbr",
              "description": "This attribute contains a short abbreviated description of the cell's content. Some user-agents, such as speech readers, may present this description before the content itself.\n\n**Note:** Do not use this attribute as it is obsolete in the latest standard. Alternatively, you can put the abbreviated description inside the cell and place the long content in the **title** attribute."
            },
            {
              "name": "align",
              "description": 'This enumerated attribute specifies how the cell content\'s horizontal alignment will be handled. Possible values are:\n\n*   `left`: The content is aligned to the left of the cell.\n*   `center`: The content is centered in the cell.\n*   `right`: The content is aligned to the right of the cell.\n*   `justify` (with text only): The content is stretched out inside the cell so that it covers its entire width.\n*   `char` (with text only): The content is aligned to a character inside the `<th>` element with minimal offset. This character is defined by the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-char) and [`charoff`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-charoff) attributes Unimplemented (see [bug\xA02212](https://bugzilla.mozilla.org/show_bug.cgi?id=2212 "character alignment not implemented (align=char, charoff=, text-align:<string>)")).\n\nThe default value when this attribute is not specified is `left`.\n\n**Note:** Do not use this attribute as it is obsolete in the latest standard.\n\n*   To achieve the same effect as the `left`, `center`, `right` or `justify` values, apply the CSS [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property to the element.\n*   To achieve the same effect as the `char` value, give the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property the same value you would use for the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td#attr-char). Unimplemented in CSS3.'
            },
            {
              "name": "axis",
              "description": "This attribute contains a list of space-separated strings. Each string is the `id` of a group of cells that this header applies to.\n\n**Note:** Do not use this attribute as it is obsolete in the latest standard."
            },
            {
              "name": "bgcolor",
              "description": 'This attribute defines the background color of each cell in a column. It consists of a 6-digit hexadecimal code as defined in [sRGB](https://www.w3.org/Graphics/Color/sRGB) and is prefixed by \'#\'. This attribute may be used with one of sixteen predefined color strings:\n\n\xA0\n\n`black` = "#000000"\n\n\xA0\n\n`green` = "#008000"\n\n\xA0\n\n`silver` = "#C0C0C0"\n\n\xA0\n\n`lime` = "#00FF00"\n\n\xA0\n\n`gray` = "#808080"\n\n\xA0\n\n`olive` = "#808000"\n\n\xA0\n\n`white` = "#FFFFFF"\n\n\xA0\n\n`yellow` = "#FFFF00"\n\n\xA0\n\n`maroon` = "#800000"\n\n\xA0\n\n`navy` = "#000080"\n\n\xA0\n\n`red` = "#FF0000"\n\n\xA0\n\n`blue` = "#0000FF"\n\n\xA0\n\n`purple` = "#800080"\n\n\xA0\n\n`teal` = "#008080"\n\n\xA0\n\n`fuchsia` = "#FF00FF"\n\n\xA0\n\n`aqua` = "#00FFFF"\n\n**Note:** Do not use this attribute, as it is non-standard and only implemented in some versions of Microsoft Internet Explorer: The [`<td>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td "The HTML <td> element defines a cell of a table that contains data. It participates in the table model.") element should be styled using [CSS](https://developer.mozilla.org/en-US/docs/CSS). To create a similar effect use the [`background-color`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-color "The background-color CSS property sets the background color of an element.") property in [CSS](https://developer.mozilla.org/en-US/docs/CSS) instead.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/td"
            }
          ]
        },
        {
          "name": "th",
          "description": {
            "kind": "markdown",
            "value": "The th element represents a header cell in a table."
          },
          "attributes": [
            {
              "name": "colspan"
            },
            {
              "name": "rowspan"
            },
            {
              "name": "headers"
            },
            {
              "name": "scope",
              "valueSet": "s"
            },
            {
              "name": "sorted"
            },
            {
              "name": "abbr",
              "description": {
                "kind": "markdown",
                "value": "This attribute contains a short abbreviated description of the cell's content. Some user-agents, such as speech readers, may present this description before the content itself."
              }
            },
            {
              "name": "align",
              "description": 'This enumerated attribute specifies how the cell content\'s horizontal alignment will be handled. Possible values are:\n\n*   `left`: The content is aligned to the left of the cell.\n*   `center`: The content is centered in the cell.\n*   `right`: The content is aligned to the right of the cell.\n*   `justify` (with text only): The content is stretched out inside the cell so that it covers its entire width.\n*   `char` (with text only): The content is aligned to a character inside the `<th>` element with minimal offset. This character is defined by the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attr-char) and [`charoff`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attr-charoff) attributes.\n\nThe default value when this attribute is not specified is `left`.\n\n**Note:** Do not use this attribute as it is obsolete in the latest standard.\n\n*   To achieve the same effect as the `left`, `center`, `right` or `justify` values, apply the CSS [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property to the element.\n*   To achieve the same effect as the `char` value, give the [`text-align`](https://developer.mozilla.org/en-US/docs/Web/CSS/text-align "The text-align CSS property sets the horizontal alignment of an inline or table-cell box. This means it works like vertical-align but in the horizontal direction.") property the same value you would use for the [`char`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attr-char). Unimplemented in CSS3.'
            },
            {
              "name": "axis",
              "description": "This attribute contains a list of space-separated strings. Each string is the `id` of a group of cells that this header applies to.\n\n**Note:** Do not use this attribute as it is obsolete in the latest standard: use the [`scope`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attr-scope) attribute instead."
            },
            {
              "name": "bgcolor",
              "description": 'This attribute defines the background color of each cell in a column. It consists of a 6-digit hexadecimal code as defined in [sRGB](https://www.w3.org/Graphics/Color/sRGB) and is prefixed by \'#\'. This attribute may be used with one of sixteen predefined color strings:\n\n\xA0\n\n`black` = "#000000"\n\n\xA0\n\n`green` = "#008000"\n\n\xA0\n\n`silver` = "#C0C0C0"\n\n\xA0\n\n`lime` = "#00FF00"\n\n\xA0\n\n`gray` = "#808080"\n\n\xA0\n\n`olive` = "#808000"\n\n\xA0\n\n`white` = "#FFFFFF"\n\n\xA0\n\n`yellow` = "#FFFF00"\n\n\xA0\n\n`maroon` = "#800000"\n\n\xA0\n\n`navy` = "#000080"\n\n\xA0\n\n`red` = "#FF0000"\n\n\xA0\n\n`blue` = "#0000FF"\n\n\xA0\n\n`purple` = "#800080"\n\n\xA0\n\n`teal` = "#008080"\n\n\xA0\n\n`fuchsia` = "#FF00FF"\n\n\xA0\n\n`aqua` = "#00FFFF"\n\n**Note:** Do not use this attribute, as it is non-standard and only implemented in some versions of Microsoft Internet Explorer: The [`<th>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th "The HTML <th> element defines a cell as header of a group of table cells. The exact nature of this group is defined by the scope and headers attributes.") element should be styled using [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS). To create a similar effect use the [`background-color`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-color "The background-color CSS property sets the background color of an element.") property in [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS) instead.'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/th"
            }
          ]
        },
        {
          "name": "form",
          "description": {
            "kind": "markdown",
            "value": "The form element represents a collection of form-associated elements, some of which can represent editable values that can be submitted to a server for processing."
          },
          "attributes": [
            {
              "name": "accept-charset",
              "description": {
                "kind": "markdown",
                "value": 'A space- or comma-delimited list of character encodings that the server accepts. The browser uses them in the order in which they are listed. The default value, the reserved string `"UNKNOWN"`, indicates the same encoding as that of the document containing the form element.  \nIn previous versions of HTML, the different character encodings could be delimited by spaces or commas. In HTML5, only spaces are allowed as delimiters.'
              }
            },
            {
              "name": "action",
              "description": {
                "kind": "markdown",
                "value": 'The URI of a program that processes the form information. This value can be overridden by a [`formaction`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-formaction) attribute on a [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") or [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") element.'
              }
            },
            {
              "name": "autocomplete",
              "valueSet": "o",
              "description": {
                "kind": "markdown",
                "value": "Indicates whether input elements can by default have their values automatically completed by the browser. This setting can be overridden by an `autocomplete` attribute on an element belonging to the form. Possible values are:\n\n*   `off`: The user must explicitly enter a value into each field for every use, or the document provides its own auto-completion method; the browser does not automatically complete entries.\n*   `on`: The browser can automatically complete values based on values that the user has previously entered in the form.\n\nFor most modern browsers (including Firefox 38+, Google Chrome 34+, IE 11+) setting the autocomplete attribute will not prevent a browser's password manager from asking the user if they want to store login fields (username and password), if the user permits the storage the browser will autofill the login the next time the user visits the page. See [The autocomplete attribute and login fields](https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion#The_autocomplete_attribute_and_login_fields)."
              }
            },
            {
              "name": "enctype",
              "valueSet": "et",
              "description": {
                "kind": "markdown",
                "value": 'When the value of the `method` attribute is `post`, enctype is the [MIME type](https://en.wikipedia.org/wiki/Mime_type) of content that is used to submit the form to the server. Possible values are:\n\n*   `application/x-www-form-urlencoded`: The default value if the attribute is not specified.\n*   `multipart/form-data`: The value used for an [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") element with the `type` attribute set to "file".\n*   `text/plain`: (HTML5)\n\nThis value can be overridden by a [`formenctype`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-formenctype) attribute on a [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") or [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") element.'
              }
            },
            {
              "name": "method",
              "valueSet": "m",
              "description": {
                "kind": "markdown",
                "value": 'The [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) method that the browser uses to submit the form. Possible values are:\n\n*   `post`: Corresponds to the HTTP [POST method](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5) ; form data are included in the body of the form and sent to the server.\n*   `get`: Corresponds to the HTTP [GET method](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3); form data are appended to the `action` attribute URI with a \'?\' as separator, and the resulting URI is sent to the server. Use this method when the form has no side-effects and contains only ASCII characters.\n*   `dialog`: Use when the form is inside a\xA0[`<dialog>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog "The HTML <dialog> element represents a dialog box or other interactive component, such as an inspector or window.") element to close the dialog when submitted.\n\nThis value can be overridden by a [`formmethod`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-formmethod) attribute on a [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") or [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") element.'
              }
            },
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": "The name of the form. In HTML 4, its use is deprecated (`id` should be used instead). It must be unique among the forms in a document and not just an empty string in HTML 5."
              }
            },
            {
              "name": "novalidate",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'This Boolean attribute indicates that the form is not to be validated when submitted. If this attribute is not specified (and therefore the form is validated), this default setting can be overridden by a [`formnovalidate`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-formnovalidate) attribute on a [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") or [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") element belonging to the form.'
              }
            },
            {
              "name": "target",
              "description": {
                "kind": "markdown",
                "value": 'A name or keyword indicating where to display the response that is received after submitting the form. In HTML 4, this is the name/keyword for a frame. In HTML5, it is a name/keyword for a _browsing context_ (for example, tab, window, or inline frame). The following keywords have special meanings:\n\n*   `_self`: Load the response into the same HTML 4 frame (or HTML5 browsing context) as the current one. This value is the default if the attribute is not specified.\n*   `_blank`: Load the response into a new unnamed HTML 4 window or HTML5 browsing context.\n*   `_parent`: Load the response into the HTML 4 frameset parent of the current frame, or HTML5 parent browsing context of the current one. If there is no parent, this option behaves the same way as `_self`.\n*   `_top`: HTML 4: Load the response into the full original window, and cancel all other frames. HTML5: Load the response into the top-level browsing context (i.e., the browsing context that is an ancestor of the current one, and has no parent). If there is no parent, this option behaves the same way as `_self`.\n*   _iframename_: The response is displayed in a named [`<iframe>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe "The HTML Inline Frame element (<iframe>) represents a nested browsing context, embedding another HTML page into the current one.").\n\nHTML5: This value can be overridden by a [`formtarget`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-formtarget) attribute on a [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") or [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") element.'
              }
            },
            {
              "name": "accept",
              "description": 'A comma-separated list of content types that the server accepts.\n\n**Usage note:** This attribute has been removed in HTML5 and should no longer be used. Instead, use the [`accept`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-accept) attribute of the specific [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") element.'
            },
            {
              "name": "autocapitalize",
              "description": "This is a nonstandard attribute used by iOS Safari Mobile which controls whether and how the text value for textual form control descendants should be automatically capitalized as it is entered/edited by the user. If the `autocapitalize` attribute is specified on an individual form control descendant, it trumps the form-wide `autocapitalize` setting. The non-deprecated values are available in iOS 5 and later. The default value is `sentences`. Possible values are:\n\n*   `none`: Completely disables automatic capitalization\n*   `sentences`: Automatically capitalize the first letter of sentences.\n*   `words`: Automatically capitalize the first letter of words.\n*   `characters`: Automatically capitalize all characters.\n*   `on`: Deprecated since iOS 5.\n*   `off`: Deprecated since iOS 5."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/form"
            }
          ]
        },
        {
          "name": "label",
          "description": {
            "kind": "markdown",
            "value": "The label element represents a caption in a user interface. The caption can be associated with a specific form control, known as the label element's labeled control, either using the for attribute, or by putting the form control inside the label element itself."
          },
          "attributes": [
            {
              "name": "form",
              "description": {
                "kind": "markdown",
                "value": 'The [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") element with which the label is associated (its _form owner_). If specified, the value of the attribute is the `id` of a [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") element in the same document. This lets you place label elements anywhere within a document, not just as descendants of their form elements.'
              }
            },
            {
              "name": "for",
              "description": {
                "kind": "markdown",
                "value": "The [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-id) of a [labelable](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Form_labelable) form-related element in the same document as the `<label>` element. The first element in the document with an `id` matching the value of the `for` attribute is the _labeled control_ for this label element, if it is a labelable element. If it is\xA0not labelable then the `for` attribute has no effect. If there are other elements which also match the `id` value, later in the document, they are not considered.\n\n**Note**: A `<label>` element can have both a `for` attribute and a contained control element, as long as the `for` attribute points to the contained control element."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/label"
            }
          ]
        },
        {
          "name": "input",
          "description": {
            "kind": "markdown",
            "value": "The input element represents a typed data field, usually with a form control to allow the user to edit the data."
          },
          "attributes": [
            {
              "name": "accept"
            },
            {
              "name": "alt"
            },
            {
              "name": "autocomplete",
              "valueSet": "inputautocomplete"
            },
            {
              "name": "autofocus",
              "valueSet": "v"
            },
            {
              "name": "checked",
              "valueSet": "v"
            },
            {
              "name": "dirname"
            },
            {
              "name": "disabled",
              "valueSet": "v"
            },
            {
              "name": "form"
            },
            {
              "name": "formaction"
            },
            {
              "name": "formenctype",
              "valueSet": "et"
            },
            {
              "name": "formmethod",
              "valueSet": "fm"
            },
            {
              "name": "formnovalidate",
              "valueSet": "v"
            },
            {
              "name": "formtarget"
            },
            {
              "name": "height"
            },
            {
              "name": "inputmode",
              "valueSet": "im"
            },
            {
              "name": "list"
            },
            {
              "name": "max"
            },
            {
              "name": "maxlength"
            },
            {
              "name": "min"
            },
            {
              "name": "minlength"
            },
            {
              "name": "multiple",
              "valueSet": "v"
            },
            {
              "name": "name"
            },
            {
              "name": "pattern"
            },
            {
              "name": "placeholder"
            },
            {
              "name": "readonly",
              "valueSet": "v"
            },
            {
              "name": "required",
              "valueSet": "v"
            },
            {
              "name": "size"
            },
            {
              "name": "src"
            },
            {
              "name": "step"
            },
            {
              "name": "type",
              "valueSet": "t"
            },
            {
              "name": "value"
            },
            {
              "name": "width"
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/input"
            }
          ]
        },
        {
          "name": "button",
          "description": {
            "kind": "markdown",
            "value": "The button element represents a button labeled by its contents."
          },
          "attributes": [
            {
              "name": "autofocus",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute lets you specify that the button should have input focus when the page loads, unless the user overrides it, for example by typing in a different control. Only one form-associated element in a document can have this attribute specified."
              }
            },
            {
              "name": "disabled",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'This Boolean attribute indicates that the user cannot interact with the button. If this attribute is not specified, the button inherits its setting from the containing element, for example [`<fieldset>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset "The HTML <fieldset> element is used to group several controls as well as labels (<label>) within a web form."); if there is no containing element with the **disabled** attribute set, then the button is enabled.\n\nFirefox will, unlike other browsers, by default, [persist the dynamic disabled state](https://stackoverflow.com/questions/5985839/bug-with-firefox-disabled-attribute-of-input-not-resetting-when-refreshing) of a [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") across page loads. Use the [`autocomplete`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#attr-autocomplete) attribute to control this feature.'
              }
            },
            {
              "name": "form",
              "description": {
                "kind": "markdown",
                "value": 'The form element that the button is associated with (its _form owner_). The value of the attribute must be the **id** attribute of a [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") element in the same document. If this attribute is not specified, the `<button>` element will be associated to an ancestor [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") element, if one exists. This attribute enables you to associate `<button>` elements to [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") elements anywhere within a document, not just as descendants of [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") elements.'
              }
            },
            {
              "name": "formaction",
              "description": {
                "kind": "markdown",
                "value": "The URI of a program that processes the information submitted by the button. If specified, it overrides the [`action`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-action) attribute of the button's form owner."
              }
            },
            {
              "name": "formenctype",
              "valueSet": "et",
              "description": {
                "kind": "markdown",
                "value": 'If the button is a submit button, this attribute specifies the type of content that is used to submit the form to the server. Possible values are:\n\n*   `application/x-www-form-urlencoded`: The default value if the attribute is not specified.\n*   `multipart/form-data`: Use this value if you are using an [`<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") element with the [`type`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) attribute set to `file`.\n*   `text/plain`\n\nIf this attribute is specified, it overrides the [`enctype`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-enctype) attribute of the button\'s form owner.'
              }
            },
            {
              "name": "formmethod",
              "valueSet": "fm",
              "description": {
                "kind": "markdown",
                "value": "If the button is a submit button, this attribute specifies the HTTP method that the browser uses to submit the form. Possible values are:\n\n*   `post`: The data from the form are included in the body of the form and sent to the server.\n*   `get`: The data from the form are appended to the **form** attribute URI, with a '?' as a separator, and the resulting URI is sent to the server. Use this method when the form has no side-effects and contains only ASCII characters.\n\nIf specified, this attribute overrides the [`method`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-method) attribute of the button's form owner."
              }
            },
            {
              "name": "formnovalidate",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "If the button is a submit button, this Boolean attribute specifies that the form is not to be validated when it is submitted. If this attribute is specified, it overrides the [`novalidate`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-novalidate) attribute of the button's form owner."
              }
            },
            {
              "name": "formtarget",
              "description": {
                "kind": "markdown",
                "value": "If the button is a submit button, this attribute is a name or keyword indicating where to display the response that is received after submitting the form. This is a name of, or keyword for, a _browsing context_ (for example, tab, window, or inline frame). If this attribute is specified, it overrides the [`target`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-target) attribute of the button's form owner. The following keywords have special meanings:\n\n*   `_self`: Load the response into the same browsing context as the current one. This value is the default if the attribute is not specified.\n*   `_blank`: Load the response into a new unnamed browsing context.\n*   `_parent`: Load the response into the parent browsing context of the current one. If there is no parent, this option behaves the same way as `_self`.\n*   `_top`: Load the response into the top-level browsing context (that is, the browsing context that is an ancestor of the current one, and has no parent). If there is no parent, this option behaves the same way as `_self`."
              }
            },
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": "The name of the button, which is submitted with the form data."
              }
            },
            {
              "name": "type",
              "valueSet": "bt",
              "description": {
                "kind": "markdown",
                "value": "The type of the button. Possible values are:\n\n*   `submit`: The button submits the form data to the server. This is the default if the attribute is not specified, or if the attribute is dynamically changed to an empty or invalid value.\n*   `reset`: The button resets all the controls to their initial values.\n*   `button`: The button has no default behavior. It can have client-side scripts associated with the element's events, which are triggered when the events occur."
              }
            },
            {
              "name": "value",
              "description": {
                "kind": "markdown",
                "value": "The initial value of the button. It defines the value associated with the button which is submitted with the form data. This value is passed to the server in params when the form is submitted."
              }
            },
            {
              "name": "autocomplete",
              "description": 'The use of this attribute on a [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") is nonstandard and Firefox-specific. By default, unlike other browsers, [Firefox persists the dynamic disabled state](https://stackoverflow.com/questions/5985839/bug-with-firefox-disabled-attribute-of-input-not-resetting-when-refreshing) of a [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button "The HTML <button> element represents a clickable button, which can be used in forms or anywhere in a document that needs simple, standard button functionality.") across page loads. Setting the value of this attribute to `off` (i.e. `autocomplete="off"`) disables this feature. See [bug\xA0654072](https://bugzilla.mozilla.org/show_bug.cgi?id=654072 "if disabled state is changed with javascript, the normal state doesn\'t return after refreshing the page").'
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/button"
            }
          ]
        },
        {
          "name": "select",
          "description": {
            "kind": "markdown",
            "value": "The select element represents a control for selecting amongst a set of options."
          },
          "attributes": [
            {
              "name": "autocomplete",
              "valueSet": "inputautocomplete",
              "description": {
                "kind": "markdown",
                "value": 'A [`DOMString`](https://developer.mozilla.org/en-US/docs/Web/API/DOMString "DOMString is a UTF-16 String. As JavaScript already uses such strings, DOMString is mapped directly to a String.") providing a hint for a [user agent\'s](https://developer.mozilla.org/en-US/docs/Glossary/user_agent "user agent\'s: A user agent is a computer program representing a person, for example, a browser in a Web context.") autocomplete feature. See [The HTML autocomplete attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) for a complete list of values and details on how to use autocomplete.'
              }
            },
            {
              "name": "autofocus",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute lets you specify that a form control should have input focus when the page loads. Only one form element in a document can have the `autofocus` attribute."
              }
            },
            {
              "name": "disabled",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute indicates that the user cannot interact with the control. If this attribute is not specified, the control inherits its setting from the containing element, for example `fieldset`; if there is no containing element with the `disabled` attribute set, then the control is enabled."
              }
            },
            {
              "name": "form",
              "description": {
                "kind": "markdown",
                "value": 'This attribute lets you specify the form element to\xA0which\xA0the select element is associated\xA0(that is, its "form owner"). If this attribute is specified, its value must be the same as the `id` of a form element in the same document. This enables you to place select elements anywhere within a document, not just as descendants of their form elements.'
              }
            },
            {
              "name": "multiple",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute indicates that multiple options can be selected in the list. If it is not specified, then only one option can be selected at a time. When `multiple` is specified, most browsers will show a scrolling list box instead of a single line dropdown."
              }
            },
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": "This attribute is used to specify the name of the control."
              }
            },
            {
              "name": "required",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "A Boolean attribute indicating that an option with a non-empty string value must be selected."
              }
            },
            {
              "name": "size",
              "description": {
                "kind": "markdown",
                "value": "If the control is presented as a scrolling list box (e.g. when `multiple` is specified), this attribute represents the number of rows in the list that should be visible at one time. Browsers are not required to present a select element as a scrolled list box. The default value is 0.\n\n**Note:** According to the HTML5 specification, the default value for size should be 1; however, in practice, this has been found to break some web sites, and no other browser currently does that, so Mozilla has opted to continue to return 0 for the time being with Firefox."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/select"
            }
          ]
        },
        {
          "name": "datalist",
          "description": {
            "kind": "markdown",
            "value": "The datalist element represents a set of option elements that represent predefined options for other controls. In the rendering, the datalist element represents nothing and it, along with its children, should be hidden."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/datalist"
            }
          ]
        },
        {
          "name": "optgroup",
          "description": {
            "kind": "markdown",
            "value": "The optgroup element represents a group of option elements with a common label."
          },
          "attributes": [
            {
              "name": "disabled",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "If this Boolean attribute is set, none of the items in this option group is selectable. Often browsers grey out such control and it won't receive any browsing events, like mouse clicks or focus-related ones."
              }
            },
            {
              "name": "label",
              "description": {
                "kind": "markdown",
                "value": "The name of the group of options, which the browser can use when labeling the options in the user interface. This attribute is mandatory if this element is used."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/optgroup"
            }
          ]
        },
        {
          "name": "option",
          "description": {
            "kind": "markdown",
            "value": "The option element represents an option in a select element or as part of a list of suggestions in a datalist element."
          },
          "attributes": [
            {
              "name": "disabled",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'If this Boolean attribute is set, this option is not checkable. Often browsers grey out such control and it won\'t receive any browsing event, like mouse clicks or focus-related ones. If this attribute is not set, the element can still be disabled if one of its ancestors is a disabled [`<optgroup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup "The HTML <optgroup> element creates a grouping of options within a <select> element.") element.'
              }
            },
            {
              "name": "label",
              "description": {
                "kind": "markdown",
                "value": "This attribute is text for the label indicating the meaning of the option. If the `label` attribute isn't defined, its value is that of the element text content."
              }
            },
            {
              "name": "selected",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'If present, this Boolean attribute indicates that the option is initially selected. If the `<option>` element is the descendant of a [`<select>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select "The HTML <select> element represents a control that provides a menu of options") element whose [`multiple`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#attr-multiple) attribute is not set, only one single `<option>` of this [`<select>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select "The HTML <select> element represents a control that provides a menu of options") element may have the `selected` attribute.'
              }
            },
            {
              "name": "value",
              "description": {
                "kind": "markdown",
                "value": "The content of this attribute represents the value to be submitted with the form, should this option be selected.\xA0If this attribute is omitted, the value is taken from the text content of the option element."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/option"
            }
          ]
        },
        {
          "name": "textarea",
          "description": {
            "kind": "markdown",
            "value": "The textarea element represents a multiline plain text edit control for the element's raw value. The contents of the control represent the control's default value."
          },
          "attributes": [
            {
              "name": "autocomplete",
              "valueSet": "inputautocomplete",
              "description": {
                "kind": "markdown",
                "value": 'This attribute indicates whether the value of the control can be automatically completed by the browser. Possible values are:\n\n*   `off`: The user must explicitly enter a value into this field for every use, or the document provides its own auto-completion method; the browser does not automatically complete the entry.\n*   `on`: The browser can automatically complete the value based on values that the user has entered during previous uses.\n\nIf the `autocomplete` attribute is not specified on a `<textarea>` element, then the browser uses the `autocomplete` attribute value of the `<textarea>` element\'s form owner. The form owner is either the [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") element that this `<textarea>` element is a descendant of or the form element whose `id` is specified by the `form` attribute of the input element. For more information, see the [`autocomplete`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-autocomplete) attribute in [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.").'
              }
            },
            {
              "name": "autofocus",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute lets you specify that a form control should have input focus when the page loads. Only one form-associated element in a document can have this attribute specified."
              }
            },
            {
              "name": "cols",
              "description": {
                "kind": "markdown",
                "value": "The visible width of the text control, in average character widths. If it is specified, it must be a positive integer. If it is not specified, the default value is `20`."
              }
            },
            {
              "name": "dirname"
            },
            {
              "name": "disabled",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'This Boolean attribute indicates that the user cannot interact with the control. If this attribute is not specified, the control inherits its setting from the containing element, for example [`<fieldset>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset "The HTML <fieldset> element is used to group several controls as well as labels (<label>) within a web form."); if there is no containing element when the `disabled` attribute is set, the control is enabled.'
              }
            },
            {
              "name": "form",
              "description": {
                "kind": "markdown",
                "value": 'The form element that the `<textarea>` element is associated with (its "form owner"). The value of the attribute must be the `id` of a form element in the same document. If this attribute is not specified, the `<textarea>` element must be a descendant of a form element. This attribute enables you to place `<textarea>` elements anywhere within a document, not just as descendants of form elements.'
              }
            },
            {
              "name": "inputmode",
              "valueSet": "im"
            },
            {
              "name": "maxlength",
              "description": {
                "kind": "markdown",
                "value": "The maximum number of characters (unicode code points) that the user can enter. If this value isn't specified, the user can enter an unlimited number of characters."
              }
            },
            {
              "name": "minlength",
              "description": {
                "kind": "markdown",
                "value": "The minimum number of characters (unicode code points) required that the user should enter."
              }
            },
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": "The name of the control."
              }
            },
            {
              "name": "placeholder",
              "description": {
                "kind": "markdown",
                "value": 'A hint to the user of what can be entered in the control. Carriage returns or line-feeds within the placeholder text must be treated as line breaks when rendering the hint.\n\n**Note:** Placeholders should only be used to show an example of the type of data that should be entered into a form; they are _not_ a substitute for a proper [`<label>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label "The HTML <label> element represents a caption for an item in a user interface.") element tied to the input. See [Labels and placeholders](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Labels_and_placeholders "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") in [<input>: The Input (Form Input) element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") for a full explanation.'
              }
            },
            {
              "name": "readonly",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute indicates that the user cannot modify the value of the control. Unlike the `disabled` attribute, the `readonly` attribute does not prevent the user from clicking or selecting in the control. The value of a read-only control is still submitted with the form."
              }
            },
            {
              "name": "required",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This attribute specifies that the user must fill in a value before submitting a form."
              }
            },
            {
              "name": "rows",
              "description": {
                "kind": "markdown",
                "value": "The number of visible text lines for the control."
              }
            },
            {
              "name": "wrap",
              "valueSet": "w",
              "description": {
                "kind": "markdown",
                "value": "Indicates how the control wraps text. Possible values are:\n\n*   `hard`: The browser automatically inserts line breaks (CR+LF) so that each line has no more than the width of the control; the `cols` attribute must also be specified for this to take effect.\n*   `soft`: The browser ensures that all line breaks in the value consist of a CR+LF pair, but does not insert any additional line breaks.\n*   `off` : Like `soft` but changes appearance to `white-space: pre` so line segments exceeding `cols` are not wrapped and the `<textarea>` becomes horizontally scrollable.\n\nIf this attribute is not specified, `soft` is its default value."
              }
            },
            {
              "name": "autocapitalize",
              "description": "This is a non-standard attribute supported by WebKit on iOS (therefore nearly all browsers running on iOS, including Safari, Firefox, and Chrome), which controls whether and how the text value should be automatically capitalized as it is entered/edited by the user. The non-deprecated values are available in iOS 5 and later. Possible values are:\n\n*   `none`: Completely disables automatic capitalization.\n*   `sentences`: Automatically capitalize the first letter of sentences.\n*   `words`: Automatically capitalize the first letter of words.\n*   `characters`: Automatically capitalize all characters.\n*   `on`: Deprecated since iOS 5.\n*   `off`: Deprecated since iOS 5."
            },
            {
              "name": "spellcheck",
              "description": "Specifies whether the `<textarea>` is subject to spell checking by the underlying browser/OS. the value can be:\n\n*   `true`: Indicates that the element needs to have its spelling and grammar checked.\n*   `default` : Indicates that the element is to act according to a default behavior, possibly based on the parent element's own `spellcheck` value.\n*   `false` : Indicates that the element should not be spell checked."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/textarea"
            }
          ]
        },
        {
          "name": "output",
          "description": {
            "kind": "markdown",
            "value": "The output element represents the result of a calculation performed by the application, or the result of a user action."
          },
          "attributes": [
            {
              "name": "for",
              "description": {
                "kind": "markdown",
                "value": "A space-separated list of other elements\u2019 [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id)s, indicating that those elements contributed input values to (or otherwise affected) the calculation."
              }
            },
            {
              "name": "form",
              "description": {
                "kind": "markdown",
                "value": 'The [form element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) that this element is associated with (its "form owner"). The value of the attribute must be an `id` of a form element in the same document. If this attribute is not specified, the output element must be a descendant of a form element. This attribute enables you to place output elements anywhere within a document, not just as descendants of their form elements.'
              }
            },
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": 'The name of the element, exposed in the [`HTMLFormElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement "The HTMLFormElement interface represents a <form> element in the DOM; it allows access to and in some cases modification of aspects of the form, as well as access to its component elements.") API.'
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/output"
            }
          ]
        },
        {
          "name": "progress",
          "description": {
            "kind": "markdown",
            "value": "The progress element represents the completion progress of a task. The progress is either indeterminate, indicating that progress is being made but that it is not clear how much more work remains to be done before the task is complete (e.g. because the task is waiting for a remote host to respond), or the progress is a number in the range zero to a maximum, giving the fraction of work that has so far been completed."
          },
          "attributes": [
            {
              "name": "value",
              "description": {
                "kind": "markdown",
                "value": "This attribute specifies how much of the task that has been completed. It must be a valid floating point number between 0 and `max`, or between 0 and 1 if `max` is omitted. If there is no `value` attribute, the progress bar is indeterminate; this indicates that an activity is ongoing with no indication of how long it is expected to take."
              }
            },
            {
              "name": "max",
              "description": {
                "kind": "markdown",
                "value": "This attribute describes how much work the task indicated by the `progress` element requires. The `max` attribute, if present, must have a value greater than zero and be a valid floating point number. The default value is 1."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/progress"
            }
          ]
        },
        {
          "name": "meter",
          "description": {
            "kind": "markdown",
            "value": "The meter element represents a scalar measurement within a known range, or a fractional value; for example disk usage, the relevance of a query result, or the fraction of a voting population to have selected a particular candidate."
          },
          "attributes": [
            {
              "name": "value",
              "description": {
                "kind": "markdown",
                "value": "The current numeric value. This must be between the minimum and maximum values (`min` attribute and `max` attribute) if they are specified. If unspecified or malformed, the value is 0. If specified, but not within the range given by the `min` attribute and `max` attribute, the value is equal to the nearest end of the range.\n\n**Usage note:** Unless the `value` attribute is between `0` and `1` (inclusive), the `min` and `max` attributes should define the range so that the `value` attribute's value is within it."
              }
            },
            {
              "name": "min",
              "description": {
                "kind": "markdown",
                "value": "The lower numeric bound of the measured range. This must be less than the maximum value (`max` attribute), if specified. If unspecified, the minimum value is 0."
              }
            },
            {
              "name": "max",
              "description": {
                "kind": "markdown",
                "value": "The upper numeric bound of the measured range. This must be greater than the minimum value (`min` attribute), if specified. If unspecified, the maximum value is 1."
              }
            },
            {
              "name": "low",
              "description": {
                "kind": "markdown",
                "value": "The upper numeric bound of the low end of the measured range. This must be greater than the minimum value (`min` attribute), and it also must be less than the high value and maximum value (`high` attribute and `max` attribute, respectively), if any are specified. If unspecified, or if less than the minimum value, the `low` value is equal to the minimum value."
              }
            },
            {
              "name": "high",
              "description": {
                "kind": "markdown",
                "value": "The lower numeric bound of the high end of the measured range. This must be less than the maximum value (`max` attribute), and it also must be greater than the low value and minimum value (`low` attribute and **min** attribute, respectively), if any are specified. If unspecified, or if greater than the maximum value, the `high` value is equal to the maximum value."
              }
            },
            {
              "name": "optimum",
              "description": {
                "kind": "markdown",
                "value": "This attribute indicates the optimal numeric value. It must be within the range (as defined by the `min` attribute and `max` attribute). When used with the `low` attribute and `high` attribute, it gives an indication where along the range is considered preferable. For example, if it is between the `min` attribute and the `low` attribute, then the lower range is considered preferred."
              }
            },
            {
              "name": "form",
              "description": "This attribute associates the element with a `form` element that has ownership of the `meter` element. For example, a `meter` might be displaying a range corresponding to an `input` element of `type` _number_. This attribute is only used if the `meter` element is being used as a form-associated element; even then, it may be omitted if the element appears as a descendant of a `form` element."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/meter"
            }
          ]
        },
        {
          "name": "fieldset",
          "description": {
            "kind": "markdown",
            "value": "The fieldset element represents a set of form controls optionally grouped under a common name."
          },
          "attributes": [
            {
              "name": "disabled",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "If this Boolean attribute is set, all form controls that are descendants of the `<fieldset>`, are disabled, meaning they are not editable and won't be submitted along with the `<form>`. They won't receive any browsing events, like mouse clicks or focus-related events. By default browsers display such controls grayed out. Note that form elements inside the [`<legend>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend \"The HTML <legend> element represents a caption for the content of its parent <fieldset>.\") element won't be disabled."
              }
            },
            {
              "name": "form",
              "description": {
                "kind": "markdown",
                "value": 'This attribute takes the value of the `id` attribute of a [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form "The HTML <form> element represents a document section that contains interactive controls for submitting information to a web server.") element you want the `<fieldset>` to be part of, even if it is not inside the form.'
              }
            },
            {
              "name": "name",
              "description": {
                "kind": "markdown",
                "value": 'The name associated with the group.\n\n**Note**: The caption for the fieldset is given by the first [`<legend>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend "The HTML <legend> element represents a caption for the content of its parent <fieldset>.") element nested inside it.'
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/fieldset"
            }
          ]
        },
        {
          "name": "legend",
          "description": {
            "kind": "markdown",
            "value": "The legend element represents a caption for the rest of the contents of the legend element's parent fieldset element, if any."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/legend"
            }
          ]
        },
        {
          "name": "details",
          "description": {
            "kind": "markdown",
            "value": "The details element represents a disclosure widget from which the user can obtain additional information or controls."
          },
          "attributes": [
            {
              "name": "open",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": "This Boolean attribute indicates whether or not the details \u2014 that is, the contents of the `<details>` element \u2014 are currently visible. The default, `false`, means the details are not visible."
              }
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/details"
            }
          ]
        },
        {
          "name": "summary",
          "description": {
            "kind": "markdown",
            "value": "The summary element represents a summary, caption, or legend for the rest of the contents of the summary element's parent details element, if any."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/summary"
            }
          ]
        },
        {
          "name": "dialog",
          "description": {
            "kind": "markdown",
            "value": "The dialog element represents a part of an application that a user interacts with to perform a task, for example a dialog box, inspector, or window."
          },
          "attributes": [
            {
              "name": "open",
              "description": "Indicates that the dialog is active and available for interaction. When the `open` attribute is not set, the dialog shouldn't be shown to the user."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/dialog"
            }
          ]
        },
        {
          "name": "script",
          "description": {
            "kind": "markdown",
            "value": "The script element allows authors to include dynamic script and data blocks in their documents. The element does not represent content for the user."
          },
          "attributes": [
            {
              "name": "src",
              "description": {
                "kind": "markdown",
                "value": "This attribute specifies the URI of an external script; this can be used as an alternative to embedding a script directly within a document.\n\nIf a `script` element has a `src` attribute specified, it should not have a script embedded inside its tags."
              }
            },
            {
              "name": "type",
              "description": {
                "kind": "markdown",
                "value": 'This attribute indicates the type of script represented. The value of this attribute will be in one of the following categories:\n\n*   **Omitted or a JavaScript MIME type:** For HTML5-compliant browsers this indicates the script is JavaScript. HTML5 specification urges authors to omit the attribute rather than provide a redundant MIME type. In earlier browsers, this identified the scripting language of the embedded or imported (via the `src` attribute) code. JavaScript MIME types are [listed in the specification](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#JavaScript_types).\n*   **`module`:** For HTML5-compliant browsers the code is treated as a JavaScript module. The processing of the script contents is not affected by the `charset` and `defer` attributes. For information on using `module`, see [ES6 in Depth: Modules](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/). Code may behave differently when the `module` keyword is used.\n*   **Any other value:** The embedded content is treated as a data block which won\'t be processed by the browser. Developers must use a valid MIME type that is not a JavaScript MIME type to denote data blocks. The `src` attribute will be ignored.\n\n**Note:** in Firefox you could specify the version of JavaScript contained in a `<script>` element by including a non-standard `version` parameter inside the `type` attribute \u2014 for example `type="text/javascript;version=1.8"`. This has been removed in Firefox 59 (see [bug\xA01428745](https://bugzilla.mozilla.org/show_bug.cgi?id=1428745 "FIXED: Remove support for version parameter from script loader")).'
              }
            },
            {
              "name": "charset"
            },
            {
              "name": "async",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'This is a Boolean attribute indicating that the browser should, if possible, load the script asynchronously.\n\nThis attribute must not be used if the `src` attribute is absent (i.e. for inline scripts). If it is included in this case it will have no effect.\n\nBrowsers usually assume the worst case scenario and load scripts synchronously, (i.e. `async="false"`) during HTML parsing.\n\nDynamically inserted scripts (using [`document.createElement()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement "In an HTML document, the document.createElement() method creates the HTML element specified by tagName, or an HTMLUnknownElement if tagName isn\'t recognized.")) load asynchronously by default, so to turn on synchronous loading (i.e. scripts load in the order they were inserted) set `async="false"`.\n\nSee [Browser compatibility](#Browser_compatibility) for notes on browser support. See also [Async scripts for asm.js](https://developer.mozilla.org/en-US/docs/Games/Techniques/Async_scripts).'
              }
            },
            {
              "name": "defer",
              "valueSet": "v",
              "description": {
                "kind": "markdown",
                "value": 'This Boolean attribute is set to indicate to a browser that the script is meant to be executed after the document has been parsed, but before firing [`DOMContentLoaded`](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded "/en-US/docs/Web/Events/DOMContentLoaded").\n\nScripts with the `defer` attribute will prevent the `DOMContentLoaded` event from firing until the script has loaded and finished evaluating.\n\nThis attribute must not be used if the `src` attribute is absent (i.e. for inline scripts), in this case it would have no effect.\n\nTo achieve a similar effect for dynamically inserted scripts use `async="false"` instead. Scripts with the `defer` attribute will execute in the order in which they appear in the document.'
              }
            },
            {
              "name": "crossorigin",
              "valueSet": "xo",
              "description": {
                "kind": "markdown",
                "value": 'Normal `script` elements pass minimal information to the [`window.onerror`](https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror "The onerror property of the GlobalEventHandlers mixin is an EventHandler that processes error events.") for scripts which do not pass the standard [CORS](https://developer.mozilla.org/en-US/docs/Glossary/CORS "CORS: CORS (Cross-Origin Resource Sharing) is a system, consisting of transmitting HTTP headers, that determines whether browsers block frontend JavaScript code from accessing responses for cross-origin requests.") checks. To allow error logging for sites which use a separate domain for static media, use this attribute. See [CORS settings attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for a more descriptive explanation of its valid arguments.'
              }
            },
            {
              "name": "nonce",
              "description": {
                "kind": "markdown",
                "value": "A cryptographic nonce (number used once) to whitelist inline scripts in a [script-src Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src). The server must generate a unique nonce value each time it transmits a policy. It is critical to provide a nonce that cannot be guessed as bypassing a resource's policy is otherwise trivial."
              }
            },
            {
              "name": "integrity",
              "description": "This attribute contains inline metadata that a user agent can use to verify that a fetched resource has been delivered free of unexpected manipulation. See [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)."
            },
            {
              "name": "nomodule",
              "description": "This Boolean attribute is set to indicate that the script should not be executed in browsers that support [ES2015 modules](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/) \u2014 in effect, this can be used to serve fallback scripts to older browsers that do not support modular JavaScript code."
            },
            {
              "name": "referrerpolicy",
              "description": 'Indicates which [referrer](https://developer.mozilla.org/en-US/docs/Web/API/Document/referrer) to send when fetching the script, or resources fetched by the script:\n\n*   `no-referrer`: The [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer "The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.") header will not be sent.\n*   `no-referrer-when-downgrade` (default): The [`Referer`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer "The Referer request header contains the address of the previous web page from which a link to the currently requested page was followed. The Referer header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.") header will not be sent to [origin](https://developer.mozilla.org/en-US/docs/Glossary/origin "origin: Web content\'s origin is defined by the scheme (protocol), host (domain), and port of the URL used to access it. Two objects have the same origin only when the scheme, host, and port all match.")s without [TLS](https://developer.mozilla.org/en-US/docs/Glossary/TLS "TLS: Transport Layer Security (TLS), previously known as Secure Sockets Layer (SSL), is a protocol used by applications to communicate securely across a network, preventing tampering with and eavesdropping on email, web browsing, messaging, and other protocols.") ([HTTPS](https://developer.mozilla.org/en-US/docs/Glossary/HTTPS "HTTPS: HTTPS (HTTP Secure) is an encrypted version of the HTTP protocol. It usually uses SSL or TLS to encrypt all communication between a client and a server. This secure connection allows clients to safely exchange sensitive data with a server, for example for banking activities or online shopping.")).\n*   `origin`: The sent referrer will be limited to the origin of the referring page: its [scheme](https://developer.mozilla.org/en-US/docs/Archive/Mozilla/URIScheme), [host](https://developer.mozilla.org/en-US/docs/Glossary/host "host: A host is a device connected to the Internet (or a local network). Some hosts called servers offer additional services like serving webpages or storing files and emails."), and [port](https://developer.mozilla.org/en-US/docs/Glossary/port "port: For a computer connected to a network with an IP address, a port is a communication endpoint. Ports are designated by numbers, and below 1024 each port is associated by default with a specific protocol.").\n*   `origin-when-cross-origin`: The referrer sent to other origins will be limited to the scheme, the host, and the port. Navigations on the same origin will still include the path.\n*   `same-origin`: A referrer will be sent for [same origin](https://developer.mozilla.org/en-US/docs/Glossary/Same-origin_policy "same origin: The same-origin policy is a critical security mechanism that restricts how a document or script loaded from one origin can interact with a resource from another origin."), but cross-origin requests will contain no referrer information.\n*   `strict-origin`: Only send the origin of the document as the referrer when the protocol security level stays the same (e.g. HTTPS\u2192HTTPS), but don\'t send it to a less secure destination (e.g. HTTPS\u2192HTTP).\n*   `strict-origin-when-cross-origin`: Send a full URL when performing a same-origin request, but only send the origin when the protocol security level stays the same (e.g.HTTPS\u2192HTTPS), and send no header to a less secure destination (e.g. HTTPS\u2192HTTP).\n*   `unsafe-url`: The referrer will include the origin _and_ the path (but not the [fragment](https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash), [password](https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/password), or [username](https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/username)). **This value is unsafe**, because it leaks origins and paths from TLS-protected resources to insecure origins.\n\n**Note**: An empty string value (`""`) is both the default value, and a fallback value if `referrerpolicy` is not supported. If `referrerpolicy` is not explicitly specified on the `<script>` element, it will adopt a higher-level referrer policy, i.e. one set on the whole document or domain. If a higher-level policy is not available,\xA0the empty string is treated as being equivalent to `no-referrer-when-downgrade`.'
            },
            {
              "name": "text",
              "description": "Like the `textContent` attribute, this attribute sets the text content of the element. Unlike the `textContent` attribute, however, this attribute is evaluated as executable code after the node is inserted into the DOM."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/script"
            }
          ]
        },
        {
          "name": "noscript",
          "description": {
            "kind": "markdown",
            "value": "The noscript element represents nothing if scripting is enabled, and represents its children if scripting is disabled. It is used to present different markup to user agents that support scripting and those that don't support scripting, by affecting how the document is parsed."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/noscript"
            }
          ]
        },
        {
          "name": "template",
          "description": {
            "kind": "markdown",
            "value": "The template element is used to declare fragments of HTML that can be cloned and inserted in the document by script."
          },
          "attributes": [],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/template"
            }
          ]
        },
        {
          "name": "canvas",
          "description": {
            "kind": "markdown",
            "value": "The canvas element provides scripts with a resolution-dependent bitmap canvas, which can be used for rendering graphs, game graphics, art, or other visual images on the fly."
          },
          "attributes": [
            {
              "name": "width",
              "description": {
                "kind": "markdown",
                "value": "The width of the coordinate space in CSS pixels. Defaults to 300."
              }
            },
            {
              "name": "height",
              "description": {
                "kind": "markdown",
                "value": "The height of the coordinate space in CSS pixels. Defaults to 150."
              }
            },
            {
              "name": "moz-opaque",
              "description": "Lets the canvas know whether or not translucency will be a factor. If the canvas knows there's no translucency, painting performance can be optimized. This is only supported by Mozilla-based browsers; use the standardized [`canvas.getContext('2d', { alpha: false })`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext \"The HTMLCanvasElement.getContext() method returns a drawing context on the canvas, or null if the context identifier is not supported.\") instead."
            }
          ],
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Element/canvas"
            }
          ]
        }
      ],
      "globalAttributes": [
        {
          "name": "accesskey",
          "description": {
            "kind": "markdown",
            "value": "Provides a hint for generating a keyboard shortcut for the current element. This attribute consists of a space-separated list of characters. The browser should use the first one that exists on the computer keyboard layout."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/accesskey"
            }
          ]
        },
        {
          "name": "autocapitalize",
          "description": {
            "kind": "markdown",
            "value": "Controls whether and how text input is automatically capitalized as it is entered/edited by the user. It can have the following values:\n\n*   `off` or `none`, no autocapitalization is applied (all letters default to lowercase)\n*   `on` or `sentences`, the first letter of each sentence defaults to a capital letter; all other letters default to lowercase\n*   `words`, the first letter of each word defaults to a capital letter; all other letters default to lowercase\n*   `characters`, all letters should default to uppercase"
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/autocapitalize"
            }
          ]
        },
        {
          "name": "class",
          "description": {
            "kind": "markdown",
            "value": 'A space-separated list of the classes of the element. Classes allows CSS and JavaScript to select and access specific elements via the [class selectors](/en-US/docs/Web/CSS/Class_selectors) or functions like the method [`Document.getElementsByClassName()`](/en-US/docs/Web/API/Document/getElementsByClassName "returns an array-like object of all child elements which have all of the given class names.").'
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/class"
            }
          ]
        },
        {
          "name": "contenteditable",
          "description": {
            "kind": "markdown",
            "value": "An enumerated attribute indicating if the element should be editable by the user. If so, the browser modifies its widget to allow editing. The attribute must take one of the following values:\n\n*   `true` or the _empty string_, which indicates that the element must be editable;\n*   `false`, which indicates that the element must not be editable."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/contenteditable"
            }
          ]
        },
        {
          "name": "contextmenu",
          "description": {
            "kind": "markdown",
            "value": 'The `[**id**](#attr-id)` of a [`<menu>`](/en-US/docs/Web/HTML/Element/menu "The HTML <menu> element represents a group of commands that a user can perform or activate. This includes both list menus, which might appear across the top of a screen, as well as context menus, such as those that might appear underneath a button after it has been clicked.") to use as the contextual menu for this element.'
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/contextmenu"
            }
          ]
        },
        {
          "name": "dir",
          "description": {
            "kind": "markdown",
            "value": "An enumerated attribute indicating the directionality of the element's text. It can have the following values:\n\n*   `ltr`, which means _left to right_ and is to be used for languages that are written from the left to the right (like English);\n*   `rtl`, which means _right to left_ and is to be used for languages that are written from the right to the left (like Arabic);\n*   `auto`, which lets the user agent decide. It uses a basic algorithm as it parses the characters inside the element until it finds a character with a strong directionality, then it applies that directionality to the whole element."
          },
          "valueSet": "d",
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/dir"
            }
          ]
        },
        {
          "name": "draggable",
          "description": {
            "kind": "markdown",
            "value": "An enumerated attribute indicating whether the element can be dragged, using the [Drag and Drop API](/en-us/docs/DragDrop/Drag_and_Drop). It can have the following values:\n\n*   `true`, which indicates that the element may be dragged\n*   `false`, which indicates that the element may not be dragged."
          },
          "valueSet": "b",
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/draggable"
            }
          ]
        },
        {
          "name": "dropzone",
          "description": {
            "kind": "markdown",
            "value": "An enumerated attribute indicating what types of content can be dropped on an element, using the [Drag and Drop API](/en-US/docs/DragDrop/Drag_and_Drop). It can have the following values:\n\n*   `copy`, which indicates that dropping will create a copy of the element that was dragged\n*   `move`, which indicates that the element that was dragged will be moved to this new location.\n*   `link`, will create a link to the dragged data."
          }
        },
        {
          "name": "exportparts",
          "description": {
            "kind": "markdown",
            "value": "Used to transitively export shadow parts from a nested shadow tree into a containing light tree."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/exportparts"
            }
          ]
        },
        {
          "name": "hidden",
          "description": {
            "kind": "markdown",
            "value": "A Boolean attribute indicates that the element is not yet, or is no longer, _relevant_. For example, it can be used to hide elements of the page that can't be used until the login process has been completed. The browser won't render such elements. This attribute must not be used to hide content that could legitimately be shown."
          },
          "valueSet": "v",
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/hidden"
            }
          ]
        },
        {
          "name": "id",
          "description": {
            "kind": "markdown",
            "value": "Defines a unique identifier (ID) which must be unique in the whole document. Its purpose is to identify the element when linking (using a fragment identifier), scripting, or styling (with CSS)."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/id"
            }
          ]
        },
        {
          "name": "inputmode",
          "description": {
            "kind": "markdown",
            "value": 'Provides a hint to browsers as to the type of virtual keyboard configuration to use when editing this element or its contents. Used primarily on [`<input>`](/en-US/docs/Web/HTML/Element/input "The HTML <input> element is used to create interactive controls for web-based forms in order to accept data from the user; a wide variety of types of input data and control widgets are available, depending on the device and user agent.") elements, but is usable on any element while in `[contenteditable](/en-US/docs/Web/HTML/Global_attributes#attr-contenteditable)` mode.'
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/inputmode"
            }
          ]
        },
        {
          "name": "is",
          "description": {
            "kind": "markdown",
            "value": "Allows you to specify that a standard HTML element should behave like a registered custom built-in element (see [Using custom elements](/en-US/docs/Web/Web_Components/Using_custom_elements) for more details)."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/is"
            }
          ]
        },
        {
          "name": "itemid",
          "description": {
            "kind": "markdown",
            "value": "The unique, global identifier of an item."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/itemid"
            }
          ]
        },
        {
          "name": "itemprop",
          "description": {
            "kind": "markdown",
            "value": "Used to add properties to an item. Every HTML element may have an `itemprop` attribute specified, where an `itemprop` consists of a name and value pair."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/itemprop"
            }
          ]
        },
        {
          "name": "itemref",
          "description": {
            "kind": "markdown",
            "value": "Properties that are not descendants of an element with the `itemscope` attribute can be associated with the item using an `itemref`. It provides a list of element ids (not `itemid`s) with additional properties elsewhere in the document."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/itemref"
            }
          ]
        },
        {
          "name": "itemscope",
          "description": {
            "kind": "markdown",
            "value": "`itemscope` (usually) works along with `[itemtype](/en-US/docs/Web/HTML/Global_attributes#attr-itemtype)` to specify that the HTML contained in a block is about a particular item. `itemscope` creates the Item and defines the scope of the `itemtype` associated with it. `itemtype` is a valid URL of a vocabulary (such as [schema.org](https://schema.org/)) that describes the item and its properties context."
          },
          "valueSet": "v",
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/itemscope"
            }
          ]
        },
        {
          "name": "itemtype",
          "description": {
            "kind": "markdown",
            "value": "Specifies the URL of the vocabulary that will be used to define `itemprop`s (item properties) in the data structure. `[itemscope](/en-US/docs/Web/HTML/Global_attributes#attr-itemscope)` is used to set the scope of where in the data structure the vocabulary set by `itemtype` will be active."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/itemtype"
            }
          ]
        },
        {
          "name": "lang",
          "description": {
            "kind": "markdown",
            "value": "Helps define the language of an element: the language that non-editable elements are in, or the language that editable elements should be written in by the user. The attribute contains one \u201Clanguage tag\u201D (made of hyphen-separated \u201Clanguage subtags\u201D) in the format defined in [_Tags for Identifying Languages (BCP47)_](https://www.ietf.org/rfc/bcp/bcp47.txt). [**xml:lang**](#attr-xml:lang) has priority over it."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/lang"
            }
          ]
        },
        {
          "name": "part",
          "description": {
            "kind": "markdown",
            "value": 'A space-separated list of the part names of the element. Part names allows CSS to select and style specific elements in a shadow tree via the [`::part`](/en-US/docs/Web/CSS/::part "The ::part CSS pseudo-element represents any element within a shadow tree that has a matching part attribute.") pseudo-element.'
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/part"
            }
          ]
        },
        {
          "name": "role",
          "valueSet": "roles"
        },
        {
          "name": "slot",
          "description": {
            "kind": "markdown",
            "value": "Assigns a slot in a [shadow DOM](/en-US/docs/Web/Web_Components/Shadow_DOM) shadow tree to an element: An element with a `slot` attribute is assigned to the slot created by the [`<slot>`](/en-US/docs/Web/HTML/Element/slot \"The HTML <slot> element\u2014part of the Web Components technology suite\u2014is a placeholder inside a web component that you can fill with your own markup, which lets you create separate DOM trees and present them together.\") element whose `[name](/en-US/docs/Web/HTML/Element/slot#attr-name)` attribute's value matches that `slot` attribute's value."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/slot"
            }
          ]
        },
        {
          "name": "spellcheck",
          "description": {
            "kind": "markdown",
            "value": "An enumerated attribute defines whether the element may be checked for spelling errors. It may have the following values:\n\n*   `true`, which indicates that the element should be, if possible, checked for spelling errors;\n*   `false`, which indicates that the element should not be checked for spelling errors."
          },
          "valueSet": "b",
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/spellcheck"
            }
          ]
        },
        {
          "name": "style",
          "description": {
            "kind": "markdown",
            "value": 'Contains [CSS](/en-US/docs/Web/CSS) styling declarations to be applied to the element. Note that it is recommended for styles to be defined in a separate file or files. This attribute and the [`<style>`](/en-US/docs/Web/HTML/Element/style "The HTML <style> element contains style information for a document, or part of a document.") element have mainly the purpose of allowing for quick styling, for example for testing purposes.'
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/style"
            }
          ]
        },
        {
          "name": "tabindex",
          "description": {
            "kind": "markdown",
            "value": "An integer attribute indicating if the element can take input focus (is _focusable_), if it should participate to sequential keyboard navigation, and if so, at what position. It can take several values:\n\n*   a _negative value_ means that the element should be focusable, but should not be reachable via sequential keyboard navigation;\n*   `0` means that the element should be focusable and reachable via sequential keyboard navigation, but its relative order is defined by the platform convention;\n*   a _positive value_ means that the element should be focusable and reachable via sequential keyboard navigation; the order in which the elements are focused is the increasing value of the [**tabindex**](#attr-tabindex). If several elements share the same tabindex, their relative order follows their relative positions in the document."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/tabindex"
            }
          ]
        },
        {
          "name": "title",
          "description": {
            "kind": "markdown",
            "value": "Contains a text representing advisory information related to the element it belongs to. Such information can typically, but not necessarily, be presented to the user as a tooltip."
          },
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/title"
            }
          ]
        },
        {
          "name": "translate",
          "description": {
            "kind": "markdown",
            "value": "An enumerated attribute that is used to specify whether an element's attribute values and the values of its [`Text`](/en-US/docs/Web/API/Text \"The Text interface represents the textual content of Element or Attr. If an element has no markup within its content, it has a single child implementing Text that contains the element's text. However, if the element contains markup, it is parsed into information items and Text nodes that form its children.\") node children are to be translated when the page is localized, or whether to leave them unchanged. It can have the following values:\n\n*   empty string and `yes`, which indicates that the element will be translated.\n*   `no`, which indicates that the element will not be translated."
          },
          "valueSet": "y",
          "references": [
            {
              "name": "MDN Reference",
              "url": "https://developer.mozilla.org/docs/Web/HTML/Global_attributes/translate"
            }
          ]
        },
        {
          "name": "onabort",
          "description": {
            "kind": "markdown",
            "value": "The loading of a resource has been aborted."
          }
        },
        {
          "name": "onblur",
          "description": {
            "kind": "markdown",
            "value": "An element has lost focus (does not bubble)."
          }
        },
        {
          "name": "oncanplay",
          "description": {
            "kind": "markdown",
            "value": "The user agent can play the media, but estimates that not enough data has been loaded to play the media up to its end without having to stop for further buffering of content."
          }
        },
        {
          "name": "oncanplaythrough",
          "description": {
            "kind": "markdown",
            "value": "The user agent can play the media up to its end without having to stop for further buffering of content."
          }
        },
        {
          "name": "onchange",
          "description": {
            "kind": "markdown",
            "value": "The change event is fired for <input>, <select>, and <textarea> elements when a change to the element's value is committed by the user."
          }
        },
        {
          "name": "onclick",
          "description": {
            "kind": "markdown",
            "value": "A pointing device button has been pressed and released on an element."
          }
        },
        {
          "name": "oncontextmenu",
          "description": {
            "kind": "markdown",
            "value": "The right button of the mouse is clicked (before the context menu is displayed)."
          }
        },
        {
          "name": "ondblclick",
          "description": {
            "kind": "markdown",
            "value": "A pointing device button is clicked twice on an element."
          }
        },
        {
          "name": "ondrag",
          "description": {
            "kind": "markdown",
            "value": "An element or text selection is being dragged (every 350ms)."
          }
        },
        {
          "name": "ondragend",
          "description": {
            "kind": "markdown",
            "value": "A drag operation is being ended (by releasing a mouse button or hitting the escape key)."
          }
        },
        {
          "name": "ondragenter",
          "description": {
            "kind": "markdown",
            "value": "A dragged element or text selection enters a valid drop target."
          }
        },
        {
          "name": "ondragleave",
          "description": {
            "kind": "markdown",
            "value": "A dragged element or text selection leaves a valid drop target."
          }
        },
        {
          "name": "ondragover",
          "description": {
            "kind": "markdown",
            "value": "An element or text selection is being dragged over a valid drop target (every 350ms)."
          }
        },
        {
          "name": "ondragstart",
          "description": {
            "kind": "markdown",
            "value": "The user starts dragging an element or text selection."
          }
        },
        {
          "name": "ondrop",
          "description": {
            "kind": "markdown",
            "value": "An element is dropped on a valid drop target."
          }
        },
        {
          "name": "ondurationchange",
          "description": {
            "kind": "markdown",
            "value": "The duration attribute has been updated."
          }
        },
        {
          "name": "onemptied",
          "description": {
            "kind": "markdown",
            "value": "The media has become empty; for example, this event is sent if the media has already been loaded (or partially loaded), and the load() method is called to reload it."
          }
        },
        {
          "name": "onended",
          "description": {
            "kind": "markdown",
            "value": "Playback has stopped because the end of the media was reached."
          }
        },
        {
          "name": "onerror",
          "description": {
            "kind": "markdown",
            "value": "A resource failed to load."
          }
        },
        {
          "name": "onfocus",
          "description": {
            "kind": "markdown",
            "value": "An element has received focus (does not bubble)."
          }
        },
        {
          "name": "onformchange"
        },
        {
          "name": "onforminput"
        },
        {
          "name": "oninput",
          "description": {
            "kind": "markdown",
            "value": "The value of an element changes or the content of an element with the attribute contenteditable is modified."
          }
        },
        {
          "name": "oninvalid",
          "description": {
            "kind": "markdown",
            "value": "A submittable element has been checked and doesn't satisfy its constraints."
          }
        },
        {
          "name": "onkeydown",
          "description": {
            "kind": "markdown",
            "value": "A key is pressed down."
          }
        },
        {
          "name": "onkeypress",
          "description": {
            "kind": "markdown",
            "value": "A key is pressed down and that key normally produces a character value (use input instead)."
          }
        },
        {
          "name": "onkeyup",
          "description": {
            "kind": "markdown",
            "value": "A key is released."
          }
        },
        {
          "name": "onload",
          "description": {
            "kind": "markdown",
            "value": "A resource and its dependent resources have finished loading."
          }
        },
        {
          "name": "onloadeddata",
          "description": {
            "kind": "markdown",
            "value": "The first frame of the media has finished loading."
          }
        },
        {
          "name": "onloadedmetadata",
          "description": {
            "kind": "markdown",
            "value": "The metadata has been loaded."
          }
        },
        {
          "name": "onloadstart",
          "description": {
            "kind": "markdown",
            "value": "Progress has begun."
          }
        },
        {
          "name": "onmousedown",
          "description": {
            "kind": "markdown",
            "value": "A pointing device button (usually a mouse) is pressed on an element."
          }
        },
        {
          "name": "onmousemove",
          "description": {
            "kind": "markdown",
            "value": "A pointing device is moved over an element."
          }
        },
        {
          "name": "onmouseout",
          "description": {
            "kind": "markdown",
            "value": "A pointing device is moved off the element that has the listener attached or off one of its children."
          }
        },
        {
          "name": "onmouseover",
          "description": {
            "kind": "markdown",
            "value": "A pointing device is moved onto the element that has the listener attached or onto one of its children."
          }
        },
        {
          "name": "onmouseup",
          "description": {
            "kind": "markdown",
            "value": "A pointing device button is released over an element."
          }
        },
        {
          "name": "onmousewheel"
        },
        {
          "name": "onmouseenter",
          "description": {
            "kind": "markdown",
            "value": "A pointing device is moved onto the element that has the listener attached."
          }
        },
        {
          "name": "onmouseleave",
          "description": {
            "kind": "markdown",
            "value": "A pointing device is moved off the element that has the listener attached."
          }
        },
        {
          "name": "onpause",
          "description": {
            "kind": "markdown",
            "value": "Playback has been paused."
          }
        },
        {
          "name": "onplay",
          "description": {
            "kind": "markdown",
            "value": "Playback has begun."
          }
        },
        {
          "name": "onplaying",
          "description": {
            "kind": "markdown",
            "value": "Playback is ready to start after having been paused or delayed due to lack of data."
          }
        },
        {
          "name": "onprogress",
          "description": {
            "kind": "markdown",
            "value": "In progress."
          }
        },
        {
          "name": "onratechange",
          "description": {
            "kind": "markdown",
            "value": "The playback rate has changed."
          }
        },
        {
          "name": "onreset",
          "description": {
            "kind": "markdown",
            "value": "A form is reset."
          }
        },
        {
          "name": "onresize",
          "description": {
            "kind": "markdown",
            "value": "The document view has been resized."
          }
        },
        {
          "name": "onreadystatechange",
          "description": {
            "kind": "markdown",
            "value": "The readyState attribute of a document has changed."
          }
        },
        {
          "name": "onscroll",
          "description": {
            "kind": "markdown",
            "value": "The document view or an element has been scrolled."
          }
        },
        {
          "name": "onseeked",
          "description": {
            "kind": "markdown",
            "value": "A seek operation completed."
          }
        },
        {
          "name": "onseeking",
          "description": {
            "kind": "markdown",
            "value": "A seek operation began."
          }
        },
        {
          "name": "onselect",
          "description": {
            "kind": "markdown",
            "value": "Some text is being selected."
          }
        },
        {
          "name": "onshow",
          "description": {
            "kind": "markdown",
            "value": "A contextmenu event was fired on/bubbled to an element that has a contextmenu attribute"
          }
        },
        {
          "name": "onstalled",
          "description": {
            "kind": "markdown",
            "value": "The user agent is trying to fetch media data, but data is unexpectedly not forthcoming."
          }
        },
        {
          "name": "onsubmit",
          "description": {
            "kind": "markdown",
            "value": "A form is submitted."
          }
        },
        {
          "name": "onsuspend",
          "description": {
            "kind": "markdown",
            "value": "Media data loading has been suspended."
          }
        },
        {
          "name": "ontimeupdate",
          "description": {
            "kind": "markdown",
            "value": "The time indicated by the currentTime attribute has been updated."
          }
        },
        {
          "name": "onvolumechange",
          "description": {
            "kind": "markdown",
            "value": "The volume has changed."
          }
        },
        {
          "name": "onwaiting",
          "description": {
            "kind": "markdown",
            "value": "Playback has stopped because of a temporary lack of data."
          }
        },
        {
          "name": "onpointercancel",
          "description": {
            "kind": "markdown",
            "value": "The pointer is unlikely to produce any more events."
          }
        },
        {
          "name": "onpointerdown",
          "description": {
            "kind": "markdown",
            "value": "The pointer enters the active buttons state."
          }
        },
        {
          "name": "onpointerenter",
          "description": {
            "kind": "markdown",
            "value": "Pointing device is moved inside the hit-testing boundary."
          }
        },
        {
          "name": "onpointerleave",
          "description": {
            "kind": "markdown",
            "value": "Pointing device is moved out of the hit-testing boundary."
          }
        },
        {
          "name": "onpointerlockchange",
          "description": {
            "kind": "markdown",
            "value": "The pointer was locked or released."
          }
        },
        {
          "name": "onpointerlockerror",
          "description": {
            "kind": "markdown",
            "value": "It was impossible to lock the pointer for technical reasons or because the permission was denied."
          }
        },
        {
          "name": "onpointermove",
          "description": {
            "kind": "markdown",
            "value": "The pointer changed coordinates."
          }
        },
        {
          "name": "onpointerout",
          "description": {
            "kind": "markdown",
            "value": "The pointing device moved out of hit-testing boundary or leaves detectable hover range."
          }
        },
        {
          "name": "onpointerover",
          "description": {
            "kind": "markdown",
            "value": "The pointing device is moved into the hit-testing boundary."
          }
        },
        {
          "name": "onpointerup",
          "description": {
            "kind": "markdown",
            "value": "The pointer leaves the active buttons state."
          }
        },
        {
          "name": "aria-activedescendant",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-activedescendant"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Identifies the currently active element when DOM focus is on a [`composite`](https://www.w3.org/TR/wai-aria-1.1/#composite) widget, [`textbox`](https://www.w3.org/TR/wai-aria-1.1/#textbox), [`group`](https://www.w3.org/TR/wai-aria-1.1/#group), or [`application`](https://www.w3.org/TR/wai-aria-1.1/#application)."
          }
        },
        {
          "name": "aria-atomic",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-atomic"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates whether [assistive technologies](https://www.w3.org/TR/wai-aria-1.1/#dfn-assistive-technology) will present all, or only parts of, the changed region based on the change notifications defined by the [`aria-relevant`](https://www.w3.org/TR/wai-aria-1.1/#aria-relevant) attribute."
          }
        },
        {
          "name": "aria-autocomplete",
          "valueSet": "autocomplete",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-autocomplete"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates whether inputting text could trigger display of one or more predictions of the user's intended value for an input and specifies how predictions would be presented if they are made."
          }
        },
        {
          "name": "aria-busy",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-busy"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates an element is being modified and that assistive technologies _MAY_ want to wait until the modifications are complete before exposing them to the user."
          }
        },
        {
          "name": "aria-checked",
          "valueSet": "tristate",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-checked"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": 'Indicates the current "checked" [state](https://www.w3.org/TR/wai-aria-1.1/#dfn-state) of checkboxes, radio buttons, and other [widgets](https://www.w3.org/TR/wai-aria-1.1/#dfn-widget). See related [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.1/#aria-pressed) and [`aria-selected`](https://www.w3.org/TR/wai-aria-1.1/#aria-selected).'
          }
        },
        {
          "name": "aria-colcount",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-colcount"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the total number of columns in a [`table`](https://www.w3.org/TR/wai-aria-1.1/#table), [`grid`](https://www.w3.org/TR/wai-aria-1.1/#grid), or [`treegrid`](https://www.w3.org/TR/wai-aria-1.1/#treegrid). See related [`aria-colindex`](https://www.w3.org/TR/wai-aria-1.1/#aria-colindex)."
          }
        },
        {
          "name": "aria-colindex",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-colindex"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines an [element's](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) column index or position with respect to the total number of columns within a [`table`](https://www.w3.org/TR/wai-aria-1.1/#table), [`grid`](https://www.w3.org/TR/wai-aria-1.1/#grid), or [`treegrid`](https://www.w3.org/TR/wai-aria-1.1/#treegrid). See related [`aria-colcount`](https://www.w3.org/TR/wai-aria-1.1/#aria-colcount) and [`aria-colspan`](https://www.w3.org/TR/wai-aria-1.1/#aria-colspan)."
          }
        },
        {
          "name": "aria-colspan",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-colspan"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the number of columns spanned by a cell or gridcell within a [`table`](https://www.w3.org/TR/wai-aria-1.1/#table), [`grid`](https://www.w3.org/TR/wai-aria-1.1/#grid), or [`treegrid`](https://www.w3.org/TR/wai-aria-1.1/#treegrid). See related [`aria-colindex`](https://www.w3.org/TR/wai-aria-1.1/#aria-colindex) and [`aria-rowspan`](https://www.w3.org/TR/wai-aria-1.1/#aria-rowspan)."
          }
        },
        {
          "name": "aria-controls",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-controls"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Identifies the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) (or elements) whose contents or presence are controlled by the current element. See related [`aria-owns`](https://www.w3.org/TR/wai-aria-1.1/#aria-owns)."
          }
        },
        {
          "name": "aria-current",
          "valueSet": "current",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-current"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) that represents the current item within a container or set of related elements."
          }
        },
        {
          "name": "aria-describedat",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-describedat"
            }
          ]
        },
        {
          "name": "aria-describedby",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-describedby"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Identifies the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) (or elements) that describes the [object](https://www.w3.org/TR/wai-aria-1.1/#dfn-object). See related [`aria-labelledby`](https://www.w3.org/TR/wai-aria-1.1/#aria-labelledby)."
          }
        },
        {
          "name": "aria-disabled",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-disabled"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates that the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) is [perceivable](https://www.w3.org/TR/wai-aria-1.1/#dfn-perceivable) but disabled, so it is not editable or otherwise [operable](https://www.w3.org/TR/wai-aria-1.1/#dfn-operable). See related [`aria-hidden`](https://www.w3.org/TR/wai-aria-1.1/#aria-hidden) and [`aria-readonly`](https://www.w3.org/TR/wai-aria-1.1/#aria-readonly)."
          }
        },
        {
          "name": "aria-dropeffect",
          "valueSet": "dropeffect",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-dropeffect"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "\\[Deprecated in ARIA 1.1\\] Indicates what functions can be performed when a dragged object is released on the drop target."
          }
        },
        {
          "name": "aria-errormessage",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-errormessage"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Identifies the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) that provides an error message for the [object](https://www.w3.org/TR/wai-aria-1.1/#dfn-object). See related [`aria-invalid`](https://www.w3.org/TR/wai-aria-1.1/#aria-invalid) and [`aria-describedby`](https://www.w3.org/TR/wai-aria-1.1/#aria-describedby)."
          }
        },
        {
          "name": "aria-expanded",
          "valueSet": "u",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-expanded"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates whether the element, or another grouping element it controls, is currently expanded or collapsed."
          }
        },
        {
          "name": "aria-flowto",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-flowto"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Identifies the next [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) (or elements) in an alternate reading order of content which, at the user's discretion, allows assistive technology to override the general default of reading in document source order."
          }
        },
        {
          "name": "aria-grabbed",
          "valueSet": "u",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-grabbed"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": `\\[Deprecated in ARIA 1.1\\] Indicates an element's "grabbed" [state](https://www.w3.org/TR/wai-aria-1.1/#dfn-state) in a drag-and-drop operation.`
          }
        },
        {
          "name": "aria-haspopup",
          "valueSet": "haspopup",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element)."
          }
        },
        {
          "name": "aria-hidden",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-hidden"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates whether the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) is exposed to an accessibility API. See related [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.1/#aria-disabled)."
          }
        },
        {
          "name": "aria-invalid",
          "valueSet": "invalid",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-invalid"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates the entered value does not conform to the format expected by the application. See related [`aria-errormessage`](https://www.w3.org/TR/wai-aria-1.1/#aria-errormessage)."
          }
        },
        {
          "name": "aria-kbdshortcuts",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-kbdshortcuts"
            }
          ]
        },
        {
          "name": "aria-label",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-label"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines a string value that labels the current element. See related [`aria-labelledby`](https://www.w3.org/TR/wai-aria-1.1/#aria-labelledby)."
          }
        },
        {
          "name": "aria-labelledby",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-labelledby"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Identifies the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) (or elements) that labels the current element. See related [`aria-describedby`](https://www.w3.org/TR/wai-aria-1.1/#aria-describedby)."
          }
        },
        {
          "name": "aria-level",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-level"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the hierarchical level of an [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) within a structure."
          }
        },
        {
          "name": "aria-live",
          "valueSet": "live",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-live"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates that an [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) will be updated, and describes the types of updates the [user agents](https://www.w3.org/TR/wai-aria-1.1/#dfn-user-agent), [assistive technologies](https://www.w3.org/TR/wai-aria-1.1/#dfn-assistive-technology), and user can expect from the [live region](https://www.w3.org/TR/wai-aria-1.1/#dfn-live-region)."
          }
        },
        {
          "name": "aria-modal",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-modal"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates whether an [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) is modal when displayed."
          }
        },
        {
          "name": "aria-multiline",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-multiline"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates whether a text box accepts multiple lines of input or only a single line."
          }
        },
        {
          "name": "aria-multiselectable",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-multiselectable"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates that the user may select more than one item from the current selectable descendants."
          }
        },
        {
          "name": "aria-orientation",
          "valueSet": "orientation",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-orientation"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates whether the element's orientation is horizontal, vertical, or unknown/ambiguous."
          }
        },
        {
          "name": "aria-owns",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-owns"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Identifies an [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) (or elements) in order to define a visual, functional, or contextual parent/child [relationship](https://www.w3.org/TR/wai-aria-1.1/#dfn-relationship) between DOM elements where the DOM hierarchy cannot be used to represent the relationship. See related [`aria-controls`](https://www.w3.org/TR/wai-aria-1.1/#aria-controls)."
          }
        },
        {
          "name": "aria-placeholder",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-placeholder"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value. A hint could be a sample value or a brief description of the expected format."
          }
        },
        {
          "name": "aria-posinset",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-posinset"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines an [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element)'s number or position in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM. See related [`aria-setsize`](https://www.w3.org/TR/wai-aria-1.1/#aria-setsize)."
          }
        },
        {
          "name": "aria-pressed",
          "valueSet": "tristate",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-pressed"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": 'Indicates the current "pressed" [state](https://www.w3.org/TR/wai-aria-1.1/#dfn-state) of toggle buttons. See related [`aria-checked`](https://www.w3.org/TR/wai-aria-1.1/#aria-checked) and [`aria-selected`](https://www.w3.org/TR/wai-aria-1.1/#aria-selected).'
          }
        },
        {
          "name": "aria-readonly",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-readonly"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates that the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) is not editable, but is otherwise [operable](https://www.w3.org/TR/wai-aria-1.1/#dfn-operable). See related [`aria-disabled`](https://www.w3.org/TR/wai-aria-1.1/#aria-disabled)."
          }
        },
        {
          "name": "aria-relevant",
          "valueSet": "relevant",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-relevant"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates what notifications the user agent will trigger when the accessibility tree within a live region is modified. See related [`aria-atomic`](https://www.w3.org/TR/wai-aria-1.1/#aria-atomic)."
          }
        },
        {
          "name": "aria-required",
          "valueSet": "b",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-required"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates that user input is required on the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) before a form may be submitted."
          }
        },
        {
          "name": "aria-roledescription",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-roledescription"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines a human-readable, author-localized description for the [role](https://www.w3.org/TR/wai-aria-1.1/#dfn-role) of an [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element)."
          }
        },
        {
          "name": "aria-rowcount",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-rowcount"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the total number of rows in a [`table`](https://www.w3.org/TR/wai-aria-1.1/#table), [`grid`](https://www.w3.org/TR/wai-aria-1.1/#grid), or [`treegrid`](https://www.w3.org/TR/wai-aria-1.1/#treegrid). See related [`aria-rowindex`](https://www.w3.org/TR/wai-aria-1.1/#aria-rowindex)."
          }
        },
        {
          "name": "aria-rowindex",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-rowindex"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines an [element's](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) row index or position with respect to the total number of rows within a [`table`](https://www.w3.org/TR/wai-aria-1.1/#table), [`grid`](https://www.w3.org/TR/wai-aria-1.1/#grid), or [`treegrid`](https://www.w3.org/TR/wai-aria-1.1/#treegrid). See related [`aria-rowcount`](https://www.w3.org/TR/wai-aria-1.1/#aria-rowcount) and [`aria-rowspan`](https://www.w3.org/TR/wai-aria-1.1/#aria-rowspan)."
          }
        },
        {
          "name": "aria-rowspan",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-rowspan"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the number of rows spanned by a cell or gridcell within a [`table`](https://www.w3.org/TR/wai-aria-1.1/#table), [`grid`](https://www.w3.org/TR/wai-aria-1.1/#grid), or [`treegrid`](https://www.w3.org/TR/wai-aria-1.1/#treegrid). See related [`aria-rowindex`](https://www.w3.org/TR/wai-aria-1.1/#aria-rowindex) and [`aria-colspan`](https://www.w3.org/TR/wai-aria-1.1/#aria-colspan)."
          }
        },
        {
          "name": "aria-selected",
          "valueSet": "u",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-selected"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": 'Indicates the current "selected" [state](https://www.w3.org/TR/wai-aria-1.1/#dfn-state) of various [widgets](https://www.w3.org/TR/wai-aria-1.1/#dfn-widget). See related [`aria-checked`](https://www.w3.org/TR/wai-aria-1.1/#aria-checked) and [`aria-pressed`](https://www.w3.org/TR/wai-aria-1.1/#aria-pressed).'
          }
        },
        {
          "name": "aria-setsize",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-setsize"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the number of items in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM. See related [`aria-posinset`](https://www.w3.org/TR/wai-aria-1.1/#aria-posinset)."
          }
        },
        {
          "name": "aria-sort",
          "valueSet": "sort",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-sort"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Indicates if items in a table or grid are sorted in ascending or descending order."
          }
        },
        {
          "name": "aria-valuemax",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-valuemax"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the maximum allowed value for a range [widget](https://www.w3.org/TR/wai-aria-1.1/#dfn-widget)."
          }
        },
        {
          "name": "aria-valuemin",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-valuemin"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the minimum allowed value for a range [widget](https://www.w3.org/TR/wai-aria-1.1/#dfn-widget)."
          }
        },
        {
          "name": "aria-valuenow",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-valuenow"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the current value for a range [widget](https://www.w3.org/TR/wai-aria-1.1/#dfn-widget). See related [`aria-valuetext`](https://www.w3.org/TR/wai-aria-1.1/#aria-valuetext)."
          }
        },
        {
          "name": "aria-valuetext",
          "references": [
            {
              "name": "WAI-ARIA Reference",
              "url": "https://www.w3.org/TR/wai-aria-1.1/#aria-valuetext"
            }
          ],
          "description": {
            "kind": "markdown",
            "value": "Defines the human readable text alternative of [`aria-valuenow`](https://www.w3.org/TR/wai-aria-1.1/#aria-valuenow) for a range [widget](https://www.w3.org/TR/wai-aria-1.1/#dfn-widget)."
          }
        },
        {
          "name": "aria-details",
          "description": {
            "kind": "markdown",
            "value": "Identifies the [element](https://www.w3.org/TR/wai-aria-1.1/#dfn-element) that provides a detailed, extended description for the [object](https://www.w3.org/TR/wai-aria-1.1/#dfn-object). See related [`aria-describedby`](https://www.w3.org/TR/wai-aria-1.1/#aria-describedby)."
          }
        },
        {
          "name": "aria-keyshortcuts",
          "description": {
            "kind": "markdown",
            "value": "Indicates keyboard shortcuts that an author has implemented to activate or give focus to an element."
          }
        }
      ],
      "valueSets": [
        {
          "name": "b",
          "values": [
            {
              "name": "true"
            },
            {
              "name": "false"
            }
          ]
        },
        {
          "name": "u",
          "values": [
            {
              "name": "true"
            },
            {
              "name": "false"
            },
            {
              "name": "undefined"
            }
          ]
        },
        {
          "name": "o",
          "values": [
            {
              "name": "on"
            },
            {
              "name": "off"
            }
          ]
        },
        {
          "name": "y",
          "values": [
            {
              "name": "yes"
            },
            {
              "name": "no"
            }
          ]
        },
        {
          "name": "w",
          "values": [
            {
              "name": "soft"
            },
            {
              "name": "hard"
            }
          ]
        },
        {
          "name": "d",
          "values": [
            {
              "name": "ltr"
            },
            {
              "name": "rtl"
            },
            {
              "name": "auto"
            }
          ]
        },
        {
          "name": "m",
          "values": [
            {
              "name": "get",
              "description": {
                "kind": "markdown",
                "value": "Corresponds to the HTTP [GET method](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3); form data are appended to the `action` attribute URI with a '?' as separator, and the resulting URI is sent to the server. Use this method when the form has no side-effects and contains only ASCII characters."
              }
            },
            {
              "name": "post",
              "description": {
                "kind": "markdown",
                "value": "Corresponds to the HTTP [POST method](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5); form data are included in the body of the form and sent to the server."
              }
            },
            {
              "name": "dialog",
              "description": {
                "kind": "markdown",
                "value": "Use when the form is inside a [`<dialog>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog) element to close the dialog when submitted."
              }
            }
          ]
        },
        {
          "name": "fm",
          "values": [
            {
              "name": "get"
            },
            {
              "name": "post"
            }
          ]
        },
        {
          "name": "s",
          "values": [
            {
              "name": "row"
            },
            {
              "name": "col"
            },
            {
              "name": "rowgroup"
            },
            {
              "name": "colgroup"
            }
          ]
        },
        {
          "name": "t",
          "values": [
            {
              "name": "hidden"
            },
            {
              "name": "text"
            },
            {
              "name": "search"
            },
            {
              "name": "tel"
            },
            {
              "name": "url"
            },
            {
              "name": "email"
            },
            {
              "name": "password"
            },
            {
              "name": "datetime"
            },
            {
              "name": "date"
            },
            {
              "name": "month"
            },
            {
              "name": "week"
            },
            {
              "name": "time"
            },
            {
              "name": "datetime-local"
            },
            {
              "name": "number"
            },
            {
              "name": "range"
            },
            {
              "name": "color"
            },
            {
              "name": "checkbox"
            },
            {
              "name": "radio"
            },
            {
              "name": "file"
            },
            {
              "name": "submit"
            },
            {
              "name": "image"
            },
            {
              "name": "reset"
            },
            {
              "name": "button"
            }
          ]
        },
        {
          "name": "im",
          "values": [
            {
              "name": "verbatim"
            },
            {
              "name": "latin"
            },
            {
              "name": "latin-name"
            },
            {
              "name": "latin-prose"
            },
            {
              "name": "full-width-latin"
            },
            {
              "name": "kana"
            },
            {
              "name": "kana-name"
            },
            {
              "name": "katakana"
            },
            {
              "name": "numeric"
            },
            {
              "name": "tel"
            },
            {
              "name": "email"
            },
            {
              "name": "url"
            }
          ]
        },
        {
          "name": "bt",
          "values": [
            {
              "name": "button"
            },
            {
              "name": "submit"
            },
            {
              "name": "reset"
            },
            {
              "name": "menu"
            }
          ]
        },
        {
          "name": "lt",
          "values": [
            {
              "name": "1"
            },
            {
              "name": "a"
            },
            {
              "name": "A"
            },
            {
              "name": "i"
            },
            {
              "name": "I"
            }
          ]
        },
        {
          "name": "mt",
          "values": [
            {
              "name": "context"
            },
            {
              "name": "toolbar"
            }
          ]
        },
        {
          "name": "mit",
          "values": [
            {
              "name": "command"
            },
            {
              "name": "checkbox"
            },
            {
              "name": "radio"
            }
          ]
        },
        {
          "name": "et",
          "values": [
            {
              "name": "application/x-www-form-urlencoded"
            },
            {
              "name": "multipart/form-data"
            },
            {
              "name": "text/plain"
            }
          ]
        },
        {
          "name": "tk",
          "values": [
            {
              "name": "subtitles"
            },
            {
              "name": "captions"
            },
            {
              "name": "descriptions"
            },
            {
              "name": "chapters"
            },
            {
              "name": "metadata"
            }
          ]
        },
        {
          "name": "pl",
          "values": [
            {
              "name": "none"
            },
            {
              "name": "metadata"
            },
            {
              "name": "auto"
            }
          ]
        },
        {
          "name": "sh",
          "values": [
            {
              "name": "circle"
            },
            {
              "name": "default"
            },
            {
              "name": "poly"
            },
            {
              "name": "rect"
            }
          ]
        },
        {
          "name": "xo",
          "values": [
            {
              "name": "anonymous"
            },
            {
              "name": "use-credentials"
            }
          ]
        },
        {
          "name": "sb",
          "values": [
            {
              "name": "allow-forms"
            },
            {
              "name": "allow-modals"
            },
            {
              "name": "allow-pointer-lock"
            },
            {
              "name": "allow-popups"
            },
            {
              "name": "allow-popups-to-escape-sandbox"
            },
            {
              "name": "allow-same-origin"
            },
            {
              "name": "allow-scripts"
            },
            {
              "name": "allow-top-navigation"
            }
          ]
        },
        {
          "name": "tristate",
          "values": [
            {
              "name": "true"
            },
            {
              "name": "false"
            },
            {
              "name": "mixed"
            },
            {
              "name": "undefined"
            }
          ]
        },
        {
          "name": "inputautocomplete",
          "values": [
            {
              "name": "additional-name"
            },
            {
              "name": "address-level1"
            },
            {
              "name": "address-level2"
            },
            {
              "name": "address-level3"
            },
            {
              "name": "address-level4"
            },
            {
              "name": "address-line1"
            },
            {
              "name": "address-line2"
            },
            {
              "name": "address-line3"
            },
            {
              "name": "bday"
            },
            {
              "name": "bday-year"
            },
            {
              "name": "bday-day"
            },
            {
              "name": "bday-month"
            },
            {
              "name": "billing"
            },
            {
              "name": "cc-additional-name"
            },
            {
              "name": "cc-csc"
            },
            {
              "name": "cc-exp"
            },
            {
              "name": "cc-exp-month"
            },
            {
              "name": "cc-exp-year"
            },
            {
              "name": "cc-family-name"
            },
            {
              "name": "cc-given-name"
            },
            {
              "name": "cc-name"
            },
            {
              "name": "cc-number"
            },
            {
              "name": "cc-type"
            },
            {
              "name": "country"
            },
            {
              "name": "country-name"
            },
            {
              "name": "current-password"
            },
            {
              "name": "email"
            },
            {
              "name": "family-name"
            },
            {
              "name": "fax"
            },
            {
              "name": "given-name"
            },
            {
              "name": "home"
            },
            {
              "name": "honorific-prefix"
            },
            {
              "name": "honorific-suffix"
            },
            {
              "name": "impp"
            },
            {
              "name": "language"
            },
            {
              "name": "mobile"
            },
            {
              "name": "name"
            },
            {
              "name": "new-password"
            },
            {
              "name": "nickname"
            },
            {
              "name": "organization"
            },
            {
              "name": "organization-title"
            },
            {
              "name": "pager"
            },
            {
              "name": "photo"
            },
            {
              "name": "postal-code"
            },
            {
              "name": "sex"
            },
            {
              "name": "shipping"
            },
            {
              "name": "street-address"
            },
            {
              "name": "tel-area-code"
            },
            {
              "name": "tel"
            },
            {
              "name": "tel-country-code"
            },
            {
              "name": "tel-extension"
            },
            {
              "name": "tel-local"
            },
            {
              "name": "tel-local-prefix"
            },
            {
              "name": "tel-local-suffix"
            },
            {
              "name": "tel-national"
            },
            {
              "name": "transaction-amount"
            },
            {
              "name": "transaction-currency"
            },
            {
              "name": "url"
            },
            {
              "name": "username"
            },
            {
              "name": "work"
            }
          ]
        },
        {
          "name": "autocomplete",
          "values": [
            {
              "name": "inline"
            },
            {
              "name": "list"
            },
            {
              "name": "both"
            },
            {
              "name": "none"
            }
          ]
        },
        {
          "name": "current",
          "values": [
            {
              "name": "page"
            },
            {
              "name": "step"
            },
            {
              "name": "location"
            },
            {
              "name": "date"
            },
            {
              "name": "time"
            },
            {
              "name": "true"
            },
            {
              "name": "false"
            }
          ]
        },
        {
          "name": "dropeffect",
          "values": [
            {
              "name": "copy"
            },
            {
              "name": "move"
            },
            {
              "name": "link"
            },
            {
              "name": "execute"
            },
            {
              "name": "popup"
            },
            {
              "name": "none"
            }
          ]
        },
        {
          "name": "invalid",
          "values": [
            {
              "name": "grammar"
            },
            {
              "name": "false"
            },
            {
              "name": "spelling"
            },
            {
              "name": "true"
            }
          ]
        },
        {
          "name": "live",
          "values": [
            {
              "name": "off"
            },
            {
              "name": "polite"
            },
            {
              "name": "assertive"
            }
          ]
        },
        {
          "name": "orientation",
          "values": [
            {
              "name": "vertical"
            },
            {
              "name": "horizontal"
            },
            {
              "name": "undefined"
            }
          ]
        },
        {
          "name": "relevant",
          "values": [
            {
              "name": "additions"
            },
            {
              "name": "removals"
            },
            {
              "name": "text"
            },
            {
              "name": "all"
            },
            {
              "name": "additions text"
            }
          ]
        },
        {
          "name": "sort",
          "values": [
            {
              "name": "ascending"
            },
            {
              "name": "descending"
            },
            {
              "name": "none"
            },
            {
              "name": "other"
            }
          ]
        },
        {
          "name": "roles",
          "values": [
            {
              "name": "alert"
            },
            {
              "name": "alertdialog"
            },
            {
              "name": "button"
            },
            {
              "name": "checkbox"
            },
            {
              "name": "dialog"
            },
            {
              "name": "gridcell"
            },
            {
              "name": "link"
            },
            {
              "name": "log"
            },
            {
              "name": "marquee"
            },
            {
              "name": "menuitem"
            },
            {
              "name": "menuitemcheckbox"
            },
            {
              "name": "menuitemradio"
            },
            {
              "name": "option"
            },
            {
              "name": "progressbar"
            },
            {
              "name": "radio"
            },
            {
              "name": "scrollbar"
            },
            {
              "name": "searchbox"
            },
            {
              "name": "slider"
            },
            {
              "name": "spinbutton"
            },
            {
              "name": "status"
            },
            {
              "name": "switch"
            },
            {
              "name": "tab"
            },
            {
              "name": "tabpanel"
            },
            {
              "name": "textbox"
            },
            {
              "name": "timer"
            },
            {
              "name": "tooltip"
            },
            {
              "name": "treeitem"
            },
            {
              "name": "combobox"
            },
            {
              "name": "grid"
            },
            {
              "name": "listbox"
            },
            {
              "name": "menu"
            },
            {
              "name": "menubar"
            },
            {
              "name": "radiogroup"
            },
            {
              "name": "tablist"
            },
            {
              "name": "tree"
            },
            {
              "name": "treegrid"
            },
            {
              "name": "application"
            },
            {
              "name": "article"
            },
            {
              "name": "cell"
            },
            {
              "name": "columnheader"
            },
            {
              "name": "definition"
            },
            {
              "name": "directory"
            },
            {
              "name": "document"
            },
            {
              "name": "feed"
            },
            {
              "name": "figure"
            },
            {
              "name": "group"
            },
            {
              "name": "heading"
            },
            {
              "name": "img"
            },
            {
              "name": "list"
            },
            {
              "name": "listitem"
            },
            {
              "name": "math"
            },
            {
              "name": "none"
            },
            {
              "name": "note"
            },
            {
              "name": "presentation"
            },
            {
              "name": "region"
            },
            {
              "name": "row"
            },
            {
              "name": "rowgroup"
            },
            {
              "name": "rowheader"
            },
            {
              "name": "separator"
            },
            {
              "name": "table"
            },
            {
              "name": "term"
            },
            {
              "name": "text"
            },
            {
              "name": "toolbar"
            },
            {
              "name": "banner"
            },
            {
              "name": "complementary"
            },
            {
              "name": "contentinfo"
            },
            {
              "name": "form"
            },
            {
              "name": "main"
            },
            {
              "name": "navigation"
            },
            {
              "name": "region"
            },
            {
              "name": "search"
            },
            {
              "name": "doc-abstract"
            },
            {
              "name": "doc-acknowledgments"
            },
            {
              "name": "doc-afterword"
            },
            {
              "name": "doc-appendix"
            },
            {
              "name": "doc-backlink"
            },
            {
              "name": "doc-biblioentry"
            },
            {
              "name": "doc-bibliography"
            },
            {
              "name": "doc-biblioref"
            },
            {
              "name": "doc-chapter"
            },
            {
              "name": "doc-colophon"
            },
            {
              "name": "doc-conclusion"
            },
            {
              "name": "doc-cover"
            },
            {
              "name": "doc-credit"
            },
            {
              "name": "doc-credits"
            },
            {
              "name": "doc-dedication"
            },
            {
              "name": "doc-endnote"
            },
            {
              "name": "doc-endnotes"
            },
            {
              "name": "doc-epigraph"
            },
            {
              "name": "doc-epilogue"
            },
            {
              "name": "doc-errata"
            },
            {
              "name": "doc-example"
            },
            {
              "name": "doc-footnote"
            },
            {
              "name": "doc-foreword"
            },
            {
              "name": "doc-glossary"
            },
            {
              "name": "doc-glossref"
            },
            {
              "name": "doc-index"
            },
            {
              "name": "doc-introduction"
            },
            {
              "name": "doc-noteref"
            },
            {
              "name": "doc-notice"
            },
            {
              "name": "doc-pagebreak"
            },
            {
              "name": "doc-pagelist"
            },
            {
              "name": "doc-part"
            },
            {
              "name": "doc-preface"
            },
            {
              "name": "doc-prologue"
            },
            {
              "name": "doc-pullquote"
            },
            {
              "name": "doc-qna"
            },
            {
              "name": "doc-subtitle"
            },
            {
              "name": "doc-tip"
            },
            {
              "name": "doc-toc"
            }
          ]
        },
        {
          "name": "metanames",
          "values": [
            {
              "name": "application-name"
            },
            {
              "name": "author"
            },
            {
              "name": "description"
            },
            {
              "name": "format-detection"
            },
            {
              "name": "generator"
            },
            {
              "name": "keywords"
            },
            {
              "name": "publisher"
            },
            {
              "name": "referrer"
            },
            {
              "name": "robots"
            },
            {
              "name": "theme-color"
            },
            {
              "name": "viewport"
            }
          ]
        },
        {
          "name": "haspopup",
          "values": [
            {
              "name": "false",
              "description": {
                "kind": "markdown",
                "value": "(default) Indicates the element does not have a popup."
              }
            },
            {
              "name": "true",
              "description": {
                "kind": "markdown",
                "value": "Indicates the popup is a menu."
              }
            },
            {
              "name": "menu",
              "description": {
                "kind": "markdown",
                "value": "Indicates the popup is a menu."
              }
            },
            {
              "name": "listbox",
              "description": {
                "kind": "markdown",
                "value": "Indicates the popup is a listbox."
              }
            },
            {
              "name": "tree",
              "description": {
                "kind": "markdown",
                "value": "Indicates the popup is a tree."
              }
            },
            {
              "name": "grid",
              "description": {
                "kind": "markdown",
                "value": "Indicates the popup is a grid."
              }
            },
            {
              "name": "dialog",
              "description": {
                "kind": "markdown",
                "value": "Indicates the popup is a dialog."
              }
            }
          ]
        }
      ]
    };
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/languageFacts/dataManager.js
var HTMLDataManager;
var init_dataManager = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/languageFacts/dataManager.js"() {
    init_dataProvider();
    init_webCustomData();
    HTMLDataManager = function() {
      function HTMLDataManager2(options) {
        this.dataProviders = [];
        this.setDataProviders(options.useDefaultDataProvider !== false, options.customDataProviders || []);
      }
      HTMLDataManager2.prototype.setDataProviders = function(builtIn, providers) {
        var _a2;
        this.dataProviders = [];
        if (builtIn) {
          this.dataProviders.push(new HTMLDataProvider("html5", htmlData));
        }
        (_a2 = this.dataProviders).push.apply(_a2, providers);
      };
      HTMLDataManager2.prototype.getDataProviders = function() {
        return this.dataProviders;
      };
      return HTMLDataManager2;
    }();
  }
});

// ../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/htmlLanguageService.js
var htmlLanguageService_exports = {};
__export(htmlLanguageService_exports, {
  ClientCapabilities: () => ClientCapabilities,
  Color: () => Color2,
  ColorInformation: () => ColorInformation2,
  ColorPresentation: () => ColorPresentation2,
  Command: () => Command2,
  CompletionItem: () => CompletionItem2,
  CompletionItemKind: () => CompletionItemKind2,
  CompletionItemTag: () => CompletionItemTag2,
  CompletionList: () => CompletionList2,
  Diagnostic: () => Diagnostic2,
  DocumentHighlight: () => DocumentHighlight2,
  DocumentHighlightKind: () => DocumentHighlightKind2,
  DocumentLink: () => DocumentLink2,
  FileType: () => FileType,
  FoldingRange: () => FoldingRange2,
  FoldingRangeKind: () => FoldingRangeKind2,
  FormattingOptions: () => FormattingOptions2,
  Hover: () => Hover2,
  InsertReplaceEdit: () => InsertReplaceEdit2,
  InsertTextFormat: () => InsertTextFormat2,
  InsertTextMode: () => InsertTextMode2,
  Location: () => Location2,
  MarkedString: () => MarkedString2,
  MarkupContent: () => MarkupContent2,
  MarkupKind: () => MarkupKind2,
  Position: () => Position2,
  Range: () => Range2,
  ScannerState: () => ScannerState,
  SelectionRange: () => SelectionRange2,
  SymbolInformation: () => SymbolInformation2,
  SymbolKind: () => SymbolKind2,
  TextDocument: () => TextDocument3,
  TextEdit: () => TextEdit2,
  TokenType: () => TokenType,
  WorkspaceEdit: () => WorkspaceEdit2,
  getDefaultHTMLDataProvider: () => getDefaultHTMLDataProvider,
  getLanguageService: () => getLanguageService,
  newHTMLDataProvider: () => newHTMLDataProvider
});
function getLanguageService(options) {
  if (options === void 0) {
    options = defaultLanguageServiceOptions;
  }
  var dataManager = new HTMLDataManager(options);
  var htmlHover = new HTMLHover(options, dataManager);
  var htmlCompletion = new HTMLCompletion(options, dataManager);
  return {
    setDataProviders: dataManager.setDataProviders.bind(dataManager),
    createScanner,
    parseHTMLDocument: function(document) {
      return parse(document.getText());
    },
    doComplete: htmlCompletion.doComplete.bind(htmlCompletion),
    doComplete2: htmlCompletion.doComplete2.bind(htmlCompletion),
    setCompletionParticipants: htmlCompletion.setCompletionParticipants.bind(htmlCompletion),
    doHover: htmlHover.doHover.bind(htmlHover),
    format,
    findDocumentHighlights,
    findDocumentLinks,
    findDocumentSymbols,
    getFoldingRanges,
    getSelectionRanges,
    doQuoteComplete: htmlCompletion.doQuoteComplete.bind(htmlCompletion),
    doTagComplete: htmlCompletion.doTagComplete.bind(htmlCompletion),
    doRename,
    findMatchingTagPosition,
    findOnTypeRenameRanges: findLinkedEditingRanges,
    findLinkedEditingRanges
  };
}
function newHTMLDataProvider(id, customData) {
  return new HTMLDataProvider(id, customData);
}
function getDefaultHTMLDataProvider() {
  return newHTMLDataProvider("default", htmlData);
}
var defaultLanguageServiceOptions;
var init_htmlLanguageService = __esm({
  "../../node_modules/.pnpm/vscode-html-languageservice@4.2.1/node_modules/vscode-html-languageservice/lib/esm/htmlLanguageService.js"() {
    init_htmlScanner();
    init_htmlParser();
    init_htmlCompletion();
    init_htmlHover();
    init_htmlFormatter();
    init_htmlLinks();
    init_htmlHighlighting();
    init_htmlSymbolsProvider();
    init_htmlRename();
    init_htmlMatchingTagPosition();
    init_htmlLinkedEditing();
    init_htmlFolding();
    init_htmlSelectionRange();
    init_dataProvider();
    init_dataManager();
    init_webCustomData();
    init_htmlLanguageTypes();
    defaultLanguageServiceOptions = {};
  }
});

// ../../packages/client/out/features/splitEditors.js
var require_splitEditors = __commonJS({
  "../../packages/client/out/features/splitEditors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.userPick = exports2.activate = exports2.htmlLs = void 0;
    var vscode2 = require("vscode");
    var reactivity_1 = require_reactivity();
    var shared = require_node4();
    var html = (init_htmlLanguageService(), __toCommonJS(htmlLanguageService_exports));
    var vscode_languageserver_textdocument_1 = (init_main3(), __toCommonJS(main_exports2));
    exports2.htmlLs = html.getLanguageService();
    function activate2(context) {
      const getDocDescriptor = useDocDescriptor();
      context.subscriptions.push(vscode2.commands.registerCommand("volar.action.splitEditors", onSplit));
      async function onSplit() {
        const editor = vscode2.window.activeTextEditor;
        if (!editor)
          return;
        const doc = editor.document;
        const descriptor = getDocDescriptor(doc.getText());
        const leftBlocks = [
          descriptor.scriptSetup,
          descriptor.script,
          ...descriptor.styles
        ].filter(shared.notEmpty);
        const rightBlocks = [
          descriptor.template,
          ...descriptor.customBlocks
        ].filter(shared.notEmpty);
        await foldingBlocks(leftBlocks);
        await vscode2.commands.executeCommand("workbench.action.toggleSplitEditorInGroup");
        await foldingBlocks(rightBlocks);
        async function foldingBlocks(blocks) {
          const firstBlock = blocks.sort((a, b) => a.startTagEnd - b.startTagEnd)[0];
          const editor2 = vscode2.window.activeTextEditor;
          if (!editor2)
            return;
          editor2.selections = blocks.map((block) => new vscode2.Selection(doc.positionAt(block.startTagEnd), doc.positionAt(block.startTagEnd)));
          await vscode2.commands.executeCommand("editor.unfoldAll");
          await vscode2.commands.executeCommand("editor.foldLevel1");
          editor2.revealRange(new vscode2.Range(doc.positionAt(firstBlock.startTagEnd), new vscode2.Position(editor2.document.lineCount, 0)), vscode2.TextEditorRevealType.AtTop);
        }
      }
    }
    exports2.activate = activate2;
    function useDocDescriptor() {
      const splitDocText = (0, reactivity_1.ref)("");
      const splitDocDescriptor = (0, reactivity_1.computed)(() => shared.parseSfc(splitDocText.value, exports2.htmlLs.parseHTMLDocument(vscode_languageserver_textdocument_1.TextDocument.create("", "", 0, splitDocText.value))));
      return getDescriptor;
      function getDescriptor(text) {
        splitDocText.value = text;
        return splitDocDescriptor.value;
      }
    }
    function userPick(options, placeholder) {
      return new Promise((resolve) => {
        const quickPick = vscode2.window.createQuickPick();
        quickPick.items = Object.values(options);
        quickPick.placeholder = placeholder;
        quickPick.onDidChangeSelection((selection) => {
          if (selection[0]) {
            for (let key in options) {
              const option = options[key];
              if (selection[0] === option) {
                resolve(key);
                quickPick.hide();
                break;
              }
            }
          }
        });
        quickPick.onDidHide(() => {
          quickPick.dispose();
          resolve(void 0);
        });
        quickPick.show();
      });
    }
    exports2.userPick = userPick;
  }
});

// ../../packages/client/out/features/attrNameCase.js
var require_attrNameCase = __commonJS({
  "../../packages/client/out/features/attrNameCase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var splitEditors_1 = require_splitEditors();
    var vscode_languageclient_1 = require_main3();
    var shared = require_node4();
    async function activate2(context, languageClient) {
      var _a2;
      await languageClient.onReady();
      await languageClient.sendRequest(shared.InitDoneRequest.type);
      const attrCases = shared.createPathMap();
      const statusBar = vscode2.window.createStatusBarItem(vscode2.StatusBarAlignment.Right);
      statusBar.command = "volar.action.attrNameCase";
      onChangeDocument((_a2 = vscode2.window.activeTextEditor) === null || _a2 === void 0 ? void 0 : _a2.document);
      const d_1 = vscode2.window.onDidChangeActiveTextEditor((e) => {
        onChangeDocument(e === null || e === void 0 ? void 0 : e.document);
      });
      const d_2 = vscode2.workspace.onDidCloseTextDocument((doc) => {
        attrCases.uriDelete(doc.uri.toString());
      });
      const d_3 = vscode2.commands.registerCommand("volar.action.attrNameCase", async () => {
        var _a3;
        const crtDoc = (_a3 = vscode2.window.activeTextEditor) === null || _a3 === void 0 ? void 0 : _a3.document;
        if (!crtDoc)
          return;
        const attrCase = attrCases.uriGet(crtDoc.uri.toString());
        const options = {};
        options[4] = { label: (attrCase === "kebabCase" ? "\u2022 " : "") + "Prop Using kebab-case" };
        options[5] = { label: (attrCase === "camelCase" ? "\u2022 " : "") + "Prop Using camelCase" };
        options[6] = { label: "Detect Prop name from Content" };
        const select = await (0, splitEditors_1.userPick)(options);
        if (select === void 0)
          return;
        if (select === "4") {
          attrCases.uriSet(crtDoc.uri.toString(), "kebabCase");
          updateStatusBarText("kebabCase");
        }
        if (select === "5") {
          attrCases.uriSet(crtDoc.uri.toString(), "camelCase");
          updateStatusBarText("camelCase");
        }
        if (select === "6") {
          const detects = await languageClient.sendRequest(shared.DetectDocumentNameCasesRequest.type, languageClient.code2ProtocolConverter.asTextDocumentIdentifier(crtDoc));
          if (detects) {
            attrCases.uriSet(crtDoc.uri.toString(), getValidAttrCase(detects.attr));
            updateStatusBarText(getValidAttrCase(detects.attr));
          }
        }
      });
      languageClient.onDidChangeState((e) => {
        if (e.newState === vscode_languageclient_1.State.Stopped) {
          d_1.dispose();
          d_2.dispose();
          d_3.dispose();
          statusBar.dispose();
        }
      });
      return (uri) => {
        var _a3;
        let attrCase = attrCases.uriGet(uri);
        if (uri.toLowerCase() === ((_a3 = vscode2.window.activeTextEditor) === null || _a3 === void 0 ? void 0 : _a3.document.uri.toString().toLowerCase())) {
          updateStatusBarText(attrCase);
        }
        return attrCase !== null && attrCase !== void 0 ? attrCase : "kebabCase";
      };
      async function onChangeDocument(newDoc) {
        if ((newDoc === null || newDoc === void 0 ? void 0 : newDoc.languageId) === "vue") {
          let attrCase = attrCases.uriGet(newDoc.uri.toString());
          if (!attrCase) {
            const attrMode = vscode2.workspace.getConfiguration("volar").get("completion.preferredAttrNameCase");
            if (attrMode === "kebab") {
              attrCase = "kebabCase";
            } else if (attrMode === "camel") {
              attrCase = "camelCase";
            } else {
              const templateCases = await languageClient.sendRequest(shared.DetectDocumentNameCasesRequest.type, languageClient.code2ProtocolConverter.asTextDocumentIdentifier(newDoc));
              if (templateCases) {
                attrCase = getValidAttrCase(templateCases.attr);
                if (templateCases.attr === "both") {
                  if (attrMode === "auto-kebab") {
                    attrCase = "kebabCase";
                  } else if (attrMode === "auto-camel") {
                    attrCase = "camelCase";
                  }
                }
              }
            }
          }
          if (attrCase) {
            attrCases.uriSet(newDoc.uri.toString(), attrCase !== null && attrCase !== void 0 ? attrCase : "unsure");
          }
          updateStatusBarText(attrCase);
          statusBar.show();
        } else {
          statusBar.hide();
        }
      }
      function getValidAttrCase(attrCase) {
        if (attrCase === "both" || attrCase === "unsure") {
          const attrMode = vscode2.workspace.getConfiguration("volar").get("completion.preferredAttrNameCase");
          if (attrMode === "auto-kebab") {
            return "kebabCase";
          } else if (attrMode === "auto-camel") {
            return "camelCase";
          }
          return "kebabCase";
        }
        return attrCase !== null && attrCase !== void 0 ? attrCase : "kebabCase";
      }
      function updateStatusBarText(attrCase) {
        let text = `Attr: `;
        if (attrCase === "kebabCase" || attrCase === void 0) {
          text += `kebab-case`;
        } else if (attrCase === "camelCase") {
          text += `camelCase`;
        }
        statusBar.text = text;
      }
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/callGraph.js
var require_callGraph = __commonJS({
  "../../packages/client/out/features/callGraph.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      context.subscriptions.push(vscode2.commands.registerCommand("volar.action.showCallGraph", async () => {
        var _a2;
        const document = (_a2 = vscode2.window.activeTextEditor) === null || _a2 === void 0 ? void 0 : _a2.document;
        if (!document)
          return;
        let param = languageClient.code2ProtocolConverter.asTextDocumentIdentifier(document);
        const d3 = await languageClient.sendRequest(shared.D3Request.type, param);
        const panel = vscode2.window.createWebviewPanel("vueCallGraph", "Vue Call Graph", vscode2.ViewColumn.One, {
          enableScripts: true
        });
        panel.webview.html = `
<script src="https://d3js.org/d3.v5.min.js"><\/script>
<script src="https://unpkg.com/viz.js@1.8.1/viz.js" type="javascript/worker"><\/script>
<script src="https://unpkg.com/d3-graphviz@2.1.0/build/d3-graphviz.min.js"><\/script>
<div id="graph" style="text-align: center;"></div>
<script>

    var dotIndex = 0;
    var graphviz = d3.select("#graph").graphviz()
        .zoom(false)
        .on("initEnd", render)

    function render() {
        var dot = \`${d3}\`;
        graphviz
            .renderDot(dot)
    }

<\/script>
`;
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/utils/fs.js
var require_fs = __commonJS({
  "../../packages/client/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exists = void 0;
    var vscode2 = require("vscode");
    async function exists(uri) {
      try {
        await vscode2.workspace.fs.stat(uri);
        return true;
      } catch {
        return false;
      }
    }
    exports2.exists = exists;
  }
});

// ../../packages/client/out/features/createWorkspaceSnippets.js
var require_createWorkspaceSnippets = __commonJS({
  "../../packages/client/out/features/createWorkspaceSnippets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var fs = require_fs();
    async function activate2(context) {
      context.subscriptions.push(vscode2.commands.registerCommand("volar.action.createWorkspaceSnippets", async () => {
        if (vscode2.workspace.workspaceFolders) {
          for (const rootPath of vscode2.workspace.workspaceFolders) {
            const volar = vscode2.extensions.getExtension("johnsoncodehk.volar");
            if (!volar)
              return;
            const templateUri = vscode2.Uri.joinPath(volar.extensionUri, "templates", "vue.code-snippets");
            const newTemplateUri = vscode2.Uri.joinPath(rootPath.uri, ".vscode", "vue.code-snippets");
            if (!await fs.exists(newTemplateUri)) {
              const template = await vscode2.workspace.fs.readFile(templateUri);
              vscode2.workspace.fs.writeFile(newTemplateUri, template);
            }
            const document = await vscode2.workspace.openTextDocument(newTemplateUri);
            await vscode2.window.showTextDocument(document);
          }
        }
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/documentVersion.js
var require_documentVersion = __commonJS({
  "../../packages/client/out/features/documentVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      context.subscriptions.push(languageClient.onRequest(shared.GetDocumentVersionRequest.type, (handler) => {
        const doc = vscode2.workspace.textDocuments.find((doc2) => doc2.uri.toString() === handler.uri);
        return doc === null || doc === void 0 ? void 0 : doc.version;
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/documentContent.js
var require_documentContent = __commonJS({
  "../../packages/client/out/features/documentContent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var vscode_languageclient_1 = require_main3();
    var shared = require_node4();
    var nls4 = require_main4();
    var localize4 = nls4.loadMessageBundle();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      const schemaDocuments = {};
      context.subscriptions.push(languageClient.onRequest(shared.GetDocumentContentRequest.type, (handle) => {
        const uri = vscode2.Uri.parse(handle.uri);
        if (uri.scheme === "untitled") {
          return Promise.reject(new vscode_languageclient_1.ResponseError(3, localize4("untitled.schema", "Unable to load {0}", uri.toString())));
        }
        if (uri.scheme !== "http" && uri.scheme !== "https") {
          return vscode2.workspace.openTextDocument(uri).then((doc) => {
            schemaDocuments[uri.toString()] = true;
            return doc.getText();
          }, (error) => {
            return Promise.reject(new vscode_languageclient_1.ResponseError(2, error.toString()));
          });
        } else {
          return Promise.reject(new vscode_languageclient_1.ResponseError(0, "Downloading schemas is not support yet"));
        }
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/documentPrintWidth.js
var require_documentPrintWidth = __commonJS({
  "../../packages/client/out/features/documentPrintWidth.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      context.subscriptions.push(languageClient.onRequest(shared.GetDocumentPrintWidthRequest.type, (handler) => {
        const configs = vscode2.workspace.getConfiguration("volar");
        return configs.get("formatting.printWidth");
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../node_modules/.pnpm/@babel+parser@7.17.3/node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/@babel+parser@7.17.3/node_modules/@babel/parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin, name) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node, comments) {
      if (node.leadingComments === void 0) {
        node.leadingComments = comments;
      } else {
        node.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename)
          comment.loc.filename = this.filename;
        this.state.comments.push(comment);
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(commentStart - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              default: {
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0)
          return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
      takeSurroundingComments(node, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0)
          return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var ErrorCodes = Object.freeze({
      SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
      SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
    });
    var ErrorMessages = makeErrorTemplates({
      AccessorIsGenerator: "A %0ter cannot be a generator.",
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accesor must not have any formal parameters.",
      BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: "'%0' require an initialization value.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: "Unsyntactic %0.",
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
      ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
      ImportCallArity: "`import()` requires exactly %0.",
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: "Expected number in radix %0.",
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
      InvalidIdentifier: "Invalid identifier %0.",
      InvalidLhs: "Invalid left-hand side in %0.",
      InvalidLhsBinding: "Binding invalid left-hand side in %0.",
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: "Unexpected character '%0'.",
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: "Label '%0' is already declared.",
      LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
      ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
      ModuleExportUndefined: "Export '%0' is not defined.",
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.',
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: "Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.",
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
      PrivateNameRedeclaration: "Duplicate private name #%0.",
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      StaticPrototype: "Classes may not have static property named prototype.",
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: "Assigning to '%0' in strict mode.",
      StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: "Unexpected keyword '%0'.",
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: "Unexpected reserved word '%0'.",
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: "Unexpected token '%0'.",
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      VarRedeclaration: "Identifier '%0' has already been declared.",
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    }, ErrorCodes.SyntaxError);
    var SourceTypeModuleErrorMessages = makeErrorTemplates({
      ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
      ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`
    }, ErrorCodes.SourceTypeModuleError);
    function keepReasonCodeCompat(reasonCode, syntaxPlugin) {
      {
        if (syntaxPlugin === "flow" && reasonCode === "PatternIsOptional") {
          return "OptionalBindingPattern";
        }
      }
      return reasonCode;
    }
    function makeErrorTemplates(messages, code, syntaxPlugin) {
      const templates = {};
      Object.keys(messages).forEach((reasonCode) => {
        templates[reasonCode] = Object.freeze({
          code,
          reasonCode: keepReasonCodeCompat(reasonCode, syntaxPlugin),
          template: messages[reasonCode]
        });
      });
      return Object.freeze(templates);
    }
    var ParserError = class extends CommentsParser {
      raise({
        code,
        reasonCode,
        template
      }, origin, ...params) {
        return this.raiseWithData(origin.node ? origin.node.loc.start : origin.at, {
          code,
          reasonCode
        }, template, ...params);
      }
      raiseOverwrite(loc, {
        code,
        template
      }, ...params) {
        const pos = loc.index;
        const message = template.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
        if (this.options.errorRecovery) {
          const errors = this.state.errors;
          for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            if (error.pos === pos) {
              return Object.assign(error, {
                message
              });
            } else if (error.pos < pos) {
              break;
            }
          }
        }
        return this._raise({
          code,
          loc,
          pos
        }, message);
      }
      raiseWithData(loc, data, errorTemplate, ...params) {
        const pos = loc.index;
        const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
        return this._raise(Object.assign({
          loc,
          pos
        }, data), message);
      }
      _raise(errorContext, message) {
        const err = new SyntaxError(message);
        Object.assign(err, errorContext);
        if (this.options.errorRecovery) {
          if (!this.isLookahead)
            this.state.errors.push(err);
          return err;
        } else {
          throw err;
        }
      }
    };
    var {
      defineProperty
    } = Object;
    var toUnenumerable = (object, key) => defineProperty(object, key, {
      enumerable: false,
      value: object[key]
    });
    function toESTreeLocation(node) {
      toUnenumerable(node.loc.start, "index");
      toUnenumerable(node.loc.end, "index");
      return node;
    }
    var estree = (superClass) => class extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.options.tokens) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      directiveToStmt(directive) {
        const directiveLiteral = directive.value;
        const stmt = this.startNodeAt(directive.start, directive.loc.start);
        const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
        expression.value = directiveLiteral.extra.expressionValue;
        expression.raw = directiveLiteral.extra.raw;
        stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.loc.end);
        stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
        return this.finishNodeAt(stmt, "ExpressionStatement", directive.loc.end);
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, ...args) {
        super.parseBlockBody(node, ...args);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }
        classBody.body.push(method);
      }
      parsePrivateName() {
        const node = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name;
        node.type = "PrivateIdentifier";
        return node;
      }
      isPrivateName(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node);
          }
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node);
          }
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        type = "MethodDefinition";
        return this.finishNode(node, type);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        propertyNode.computed = false;
        return propertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
        if (node) {
          node.type = "Property";
          if (node.kind === "method")
            node.kind = "init";
          node.shorthand = false;
        }
        return node;
      }
      parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          node.type = "Property";
        }
        return node;
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          const {
            key,
            value
          } = node;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
          return node;
        }
        return super.toAssignable(node, isLHS);
      }
      toAssignableObjectExpressionProp(prop, ...args) {
        if (prop.kind === "get" || prop.kind === "set") {
          this.raise(ErrorMessages.PatternHasAccessor, {
            node: prop.key
          });
        } else if (prop.method) {
          this.raise(ErrorMessages.PatternHasMethod, {
            node: prop.key
          });
        } else {
          super.toAssignableObjectExpressionProp(prop, ...args);
        }
      }
      finishCallExpression(node, optional) {
        super.finishCallExpression(node, optional);
        if (node.callee.type === "Import") {
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          if (this.hasPlugin("importAssertions")) {
            var _node$arguments$;
            node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
          }
          delete node.arguments;
          delete node.callee;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(node) {
        super.parseExport(node);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
            break;
        }
        return node;
      }
      parseSubscript(base, startPos, startLoc, noCalls, state) {
        const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }
        return node;
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isOptionalChain(node) {
        return node.type === "ChainExpression";
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.method || node.kind === "get" || node.kind === "set";
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    {
      types.template = new TokContext("`", true);
    }
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name, options = {}) {
      options.keyword = name;
      const token = createToken(name, options);
      keywords$1.set(name, token);
      return token;
    }
    function createBinop(name, binop) {
      return createToken(name, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes.push(new ExportedTokenType(name, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name, tokenTypeCounter);
      tokenLabels.push(name);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}", {
        beforeExpr
      }),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd"),
      placeholder: createToken("%%", {
        startsExpr: true
      })
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 128;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 128;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 132;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 125 && token <= 127;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 117 && token <= 119;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 120 && token <= 126;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes[token];
    }
    {
      tokenTypes[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
        context.push(types.brace);
      };
      tokenTypes[22].updateContext = (context) => {
        if (context[context.length - 1] === types.template) {
          context.pop();
        } else {
          context.push(types.template);
        }
      };
      tokenTypes[138].updateContext = (context) => {
        context.push(types.j_expr, types.j_oTag);
      };
    }
    var Position3 = class {
      constructor(line, col, index) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position, columnOffset) {
      const {
        line,
        column,
        index
      } = position;
      return new Position3(line, column + columnOffset, index + columnOffset);
    }
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code)
          return false;
        pos += set[i + 1];
        if (pos >= code)
          return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65)
        return code === 36;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48)
        return code === 36;
      if (code < 58)
        return true;
      if (code < 65)
        return false;
      if (code <= 90)
        return true;
      if (code < 97)
        return code === 95;
      if (code <= 122)
        return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var SCOPE_OTHER = 0;
    var SCOPE_PROGRAM = 1;
    var SCOPE_FUNCTION = 2;
    var SCOPE_ARROW = 4;
    var SCOPE_SIMPLE_CATCH = 8;
    var SCOPE_SUPER = 16;
    var SCOPE_DIRECT_SUPER = 32;
    var SCOPE_CLASS = 64;
    var SCOPE_STATIC_BLOCK = 128;
    var SCOPE_TS_MODULE = 256;
    var SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
    var BIND_KIND_VALUE = 1;
    var BIND_KIND_TYPE = 2;
    var BIND_SCOPE_VAR = 4;
    var BIND_SCOPE_LEXICAL = 8;
    var BIND_SCOPE_FUNCTION = 16;
    var BIND_FLAGS_NONE = 64;
    var BIND_FLAGS_CLASS = 128;
    var BIND_FLAGS_TS_ENUM = 256;
    var BIND_FLAGS_TS_CONST_ENUM = 512;
    var BIND_FLAGS_TS_EXPORT_ONLY = 1024;
    var BIND_FLAGS_FLOW_DECLARE_FN = 2048;
    var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS;
    var BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0;
    var BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0;
    var BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0;
    var BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS;
    var BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0;
    var BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM;
    var BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
    var BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE;
    var BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE;
    var BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM;
    var BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
    var BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
    var CLASS_ELEMENT_FLAG_STATIC = 4;
    var CLASS_ELEMENT_KIND_GETTER = 2;
    var CLASS_ELEMENT_KIND_SETTER = 1;
    var CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
    var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC;
    var CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC;
    var CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER;
    var CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER;
    var CLASS_ELEMENT_OTHER = 0;
    var Scope = class {
      constructor(flags) {
        this.var = /* @__PURE__ */ new Set();
        this.lexical = /* @__PURE__ */ new Set();
        this.functions = /* @__PURE__ */ new Set();
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(raise, inModule) {
        this.scopeStack = [];
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.raise = raise;
        this.inModule = inModule;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & SCOPE_STATIC_BLOCK) {
            return true;
          }
          if (flags & (SCOPE_VAR | SCOPE_CLASS)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        this.scopeStack.pop();
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
      }
      declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          if (bindingType & BIND_SCOPE_FUNCTION) {
            scope.functions.add(name);
          } else {
            scope.lexical.add(name);
          }
          if (bindingType & BIND_SCOPE_LEXICAL) {
            this.maybeExportDefined(scope, name);
          }
        } else if (bindingType & BIND_SCOPE_VAR) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            scope.var.add(name);
            this.maybeExportDefined(scope, name);
            if (scope.flags & SCOPE_VAR)
              break;
          }
        }
        if (this.inModule && scope.flags & SCOPE_PROGRAM) {
          this.undefinedExports.delete(name);
        }
      }
      maybeExportDefined(scope, name) {
        if (this.inModule && scope.flags & SCOPE_PROGRAM) {
          this.undefinedExports.delete(name);
        }
      }
      checkRedeclarationInScope(scope, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) {
          this.raise(ErrorMessages.VarRedeclaration, {
            at: loc
          }, name);
        }
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & BIND_KIND_VALUE))
          return false;
        if (bindingType & BIND_SCOPE_LEXICAL) {
          return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
        }
        if (bindingType & BIND_SCOPE_FUNCTION) {
          return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
        }
        return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
          this.undefinedExports.set(name, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & SCOPE_VAR) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
          scope.declareFunctions.add(name);
          return;
        }
        super.declareName(...arguments);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(...arguments))
          return true;
        if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
          return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var lineBreak = /\r\n?|[\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
      switch (code) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y;
    var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
    function isWhitespace2(code) {
      switch (code) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State = class {
      constructor() {
        this.strict = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.maybeInArrowParameters = false;
        this.inType = false;
        this.noAnonFunctionType = false;
        this.hasFlowComment = false;
        this.isAmbientContext = false;
        this.inAbstractClass = false;
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.soloAwait = false;
        this.inFSharpPipelineDirectBody = false;
        this.labels = [];
        this.decoratorStack = [[]];
        this.comments = [];
        this.commentStack = [];
        this.pos = 0;
        this.type = 135;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.lastTokStart = 0;
        this.context = [types.brace];
        this.canStartJSXElement = true;
        this.containsEsc = false;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      init({
        strictMode,
        sourceType,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position3(startLine, startColumn, 0);
      }
      curPosition() {
        return new Position3(this.curLine, this.pos - this.lineStart, this.pos);
      }
      clone(skipArrays) {
        const state = new State();
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          let val = this[key];
          if (!skipArrays && Array.isArray(val)) {
            val = val.slice();
          }
          state[key] = val;
        }
        return state;
      }
    };
    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
      hex: [46, 88, 95, 120]
    };
    var allowedNumericSeparatorSiblings = {};
    allowedNumericSeparatorSiblings.bin = [48, 49];
    allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
    allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
    allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
    var Token = class {
      constructor(state) {
        this.type = state.type;
        this.value = state.value;
        this.start = state.start;
        this.end = state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends ParserError {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokStart = this.state.start;
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(({
            message,
            loc
          }) => this.raise(message, {
            at: loc
          }));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead)
          this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(135);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment() {
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf("*/", start + 2);
        if (end === -1) {
          throw this.raise(ErrorMessages.UnterminatedComment, {
            at: this.state.curPosition()
          });
        }
        this.state.pos = end + 2;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead)
          return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start,
          end: end + 2,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead)
          startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead)
          return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start,
          end,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens)
          this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = [];
        loop:
          while (this.state.pos < this.length) {
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
              case 32:
              case 160:
              case 9:
                ++this.state.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                  ++this.state.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.state.pos;
                ++this.state.curLine;
                this.state.lineStart = this.state.pos;
                break;
              case 47:
                switch (this.input.charCodeAt(this.state.pos + 1)) {
                  case 42: {
                    const comment = this.skipBlockComment();
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                    break;
                  }
                  case 47: {
                    const comment = this.skipLineComment(2);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                    break;
                  }
                  default:
                    break loop;
                }
                break;
              default:
                if (isWhitespace2(ch)) {
                  ++this.state.pos;
                } else if (ch === 45 && !this.inModule) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                    const comment = this.skipLineComment(3);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else if (ch === 60 && !this.inModule) {
                  const pos = this.state.pos;
                  if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                    const comment = this.skipLineComment(4);
                    if (comment !== void 0) {
                      this.addComment(comment);
                      if (this.options.attachComment)
                        comments.push(comment);
                    }
                  } else {
                    break loop;
                  }
                } else {
                  break loop;
                }
            }
          }
        if (comments.length > 0) {
          const end = this.state.pos;
          const CommentWhitespace = {
            start: spaceStart,
            end,
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(CommentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(ErrorMessages.UnexpectedDigitAfterHash, {
            at: this.state.curPosition()
          });
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
            throw this.raise(next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart(next)) {
          ++this.state.pos;
          this.finishToken(134, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(134, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2)
          return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33)
          return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code) {
        let type = code === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType, {
                at: this.state.curPosition()
              });
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            throw this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code) {
        switch (code) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType, {
                  at: this.state.curPosition()
                });
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code)) {
              this.readWord(code);
              return;
            }
        }
        throw this.raise(ErrorMessages.InvalidOrUnexpectedToken, {
          at: this.state.curPosition()
        }, String.fromCodePoint(code));
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(ErrorMessages.UnterminatedRegExp, {
              at: createPositionWithColumnOffset(startLoc, 1)
            });
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(ErrorMessages.UnterminatedRegExp, {
              at: createPositionWithColumnOffset(startLoc, 1)
            });
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              this.expectPlugin("regexpUnicodeSets", nextPos());
              if (mods.includes("u")) {
                this.raise(ErrorMessages.IncompatibleRegExpUVFlags, {
                  at: nextPos()
                });
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(ErrorMessages.IncompatibleRegExpUVFlags, {
                  at: nextPos()
                });
              }
            }
            if (mods.includes(char)) {
              this.raise(ErrorMessages.DuplicateRegExpFlags, {
                at: nextPos()
              });
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(ErrorMessages.MalformedRegExpFlags, {
              at: nextPos()
            });
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(133, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen, allowNumSeparator = true) {
        const start = this.state.pos;
        const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
        const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
        let invalid = false;
        let total = 0;
        for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          const code = this.input.charCodeAt(this.state.pos);
          let val;
          if (code === 95) {
            const prev = this.input.charCodeAt(this.state.pos - 1);
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (allowedSiblings.indexOf(next) === -1) {
              this.raise(ErrorMessages.UnexpectedNumericSeparator, {
                at: this.state.curPosition()
              });
            } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
              this.raise(ErrorMessages.UnexpectedNumericSeparator, {
                at: this.state.curPosition()
              });
            }
            if (!allowNumSeparator) {
              this.raise(ErrorMessages.NumericSeparatorInEscapeSequence, {
                at: this.state.curPosition()
              });
            }
            ++this.state.pos;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (_isDigit(code)) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            if (this.options.errorRecovery && val <= 9) {
              val = 0;
              this.raise(ErrorMessages.InvalidDigit, {
                at: this.state.curPosition()
              }, radix);
            } else if (forceLen) {
              val = 0;
              invalid = true;
            } else {
              break;
            }
          }
          ++this.state.pos;
          total = total * radix + val;
        }
        if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
          return null;
        }
        return total;
      }
      readRadixNumber(radix) {
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(ErrorMessages.InvalidDigit, {
            at: createPositionWithColumnOffset(startLoc, 2)
          }, radix);
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(ErrorMessages.InvalidDecimal, {
            at: startLoc
          });
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(ErrorMessages.NumberIdentifier, {
            at: this.state.curPosition()
          });
        }
        if (isBigInt) {
          const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(131, str);
          return;
        }
        this.finishToken(130, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let isDecimal = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(ErrorMessages.InvalidNumber, {
            at: this.state.curPosition()
          });
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer3 = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(ErrorMessages.StrictOctalLiteral, startLoc);
          if (!this.state.strict) {
            const underscorePos = integer3.indexOf("_");
            if (underscorePos > 0) {
              this.raise(ErrorMessages.ZeroDigitNumericSeparator, {
                at: createPositionWithColumnOffset(startLoc, underscorePos)
              });
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer3);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(ErrorMessages.InvalidOrMissingExponent, {
              at: startLoc
            });
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(ErrorMessages.InvalidBigIntLiteral, {
              at: startLoc
            });
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(ErrorMessages.InvalidDecimal, {
              at: startLoc
            });
          }
          ++this.state.pos;
          isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(ErrorMessages.NumberIdentifier, {
            at: this.state.curPosition()
          });
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(131, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(132, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(130, val);
      }
      readCodePoint(throwOnInvalid) {
        const ch = this.input.charCodeAt(this.state.pos);
        let code;
        if (ch === 123) {
          ++this.state.pos;
          code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
          ++this.state.pos;
          if (code !== null && code > 1114111) {
            if (throwOnInvalid) {
              this.raise(ErrorMessages.InvalidCodePoint, {
                at: this.state.curPosition()
              });
            } else {
              return null;
            }
          }
        } else {
          code = this.readHexChar(4, false, throwOnInvalid);
        }
        return code;
      }
      readString(quote) {
        let out = "", chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(ErrorMessages.UnterminatedString, {
              at: this.state.startLoc
            });
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote)
            break;
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.state.pos;
          } else if (ch === 8232 || ch === 8233) {
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
          } else if (isNewLine(ch)) {
            throw this.raise(ErrorMessages.UnterminatedString, {
              at: this.state.startLoc
            });
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(129, out);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        let out = "", chunkStart = this.state.pos, containsInvalid = false;
        ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(ErrorMessages.UnterminatedTemplate, {
              at: createPositionWithColumnOffset(this.state.startLoc, 1)
            });
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === 96) {
            ++this.state.pos;
            out += this.input.slice(chunkStart, this.state.pos);
            this.finishToken(24, containsInvalid ? null : out);
            return;
          }
          if (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
            this.state.pos += 2;
            out += this.input.slice(chunkStart, this.state.pos);
            this.finishToken(25, containsInvalid ? null : out);
            return;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.state.pos);
            const escaped = this.readEscapedChar(true);
            if (escaped === null) {
              containsInvalid = true;
            } else {
              out += escaped;
            }
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            ++this.state.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.state.pos) === 10) {
                  ++this.state.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
      }
      recordStrictModeErrors(message, loc) {
        if (this.state.strict && !this.state.strictErrors.has(loc.index)) {
          this.raise(message, {
            at: loc
          });
        } else {
          this.state.strictErrors.set(loc.index, {
            loc,
            message
          });
        }
      }
      readEscapedChar(inTemplate) {
        const throwOnInvalid = !inTemplate;
        const ch = this.input.charCodeAt(++this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120: {
            const code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }
          case 117: {
            const code = this.readCodePoint(throwOnInvalid);
            return code === null ? null : String.fromCodePoint(code);
          }
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) {
              ++this.state.pos;
            }
          case 10:
            this.state.lineStart = this.state.pos;
            ++this.state.curLine;
          case 8232:
          case 8233:
            return "";
          case 56:
          case 57:
            if (inTemplate) {
              return null;
            } else {
              this.recordStrictModeErrors(ErrorMessages.StrictNumericEscape, createPositionWithColumnOffset(this.state.curPosition(), -1));
            }
          default:
            if (ch >= 48 && ch <= 55) {
              const codePos = createPositionWithColumnOffset(this.state.curPosition(), -1);
              const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
              let octalStr = match[0];
              let octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.state.pos += octalStr.length - 1;
              const next = this.input.charCodeAt(this.state.pos);
              if (octalStr !== "0" || next === 56 || next === 57) {
                if (inTemplate) {
                  return null;
                } else {
                  this.recordStrictModeErrors(ErrorMessages.StrictNumericEscape, codePos);
                }
              }
              return String.fromCharCode(octal);
            }
            return String.fromCharCode(ch);
        }
      }
      readHexChar(len, forceLen, throwOnInvalid) {
        const codeLoc = this.state.curPosition();
        const n = this.readInt(16, len, forceLen, false);
        if (n === null) {
          if (throwOnInvalid) {
            this.raise(ErrorMessages.InvalidEscapeSequence, {
              at: codeLoc
            });
          } else {
            this.state.pos = codeLoc.index - 1;
          }
        }
        return n;
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(ErrorMessages.MissingUnicodeEscape, {
                at: this.state.curPosition()
              });
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(ErrorMessages.EscapedCharNotAnIdentifier, {
                  at: escStart
                });
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(128, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(ErrorMessages.InvalidEscapedReservedWord, {
            at: this.state.startLoc
          }, tokenLabelName(type));
        }
      }
      updateContext(prevType) {
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(raise) {
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.raise = raise;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name)) {
              current.undefinedPrivateNames.set(name, loc);
            }
          } else {
            this.raise(ErrorMessages.InvalidPrivateFieldResolution, {
              at: loc
            }, name);
          }
        }
      }
      declarePrivateName(name, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name);
        if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
          const accessor = redefined && loneAccessors.get(name);
          if (accessor) {
            const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
            const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
            const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
            const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined)
              loneAccessors.delete(name);
          } else if (!redefined) {
            loneAccessors.set(name, elementType);
          }
        }
        if (redefined) {
          this.raise(ErrorMessages.PrivateNameRedeclaration, {
            at: loc
          }, name);
        }
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
      }
      usePrivateName(name, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name))
            return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name, loc);
        } else {
          this.raise(ErrorMessages.InvalidPrivateFieldResolution, {
            at: loc
          }, name);
        }
      }
    };
    var kExpression = 0;
    var kMaybeArrowParameterDeclaration = 1;
    var kMaybeAsyncArrowParameterDeclaration = 2;
    var kParameterDeclaration = 3;
    var ExpressionScope = class {
      constructor(type = kExpression) {
        this.type = void 0;
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
      }
      isCertainlyParameterDeclaration() {
        return this.type === kParameterDeclaration;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.errors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(message, loc) {
        this.errors.set(loc.index, {
          message,
          loc
        });
      }
      clearDeclarationError(loc) {
        this.errors.delete(loc.index);
      }
      iterateErrors(iterator) {
        this.errors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(raise) {
        this.stack = [new ExpressionScope()];
        this.raise = raise;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(loc, template) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(template, loc);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.raise(template, {
          at: loc
        });
      }
      recordParenthesizedIdentifierError(template, loc) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        if (scope.isCertainlyParameterDeclaration()) {
          this.raise(template, {
            at: loc
          });
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(template, loc);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(template, loc) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
            scope.recordDeclarationError(template, loc);
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration())
          return;
        currentScope.iterateErrors(({
          message,
          loc
        }) => {
          this.raise(message, {
            at: loc
          });
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(kParameterDeclaration);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var PARAM = 0;
    var PARAM_YIELD = 1;
    var PARAM_AWAIT = 2;
    var PARAM_RETURN = 4;
    var PARAM_IN = 8;
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & PARAM_AWAIT) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & PARAM_YIELD) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & PARAM_RETURN) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & PARAM_IN) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, value, enumerable = true) {
        if (!node)
          return;
        const extra = node.extra = node.extra || {};
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, template) {
        if (!this.eatContextual(token)) {
          if (template != null) {
            throw this.raise(template, {
              at: this.state.startLoc
            });
          }
          throw this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13))
          return;
        this.raise(ErrorMessages.MissingSemicolon, {
          at: this.state.lastTokEndLoc
        });
      }
      expect(type, loc) {
        this.eat(type) || this.unexpected(loc, type);
      }
      assertNoSpace(message = "Unexpected space.") {
        if (this.state.start > this.state.lastTokEndLoc.index) {
          this.raise({
            code: ErrorCodes.SyntaxError,
            reasonCode: "UnexpectedSpace",
            template: message
          }, {
            at: this.state.lastTokEndLoc
          });
        }
      }
      unexpected(loc, type) {
        throw this.raise({
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedToken",
          template: type != null ? `Unexpected token, expected "${tokenLabelName(type)}"` : "Unexpected token"
        }, {
          at: loc != null ? loc : this.state.startLoc
        });
      }
      getPluginNamesFromConfigs(pluginConfigs) {
        return pluginConfigs.map((c) => {
          if (typeof c === "string") {
            return c;
          } else {
            return c[0];
          }
        });
      }
      expectPlugin(pluginConfig, loc) {
        if (!this.hasPlugin(pluginConfig)) {
          throw this.raiseWithData(loc != null ? loc : this.state.startLoc, {
            missingPlugin: this.getPluginNamesFromConfigs([pluginConfig])
          }, `This experimental syntax requires enabling the parser plugin: ${JSON.stringify(pluginConfig)}.`);
        }
        return true;
      }
      expectOnePlugin(pluginConfigs) {
        if (!pluginConfigs.some((c) => this.hasPlugin(c))) {
          throw this.raiseWithData(this.state.startLoc, {
            missingPlugin: this.getPluginNamesFromConfigs(pluginConfigs)
          }, `This experimental syntax requires enabling one of the following parser plugin(s): ${pluginConfigs.map((c) => JSON.stringify(c)).join(", ")}.`);
        }
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors)
          return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(ErrorMessages.InvalidCoverInitializedName, {
            at: shorthandAssignLoc
          });
        }
        if (doubleProtoLoc != null) {
          this.raise(ErrorMessages.DuplicateProto, {
            at: doubleProtoLoc
          });
        }
        if (privateKeyLoc != null) {
          this.raise(ErrorMessages.UnexpectedPrivateField, {
            at: privateKeyLoc
          });
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isOptionalChain(node) {
        return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this.raise.bind(this), this.inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this.raise.bind(this));
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = PARAM;
        if (this.inModule) {
          paramFlags |= PARAM_AWAIT;
        }
        this.scope.enter(SCOPE_PROGRAM);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node2 = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if (parser != null && parser.options.ranges)
          this.range = [pos, 0];
        if (parser != null && parser.filename)
          this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node2.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node2();
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node) {
      return cloneIdentifier(node);
    }
    function cloneIdentifier(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra,
        name
      } = node;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name;
      if (type === "Placeholder") {
        cloned.expectedNode = node.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra
      } = node;
      if (type === "Placeholder") {
        return clonePlaceholder(node);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      if (node.raw !== void 0) {
        cloned.raw = node.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        return new Node2(this, this.state.start, this.state.startLoc);
      }
      startNodeAt(pos, loc) {
        return new Node2(this, pos, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.start, type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges)
          node.range[1] = endLoc.index;
        if (this.options.attachComment)
          this.processComment(node);
        return node;
      }
      resetStartLocation(node, start, startLoc) {
        node.start = start;
        node.loc.start = startLoc;
        if (this.options.ranges)
          node.range[0] = start;
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges)
          node.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = makeErrorTemplates({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: "Cannot overwrite reserved type %0.",
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
      EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
      EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
      EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
      EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
      EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
      EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
      EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
      EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
      EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
      EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: "Unexpected reserved type %0.",
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    }, ErrorCodes.SyntaxError, "flow");
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    function isMaybeDefaultImport(type) {
      return tokenIsKeywordOrIdentifier(type) && type !== 97;
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
      finishToken(type, val) {
        if (type !== 129 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        return super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches)
            ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        return super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(107);
        if (this.state.lastTokStart > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
            at: moduloLoc
          });
        }
        if (this.eat(10)) {
          node.value = this.parseExpression();
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(123)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, {
                at: this.state.lastTokStartLoc
              });
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(126)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(127)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(125)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          throw this.unexpected();
        }
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(SCOPE_OTHER);
        if (this.match(129)) {
          node.id = this.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(126) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                at: this.state.lastTokStartLoc
              });
            }
            this.parseImport(bodyNode2);
          } else {
            this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                node: bodyElement
              });
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                node: bodyElement
              });
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                node: bodyElement
              });
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {
            const label = this.state.value;
            const suggestion = exportSuggestions[label];
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
              at: this.state.startLoc
            }, label, suggestion);
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) {
            node = this.parseExport(node);
            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }
            node.type = "Declare" + node.type;
            return node;
          }
        }
        throw this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(108);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        this.flowParseTypeAlias(node);
        node.type = "DeclareTypeAlias";
        return node;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        this.flowParseOpaqueType(node, true);
        node.type = "DeclareOpaqueType";
        return node;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass = false) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        node.implements = [];
        node.mixins = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (this.isContextual(114)) {
          this.next();
          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        if (this.isContextual(110)) {
          this.next();
          do {
            node.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, {
            at: this.state.startLoc
          });
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word))
          return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
          at: startLoc
        }, word);
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual(126);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, {
              at: nodeStartLoc
            });
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(138)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;
        while (!this.match(48)) {
          node.params.push(this.flowParseType());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual(125);
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node = this.startNode();
          if (allowProto && this.isContextual(115)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(104)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(98) || this.isContextual(103)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
              at: inexactStartLoc
            });
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, {
                at: this.state.lastTokStartLoc
              });
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, {
                at: this.state.lastTokStartLoc
              });
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, {
                node: variance
              });
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, {
              at: this.state.lastTokStartLoc
            });
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, {
              node: variance
            });
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, {
                node: node.value.this
              });
            }
          } else {
            if (kind !== "init")
              this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
            node: property.value.this
          });
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? ErrorMessages.BadGetterArity : ErrorMessages.BadSetterArity, {
            node: property
          });
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(ErrorMessages.BadSetterRestParameter, {
            node: property
          });
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
        startPos = startPos || this.state.start;
        startLoc = startLoc || this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startPos, startLoc, id) {
        const node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3))
            break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, {
              node
            });
          }
          name = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, {
                node
              });
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.start, type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startPos, startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47:
            node.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node.params = tmp.params;
            node.rest = tmp.rest;
            node.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node.returnType = this.flowParseType();
            return this.finishNode(node, "FunctionTypeAnnotation");
          case 10:
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node.params = tmp.params;
            node.rest = tmp.rest;
            node.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");
          case 129:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(130)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(131)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                at: this.state.startLoc
              });
            }
            throw this.unexpected();
          case 130:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 131:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(125)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
            }
        }
        throw this.unexpected();
      }
      flowParsePostfixType() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startPos, startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node = this.startNodeAt(param.start, param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 128 && this.state.value === "_") {
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startPos, startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
        }
        return super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatement(context, topLevel) {
        if (this.state.strict && this.isContextual(125)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.shouldParseEnums() && this.isContextual(122)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatement(context, topLevel);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual(122)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startPos, startLoc, refExpressionErrors) {
        if (!this.match(17))
          return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startPos, startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, {
              at: state.startLoc
            });
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];
        while (stack.length !== 0) {
          const node2 = stack.pop();
          if (node2.type === "ArrowFunctionExpression") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack.push(node2.consequent);
            stack.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse3) {
        let result;
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse3();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse3();
        }
        return result;
      }
      parseParenItem(node, startPos, startLoc) {
        node = super.parseParenItem(node, startPos, startLoc);
        if (this.eat(17)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return node;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExport(node) {
        const decl = super.parseExport(node);
        if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
          decl.exportKind = decl.exportKind || "value";
        }
        return decl;
      }
      parseExportDeclaration(node) {
        if (this.isContextual(126)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            this.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(127)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(125)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.shouldParseEnums() && this.isContextual(122)) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(...arguments))
          return true;
        if (this.isContextual(126) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(121)) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, {
              at: startLoc
            });
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, {
              node: member.value
            });
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(ErrorMessages.InvalidIdentifier, {
            at: this.state.curPosition()
          }, fullWord);
        }
        this.finishToken(128, fullWord);
      }
      getTokenFromCode(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 123 && next === 124) {
          return this.finishOp(6, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(code === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code === 63) {
          if (next === 46) {
            return this.finishOp(18, 2);
          }
          return this.finishOp(17, 1);
        } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          return this.readIterator();
        } else {
          return super.getTokenFromCode(code);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (node.type === "TypeCastExpression") {
          return super.toAssignable(this.typeCastToParameter(node), isLHS);
        } else {
          return super.toAssignable(node, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        return super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, {
              node: expr.typeAnnotation
            });
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      checkLVal(expr, ...args) {
        if (expr.type !== "TypeCastExpression") {
          return super.checkLVal(expr, ...args);
        }
      }
      parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, {
              node: method
            });
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, {
              node: method
            });
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && this.match(47)) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }
        if (this.isContextual(110)) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, {
              node: param
            });
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, {
              node: param
            });
          }
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10))
            this.unexpected();
        }
        super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (prop.value || prop).typeParameters = typeParameters;
        }
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, {
              node: param
            });
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, {
              node: param
            });
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, {
            node: param
          });
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, {
            node: param
          });
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        const node = super.parseMaybeDefault(startPos, startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, {
            node: node.typeAnnotation
          });
        }
        return node;
      }
      shouldParseDefaultImport(node) {
        if (!hasTypeImportKind(node)) {
          return super.shouldParseDefaultImport(node);
        }
        return isMaybeDefaultImport(this.state.type);
      }
      parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, type));
      }
      maybeParseDefaultImportSpecifier(node) {
        node.importKind = "value";
        let kind = null;
        if (this.match(87)) {
          kind = "typeof";
        } else if (this.isContextual(126)) {
          kind = "type";
        }
        if (kind) {
          const lh = this.lookahead();
          const {
            type
          } = lh;
          if (kind === "type" && type === 55) {
            this.unexpected(null, lh.type);
          }
          if (isMaybeDefaultImport(type) || type === 5 || type === 55) {
            this.next();
            node.importKind = kind;
          }
        }
        return super.maybeParseDefaultImportSpecifier(node);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(ErrorMessages.ImportBindingIsString, {
                node: specifier
              }, firstIdent.value);
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
            node: specifier
          });
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
        return this.finishNode(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, allowModifiers) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, allowModifiers);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error)
            return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized)
              abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression")
              abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                  node: typeParameters
                });
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown)
            throw jsx2.error;
          if (arrow.thrown)
            throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
            node: typeParameters
          });
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon())
              this.unexpected();
            if (!this.match(19))
              this.unexpected();
            return typeNode;
          });
          if (result.thrown)
            return null;
          if (result.error)
            this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          return;
        }
        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, {
              node: node.params[i]
            });
          }
        }
        return super.checkParams(...arguments);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      }
      parseSubscripts(base, startPos, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseCallExpressionArguments(11, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted)
            return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
          if (result.node && !result.error)
            return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startPos, startLoc, noCalls);
      }
      parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments(11, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node.arguments = this.parseCallExpressionArguments(11, false);
            if (subscriptState.optionalChainMember)
              node.optional = false;
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error)
              this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
      }
      parseNewArguments(node) {
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
        super.parseNewArguments(node);
      }
      parseAsyncArrowWithTypeParameters(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        this.parseFunctionParams(node);
        if (!this.parseArrow(node))
          return;
        return this.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code);
      }
      readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, {
            at: this.state.curPosition()
          });
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, {
              at: this.state.startLoc
            });
          }
          this.hasFlowCommentCompletion();
          this.state.pos += this.skipFlowComment();
          this.state.hasFlowComment = true;
          return;
        }
        if (this.state.hasFlowComment) {
          const end = this.input.indexOf("*-/", this.state.pos + 2);
          if (end === -1) {
            throw this.raise(ErrorMessages.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
          this.state.pos = end + 2 + 3;
          return;
        }
        return super.skipBlockComment();
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(ErrorMessages.UnterminatedComment, {
            at: this.state.curPosition()
          });
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
          at: loc
        }, memberName, enumName);
      }
      flowEnumErrorInvalidExplicitType(loc, {
        enumName,
        suppliedType
      }) {
        return this.raise(suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, {
          at: loc
        }, enumName, suppliedType);
      }
      flowEnumErrorInvalidMemberInitializer(loc, {
        enumName,
        explicitType,
        memberName
      }) {
        return this.raise(explicitType === "boolean" || explicitType === "number" || explicitType === "string" ? FlowErrors.EnumInvalidMemberInitializerPrimaryType : explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerUnknownType, {
          at: loc
        }, enumName, memberName, explicitType);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
          at: loc
        }, enumName, memberName);
      }
      flowEnumErrorStringMemberInconsistentlyInitailized(node, {
        enumName
      }) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
          node
        }, enumName);
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 130: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 129: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, {
              node: id
            }, memberName, memberName[0].toUpperCase() + memberName.slice(1), enumName);
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, {
              node: id
            }, memberName, enumName);
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (this.eatContextual(101)) {
          if (!tokenIsIdentifier(this.state.type)) {
            throw this.flowEnumErrorInvalidExplicitType(this.state.startLoc, {
              enumName,
              suppliedType: null
            });
          }
          const {
            value
          } = this.state;
          this.next();
          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.flowEnumErrorInvalidExplicitType(this.state.startLoc, {
              enumName,
              suppliedType: value
            });
          }
          return value;
        }
        return null;
      }
      flowEnumBody(node, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty = () => {
              node.members = [];
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, {
                at: nameLoc
              }, enumName);
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities2 = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var HEX_NUMBER = /^[\da-fA-F]+$/;
    var DECIMAL_NUMBER = /^\d+$/;
    var JsxErrors = makeErrorTemplates({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    }, ErrorCodes.SyntaxError, "jsx");
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, {
              at: this.state.startLoc
            });
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  return this.finishToken(138);
                }
                return super.getTokenFromCode(ch);
              }
              out += this.input.slice(chunkStart, this.state.pos);
              return this.finishToken(137, out);
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(ErrorMessages.UnterminatedString, {
              at: this.state.startLoc
            });
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote)
            break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(129, out);
      }
      jsxReadEntity() {
        let str = "";
        let count = 0;
        let entity;
        let ch = this.input[this.state.pos];
        const startPos = ++this.state.pos;
        while (this.state.pos < this.length && count++ < 10) {
          ch = this.input[this.state.pos++];
          if (ch === ";") {
            if (str[0] === "#") {
              if (str[1] === "x") {
                str = str.substr(2);
                if (HEX_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 16));
                }
              } else {
                str = str.substr(1);
                if (DECIMAL_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 10));
                }
              }
            } else {
              entity = entities2[str];
            }
            break;
          }
          str += ch;
        }
        if (!entity) {
          this.state.pos = startPos;
          return "&";
        }
        return entity;
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        return this.finishToken(136, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(136)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        if (!this.eat(14))
          return name;
        const node = this.startNodeAt(startPos, startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, {
                node
              });
            }
            return node;
          case 138:
          case 129:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, {
              at: this.state.startLoc
            });
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types.j_oTag);
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.match(5)) {
          this.setContext(types.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types.j_oTag);
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        if (this.match(139)) {
          this.expect(139);
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(56) && !this.match(139)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(139);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        if (this.match(139)) {
          this.expect(139);
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(139);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents:
            for (; ; ) {
              switch (this.state.type) {
                case 138:
                  startPos = this.state.start;
                  startLoc = this.state.startLoc;
                  this.next();
                  if (this.eat(56)) {
                    closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsxParseElementAt(startPos, startLoc));
                  break;
                case 137:
                  children.push(this.parseExprAtom());
                  break;
                case 5: {
                  const node2 = this.startNode();
                  this.setContext(types.brace);
                  this.next();
                  if (this.match(21)) {
                    children.push(this.jsxParseSpreadChild(node2));
                  } else {
                    children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                  }
                  break;
                }
                default:
                  throw this.unexpected();
              }
            }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, {
              node: closingElement
            });
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, {
              node: closingElement
            }, getQualifiedJSXName(openingElement.name));
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, {
                node: closingElement
              }, getQualifiedJSXName(openingElement.name));
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
            at: this.state.startLoc
          });
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startPos, startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(137)) {
          return this.parseLiteral(this.state.value, "JSXText");
        } else if (this.match(138)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(138);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace)
          super.skipSpace();
      }
      getTokenFromCode(code) {
        const context = this.curContext();
        if (context === types.j_expr) {
          return this.jsxReadToken();
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart(code)) {
            return this.jsxReadWord();
          }
          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(139);
          }
          if ((code === 34 || code === 39) && context === types.j_oTag) {
            return this.jsxReadString(code);
          }
        }
        if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          return this.finishToken(138);
        }
        return super.getTokenFromCode(code);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 138) {
          context.splice(-2, 2, types.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 138) {
          context.push(types.j_oTag);
        } else if (type === 139) {
          const out = context[context.length - 1];
          if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
          } else {
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.types = /* @__PURE__ */ new Set();
        this.enums = /* @__PURE__ */ new Set();
        this.constEnums = /* @__PURE__ */ new Set();
        this.classes = /* @__PURE__ */ new Set();
        this.exportOnlyBindings = /* @__PURE__ */ new Set();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new TypeScriptScope(flags);
      }
      declareName(name, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
          this.maybeExportDefined(scope, name);
          scope.exportOnlyBindings.add(name);
          return;
        }
        super.declareName(...arguments);
        if (bindingType & BIND_KIND_TYPE) {
          if (!(bindingType & BIND_KIND_VALUE)) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
          }
          scope.types.add(name);
        }
        if (bindingType & BIND_FLAGS_TS_ENUM)
          scope.enums.add(name);
        if (bindingType & BIND_FLAGS_TS_CONST_ENUM)
          scope.constEnums.add(name);
        if (bindingType & BIND_FLAGS_CLASS)
          scope.classes.add(name);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (scope.enums.has(name)) {
          if (bindingType & BIND_FLAGS_TS_ENUM) {
            const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
            const wasConst = scope.constEnums.has(name);
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
          if (scope.lexical.has(name)) {
            return !!(bindingType & BIND_KIND_VALUE);
          } else {
            return false;
          }
        }
        if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
          return true;
        }
        return super.isRedeclaredInScope(...arguments);
      }
      checkLocalExport(id) {
        const topLevelScope = this.scopeStack[0];
        const {
          name
        } = id;
        if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
          super.checkLocalExport(id);
        }
      }
    };
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = makeErrorTemplates({
      AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
      AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.",
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: "'declare' is not allowed in %0ters.",
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
      DuplicateModifier: "Duplicate modifier: '%0'.",
      EmptyHeritageClauseType: "'%0' list cannot be empty.",
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
      InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
    }, ErrorCodes.SyntaxError, "typescript");
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    var typescript = (superClass) => class extends superClass {
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next();
        return this.tsTokenCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        if (!tokenIsIdentifier(this.state.type)) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.indexOf(modifier) !== -1) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate, stopOnStartOfClassStaticBlock) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, {
              at: loc
            }, before, after);
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, {
              at: loc
            }, mod1, mod2);
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
          if (!modifier)
            break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, {
                at: startLoc
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, {
                at: startLoc
              }, modifier);
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, {
              at: startLoc
            }, modifier);
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
        throw new Error("Unreachable");
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStart;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(129)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, {
            at: this.state.startLoc
          });
        }
        node.argument = this.parseExprAtom();
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName(true);
        }
        if (this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseEntityName(allowReservedWords) {
        let entity = this.parseIdentifier();
        while (this.eat(16)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName(false);
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName(true);
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters() {
        if (this.match(47)) {
          return this.tsParseTypeParameters();
        }
      }
      tsParseTypeParameters() {
        const node = this.startNode();
        if (this.match(47) || this.match(138)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true, refTrailingCommaPos);
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, {
            node
          });
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsTryNextParseConstantContext() {
        if (this.lookahead().type === 75) {
          this.next();
          return this.tsParseTypeReference();
        }
        return null;
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        return this.parseBindingList(11, 41).map((pattern) => {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, {
              node: pattern
            }, pattern.type);
          }
          return pattern;
        });
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return void 0;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17))
          node.optional = true;
        const nodeAny = node;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, {
              node
            });
          }
          const method = nodeAny;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
              at: this.state.curPosition()
            });
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(ErrorMessages.BadGetterArity, {
                at: this.state.curPosition()
              });
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                  at: this.state.curPosition()
                });
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(ErrorMessages.BadSetterArity, {
                at: this.state.curPosition()
              });
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                  at: this.state.curPosition()
                });
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                  at: this.state.curPosition()
                });
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                  at: this.state.curPosition()
                });
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                node: method[returnTypeKey]
              });
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly)
            property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type)
            property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        this.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          this.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(118);
        }
        if (this.isContextual(118)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(58);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(118);
        } else if (this.eatContextual(118)) {
          node.readonly = true;
        }
        this.expect(0);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        let labeledElements = null;
        node.elementTypes.forEach((elementNode) => {
          var _labeledElements;
          let {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, {
              node: elementNode
            });
          }
          seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";
          if (type === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
            type = elementNode.type;
          }
          const isLabeled = type === "TSNamedTupleMember";
          labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;
          if (labeledElements !== isLabeled) {
            this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
              node: elementNode
            });
          }
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const {
          start: startPos,
          startLoc
        } = this.state;
        const rest = this.eat(21);
        let type = this.tsParseType();
        const optional = this.eat(17);
        const labeled = this.eat(14);
        if (labeled) {
          const labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;
          if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
            labeledNode.label = type.typeName;
          } else {
            this.raise(TSErrors.InvalidTupleMemberLabel, {
              node: type
            });
            labeledNode.label = type;
          }
          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract)
            this.next();
          this.next();
        }
        this.tsFillSignature(19, node);
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        node.literal = (() => {
          switch (this.state.type) {
            case 130:
            case 131:
            case 129:
            case 85:
            case 86:
              return this.parseExprAtom();
            default:
              throw this.unexpected();
          }
        })();
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = this.parseTemplate(false);
        return this.finishNode(node, "TSLiteralType");
      }
      parseTemplateSubstitution() {
        if (this.state.inType)
          return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 129:
          case 130:
          case 131:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 130 && nextToken.type !== 131) {
                throw this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        throw this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, {
              node
            });
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(112);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          let braceStackCounter = 1;
          this.next();
          while (braceStackCounter > 0) {
            if (this.match(5)) {
              ++braceStackCounter;
            } else if (this.match(8)) {
              --braceStackCounter;
            }
            this.next();
          }
          return true;
        }
        if (this.match(0)) {
          let braceStackCounter = 1;
          this.next();
          while (braceStackCounter > 0) {
            if (this.match(0)) {
              ++braceStackCounter;
            } else if (this.match(3)) {
              --braceStackCounter;
            }
            this.next();
          }
          return true;
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
      }
      tsTryParseTypeAnnotation() {
        return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 106) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(ErrorMessages.InvalidEscapedReservedWord, {
            at: this.state.lastTokStartLoc
          }, "asserts");
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon)
            this.expect(14);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsParseNonConditionalType();
        this.expect(17);
        node.trueType = this.tsParseType();
        this.expect(14);
        node.falseType = this.tsParseType();
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(120) && this.lookahead().type === 77;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, {
            at: this.state.startLoc
          });
        }
        const node = this.startNode();
        const _const = this.tsTryNextParseConstantContext();
        node.typeAnnotation = _const || this.tsNextThenParseType();
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(descriptor) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, {
            at: originalStartLoc
          }, descriptor);
        }
        return delimitedList;
      }
      tsParseExpressionWithTypeArguments() {
        const node = this.startNode();
        node.expression = this.tsParseEntityName(false);
        if (this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSExpressionWithTypeArguments");
      }
      tsParseInterfaceDeclaration(node) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, {
            at: this.state.startLoc
          });
        }
        node.typeParameters = this.tsTryParseTypeParameters();
        if (this.eat(81)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
        node.typeParameters = this.tsTryParseTypeParameters();
        node.typeAnnotation = this.tsInType(() => {
          this.expect(29);
          if (this.isContextual(111) && this.lookahead().type !== 16) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInNoContext(cb) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsEatThenParseType(token) {
        return !this.match(token) ? void 0 : this.tsNextThenParseType();
      }
      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }
      tsDoThenParseType(cb) {
        return this.tsInType(() => {
          cb();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = this.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, isConst) {
        if (isConst)
          node.const = true;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(SCOPE_OTHER);
        this.expect(5);
        this.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(109)) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(129)) {
          node.id = this.parseExprAtom();
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, {
            node: moduleReference
          });
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(116) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(116);
        this.expect(10);
        if (!this.match(129)) {
          throw this.unexpected();
        }
        node.expression = this.parseExprAtom();
        this.expect(11);
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node)
          return void 0;
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        } else {
          this.state = state;
          return void 0;
        }
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let starttype = this.state.type;
        let kind;
        if (this.isContextual(99)) {
          starttype = 74;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          switch (starttype) {
            case 68:
              nany.declare = true;
              return this.parseFunctionStatement(nany, false, true);
            case 80:
              nany.declare = true;
              return this.parseClass(nany, true, false);
            case 75:
              if (this.match(75) && this.isLookaheadContextual("enum")) {
                this.expect(75);
                this.expectContextual(122);
                return this.tsParseEnumDeclaration(nany, true);
              }
            case 74:
              kind = kind || this.state.value;
              return this.parseVarStatement(nany, kind);
            case 109:
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            default: {
              if (tokenIsIdentifier(starttype)) {
                return this.tsParseDeclaration(nany, this.state.value, true);
              }
            }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true);
      }
      tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
              return declaration;
            }
            break;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false);
        }
      }
      tsParseDeclaration(node, value, next) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node);
            }
            break;
          case "enum":
            if (next || tokenIsIdentifier(this.state.type)) {
              if (next)
                this.next();
              return this.tsParseEnumDeclaration(node, false);
            }
            break;
          case "interface":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseInterfaceDeclaration(node);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(129)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak())
            return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
        if (!this.match(47)) {
          return void 0;
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startPos, startLoc);
          node.typeParameters = this.tsParseTypeParameters();
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) {
          return void 0;
        }
        return this.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) {
          return void 0;
        }
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInNoContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, {
            node
          });
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart())
          return false;
        return super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(allowModifiers, decorators) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let accessibility;
        let readonly = false;
        let override = false;
        if (allowModifiers !== void 0) {
          const modified = {};
          this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
          accessibility = modified.accessibility;
          override = modified.override;
          readonly = modified.readonly;
          if (allowModifiers === false && (accessibility || readonly || override)) {
            this.raise(TSErrors.UnexpectedParameterModifier, {
              at: startLoc
            });
          }
        }
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startPos, startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility)
            pp.accessibility = accessibility;
          if (readonly)
            pp.readonly = readonly;
          if (override)
            pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, {
              node: pp
            });
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          this.finishNode(node, bodilessType);
          return;
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, {
            node
          });
          if (node.declare) {
            super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
            return;
          }
        }
        super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
        } else {
          super.registerFunctionStatementId(...arguments);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, {
              node: node.typeAnnotation
            });
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(...args) {
        const node = super.parseArrayLike(...args);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startPos, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (typeArguments) {
              if (isOptionalCall && !this.match(10)) {
                missingParenErrorLoc = this.state.curPosition();
                this.unexpected();
              }
              if (!noCalls && this.eat(10)) {
                node.arguments = this.parseCallExpressionArguments(11, false);
                this.tsCheckForInvalidTypeCasts(node.arguments);
                node.typeParameters = typeArguments;
                if (state.optionalChainMember) {
                  node.optional = isOptionalCall;
                }
                return this.finishCallExpression(node, state.optionalChainMember);
              } else if (tokenIsTemplate(this.state.type)) {
                const result2 = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                result2.typeParameters = typeArguments;
                return result2;
              }
            }
            this.unexpected();
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result)
            return result;
        }
        return super.parseSubscript(base, startPos, startLoc, noCalls, state);
      }
      parseNewArguments(node) {
        if (this.match(47) || this.match(51)) {
          const typeParameters = this.tsTryParseAndCatch(() => {
            const args = this.tsParseTypeArgumentsInExpression();
            if (!this.match(10))
              this.unexpected();
            return args;
          });
          if (typeParameters) {
            node.typeParameters = typeParameters;
          }
        }
        super.parseNewArguments(node);
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.expression = left;
          const _const = this.tsTryNextParseConstantContext();
          if (_const) {
            node.typeAnnotation = _const;
          } else {
            node.typeAnnotation = this.tsNextThenParseType();
          }
          this.finishNode(node, "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      }
      checkDuplicateExports() {
      }
      parseImport(node) {
        node.importKind = "value";
        if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
          let ahead = this.lookahead();
          if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {
            node.importKind = "type";
            this.next();
            ahead = this.lookahead();
          }
          if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {
            return this.tsParseImportEqualsDeclaration(node);
          }
        }
        const importNode = super.parseImport(node);
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
            node: importNode
          });
        }
        return importNode;
      }
      parseExport(node) {
        if (this.match(83)) {
          this.next();
          if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {
            node.importKind = "type";
            this.next();
          } else {
            node.importKind = "value";
          }
          return this.tsParseImportEqualsDeclaration(node, true);
        } else if (this.eat(29)) {
          const assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node;
          this.expectContextual(124);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          if (this.isContextual(126) && this.lookahead().type === 5) {
            this.next();
            node.exportKind = "type";
          } else {
            node.exportKind = "value";
          }
          return super.parseExport(node);
        }
      }
      isAbstractClass() {
        return this.isContextual(120) && this.lookahead().type === 80;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          this.parseClass(cls, true, true);
          return cls;
        }
        if (this.match(125)) {
          const interfaceNode = this.startNode();
          this.next();
          const result = this.tsParseInterfaceDeclaration(interfaceNode);
          if (result)
            return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseStatementContent(context, topLevel) {
        if (this.state.type === 75) {
          const ahead = this.lookahead();
          if (ahead.type === 122) {
            const node = this.startNode();
            this.next();
            this.expectContextual(122);
            return this.tsParseEnumDeclaration(node, true);
          }
        }
        return super.parseStatementContent(context, topLevel);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(104) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers(member, modifiers, void 0, void 0, true);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                at: this.state.curPosition()
              });
            }
            this.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, {
              node: member
            });
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, {
              node: member
            }, member.accessibility);
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, {
              node: member
            });
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, {
              node: member
            });
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
            node: member
          });
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, {
              node: member
            });
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional)
          methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, {
            node: methodOrProp
          });
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, {
            node: methodOrProp
          });
        }
      }
      parseExpressionStatement(node, expr) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : void 0;
        return decl || super.parseExpressionStatement(node, expr);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart())
          return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startPos, startLoc, refExpressionErrors) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) {
          return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
        }
        const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));
        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }
          return expr;
        }
        if (result.error)
          this.state = result.failState;
        return result.node;
      }
      parseParenItem(node, startPos, startLoc) {
        node = super.parseParenItem(node, startPos, startLoc);
        if (this.eat(17)) {
          node.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(121);
        if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
            at: this.state.startLoc
          });
        }
        let declaration;
        if (tokenIsIdentifier(this.state.type)) {
          declaration = this.tsTryParseExportDeclaration();
        }
        if (!declaration) {
          declaration = super.parseExportDeclaration(node);
        }
        if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
          node.exportKind = "type";
        }
        if (declaration && isDeclare) {
          this.resetStartLocation(declaration, startPos, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement, optionalId) {
        if ((!isStatement || optionalId) && this.isContextual(110)) {
          return;
        }
        super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional && this.eat(35)) {
          node.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, {
            at: this.state.startLoc
          });
        }
        if (node.abstract && this.match(29)) {
          const {
            key
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, {
            at: this.state.startLoc
          }, key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, {
            node
          });
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, {
            node
          }, node.accessibility);
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, {
            node: typeParameters
          });
        }
        if (method.declare && (method.kind === "get" || method.kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, {
            node: method
          }, method.kind);
        }
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod")
          return;
        if (node.type === "MethodDefinition" && !node.value.body)
          return;
        super.declareClassPrivateMethodInScope(node, kind);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual(110)) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, ...args) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          prop.typeParameters = typeParameters;
        super.parseObjPropValue(prop, ...args);
      }
      parseFunctionParams(node, allowModifiers) {
        const typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters)
          node.typeParameters = typeParameters;
        super.parseFunctionParams(node, allowModifiers);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(...args) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(...args), state);
          if (!jsx2.error)
            return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(...args);
        }
        let typeParameters;
        state = state || this.state.clone();
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters();
          const expr = super.parseMaybeAssign(...args);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters)
            this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
          if (!typeCast.error)
            return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters)
            this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        if ((_jsx3 = jsx2) != null && _jsx3.thrown)
          throw jsx2.error;
        if (arrow.thrown)
          throw arrow.error;
        if ((_typeCast2 = typeCast) != null && _typeCast2.thrown)
          throw typeCast.error;
        throw ((_jsx4 = jsx2) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra;
        if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, {
            node
          });
        }
      }
      parseMaybeUnary(refExpressionErrors) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        } else {
          return super.parseMaybeUnary(refExpressionErrors);
        }
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19))
              abort();
            return returnType;
          });
          if (result.aborted)
            return;
          if (!result.thrown) {
            if (result.error)
              this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
            this.raise(TSErrors.PatternIsOptional, {
              node: param
            });
          }
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type)
          param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return super.toAssignable(this.typeCastToParameter(node), isLHS);
          case "TSParameterProperty":
            return super.toAssignable(node, isLHS);
          case "ParenthesizedExpression":
            return this.toAssignableParenthesizedExpression(node, isLHS);
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;
          default:
            return super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;
          default:
            return super.toAssignable(node, isLHS);
        }
      }
      checkLVal(expr, contextDescription, ...args) {
        var _expr$extra2;
        switch (expr.type) {
          case "TSTypeCastExpression":
            return;
          case "TSParameterProperty":
            this.checkLVal(expr.parameter, "parameter property", ...args);
            return;
          case "TSAsExpression":
          case "TSTypeAssertion":
            if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
              this.raise(ErrorMessages.InvalidLhs, {
                node: expr
              }, contextDescription);
              break;
            }
            this.checkLVal(expr.expression, "parenthesized expression", ...args);
            return;
          case "TSNonNullExpression":
            this.checkLVal(expr.expression, contextDescription, ...args);
            return;
          default:
            super.checkLVal(expr, contextDescription, ...args);
            return;
        }
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr);
            call.typeParameters = typeArguments;
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        } else {
          return super.checkCommaAfterRest(close);
        }
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(...args) {
        const node = super.parseMaybeDefault(...args);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, {
            node: node.typeAnnotation
          });
        }
        return node;
      }
      getTokenFromCode(code) {
        if (this.state.inType) {
          if (code === 62) {
            return this.finishOp(48, 1);
          }
          if (code === 60) {
            return this.finishOp(47, 1);
          }
        }
        return super.getTokenFromCode(code);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableList(exprList) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if (!expr)
            continue;
          switch (expr.type) {
            case "TSTypeCastExpression":
              exprList[i] = this.typeCastToParameter(expr);
              break;
            case "TSAsExpression":
            case "TSTypeAssertion":
              if (!this.state.maybeInArrowParameters) {
                exprList[i] = this.typeCastToParameter(expr);
              } else {
                this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  node: expr
                });
              }
              break;
          }
        }
        return super.toAssignableList(...arguments);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments)
            node.typeParameters = typeArguments;
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const oldIsAmbientContext = this.state.isAmbientContext;
        this.state.isAmbientContext = true;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
        }
      }
      parseClass(node, ...args) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, ...args);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node) {
        if (this.match(80)) {
          node.abstract = true;
          return this.parseClass(node, true, false);
        } else if (this.isContextual(125)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
              node
            });
            this.next();
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(...args) {
        const method = super.parseMethod(...args);
        if (method.abstract) {
          const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
          if (hasBody) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, {
              node: method
            }, key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`);
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = this.parseIdentifier();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = this.parseIdentifier();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          leftOfAs = this.parseIdentifier();
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
            at: loc
          });
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkLVal(node[rightOfAsKey], "import specifier", BIND_LEXICAL);
        }
      }
    };
    var PlaceholderErrors = makeErrorTemplates({
      ClassNameIsRequired: "A class name is required."
    }, ErrorCodes.SyntaxError, "placeholders");
    var placeholders = (superClass) => class extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(140)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace("Unexpected space in placeholder.");
          node.name = super.parseIdentifier(true);
          this.assertNoSpace("Unexpected space in placeholder.");
          this.expect(140);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        const isFinished = !!(node.expectedNode && node.type === "Placeholder");
        node.expectedNode = expectedNode;
        return isFinished ? node : this.finishNode(node, "Placeholder");
      }
      getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          return this.finishOp(140, 2);
        }
        return super.getTokenFromCode(...arguments);
      }
      parseExprAtom() {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
      }
      parseIdentifier() {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
      }
      checkReservedWord(word) {
        if (word !== void 0)
          super.checkReservedWord(...arguments);
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
      }
      checkLVal(expr) {
        if (expr.type !== "Placeholder")
          super.checkLVal(...arguments);
      }
      toAssignable(node) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
          return node;
        }
        return super.toAssignable(...arguments);
      }
      isLet(context) {
        if (super.isLet(context)) {
          return true;
        }
        if (!this.isContextual(99)) {
          return false;
        }
        if (context)
          return false;
        const nextToken = this.lookahead();
        if (nextToken.type === 140) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node) {
        if (node.label && node.label.type === "Placeholder")
          return;
        super.verifyBreakContinue(...arguments);
      }
      parseExpressionStatement(node, expr) {
        if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
          return super.parseExpressionStatement(...arguments);
        }
        if (this.match(14)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = this.parseStatement("label");
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        node.name = expr.name;
        return this.finishPlaceholder(node, "Statement");
      }
      parseBlock() {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
      }
      parseFunctionId() {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        this.takeDecorators(node);
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(140) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
              at: this.state.startLoc
            });
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        this.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseExport(...arguments);
        if (!this.isContextual(97) && !this.match(12)) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node) {
        if (node.specifiers && node.specifiers.length > 0) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(...arguments);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder)
          return super.parseImport(...arguments);
        node.specifiers = [];
        if (!this.isContextual(97) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        this.finishNode(specifier, "ImportDefaultSpecifier");
        node.specifiers.push(specifier);
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport)
            this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(97);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
      }
    };
    var v8intrinsic = (superClass) => class extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name = this.parseIdentifierName(this.state.start);
            const identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom() {
        return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
      }
    };
    function hasPlugin(plugins, expectedConfig) {
      const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
      const expectedKeys = Object.keys(expectedOptions);
      const expectedOptionsIsEmpty = expectedKeys.length === 0;
      return plugins.some((p) => {
        if (typeof p === "string") {
          return expectedOptionsIsEmpty && p === expectedName;
        } else {
          const [pluginName, pluginOptions] = p;
          if (pluginName !== expectedName) {
            return false;
          }
          for (const key of expectedKeys) {
            if (pluginOptions[key] !== expectedOptions[key]) {
              return false;
            }
          }
          return true;
        }
      });
    }
    function getPluginOption(plugins, name, option) {
      const plugin = plugins.find((plugin2) => {
        if (Array.isArray(plugin2)) {
          return plugin2[0] === name;
        } else {
          return plugin2 === name;
        }
      });
      if (plugin && Array.isArray(plugin)) {
        return plugin[1][option];
      }
      return null;
    }
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
    function validatePlugins(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport == null) {
          throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
        } else if (typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean.");
        }
      }
      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (hasPlugin(plugins, "pipelineOperator")) {
        const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = hasPlugin(plugins, ["recordAndTuple", {
          syntaxType: "hash"
        }]);
        if (proposal === "hack") {
          if (hasPlugin(plugins, "placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (hasPlugin(plugins, "v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
        }
      }
      if (hasPlugin(plugins, "moduleAttributes")) {
        {
          if (hasPlugin(plugins, "importAssertions")) {
            throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
          }
          const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
          if (moduleAttributesVerionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
        throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
      }
      if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var defaultOptions = {
      sourceType: "script",
      sourceFilename: void 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true
    };
    function getOptions(opts) {
      const options = {};
      for (const key of Object.keys(defaultOptions)) {
        options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
      }
      return options;
    }
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordParenthesizedIdentifierError(ErrorMessages.InvalidParenthesizedAssignment, node.loc.start);
            } else if (parenthesized.type !== "MemberExpression") {
              this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
                node
              });
            }
          } else {
            this.raise(ErrorMessages.InvalidParenthesizedAssignment, {
              node
            });
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(ErrorMessages.RestTrailingComma, {
                  at: node.extra.trailingCommaLoc
                });
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            const arg = node.argument;
            this.toAssignable(arg, isLHS);
            break;
          }
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(ErrorMessages.MissingEqInAssignment, {
                at: node.left.loc.end
              });
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
        return node;
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod, {
            node: prop.key
          });
        } else if (prop.type === "SpreadElement" && !isLast) {
          this.raise(ErrorMessages.RestTrailingComma, {
            node: prop
          });
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        let end = exprList.length;
        if (end) {
          const last = exprList[end - 1];
          if ((last == null ? void 0 : last.type) === "RestElement") {
            --end;
          } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
            last.type = "RestElement";
            let arg = last.argument;
            this.toAssignable(arg, isLHS);
            arg = unwrapParenthesizedExpression(arg);
            if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
              this.unexpected(arg.start);
            }
            if (trailingCommaLoc) {
              this.raise(ErrorMessages.RestTrailingComma, {
                at: trailingCommaLoc
              });
            }
            --end;
          }
        }
        for (let i = 0; i < end; i++) {
          const elt = exprList[i];
          if (elt) {
            this.toAssignable(elt, isLHS);
            if (elt.type === "RestElement") {
              this.raise(ErrorMessages.RestTrailingComma, {
                node: elt
              });
            }
          }
        }
        return exprList;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors, refNeedsArrowPos) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(ErrorMessages.UnsupportedParameterDecorator, {
                at: this.state.startLoc
              });
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
            elts.push(this.parseAssignableListItem(allowModifiers, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const prop = this.startNode();
        const {
          type,
          start: startPos,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(prop);
        } else if (type === 134) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);
        return prop;
      }
      parseAssignableListItem(allowModifiers, decorators) {
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseAssignableListItemTypes(param) {
        return param;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        var _startLoc, _startPos, _left;
        startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
        startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(29))
          return left;
        const node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {
        switch (expr.type) {
          case "Identifier": {
            const {
              name
            } = expr;
            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
              this.raise(bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, {
                node: expr
              }, name);
            }
            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(ErrorMessages.ParamDupe, {
                  node: expr
                });
              } else {
                checkClashes.add(name);
              }
            }
            if (disallowLetBinding && name === "let") {
              this.raise(ErrorMessages.LetInLexicalBinding, {
                node: expr
              });
            }
            if (!(bindingType & BIND_NONE)) {
              this.scope.declareName(name, bindingType, expr.loc.start);
            }
            break;
          }
          case "MemberExpression":
            if (bindingType !== BIND_NONE) {
              this.raise(ErrorMessages.InvalidPropertyBindingPattern, {
                node: expr
              });
            }
            break;
          case "ObjectPattern":
            for (let prop of expr.properties) {
              if (this.isObjectProperty(prop))
                prop = prop.value;
              else if (this.isObjectMethod(prop))
                continue;
              this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
            }
            break;
          case "ArrayPattern":
            for (const elem of expr.elements) {
              if (elem) {
                this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
              }
            }
            break;
          case "AssignmentPattern":
            this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
            break;
          case "ParenthesizedExpression":
            this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
            break;
          default: {
            this.raise(bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, {
              node: expr
            }, contextDescription);
          }
        }
      }
      checkToRestConversion(node) {
        if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
          this.raise(ErrorMessages.InvalidRestAssignmentPattern, {
            node: node.argument
          });
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? ErrorMessages.RestTrailingComma : ErrorMessages.ElementAfterRest, {
          at: this.state.startLoc
        });
        return true;
      }
    };
    var invalidHackPipeBodies = /* @__PURE__ */ new Map([["ArrowFunctionExpression", "arrow function"], ["AssignmentExpression", "assignment"], ["ConditionalExpression", "conditional"], ["YieldExpression", "yield"]]);
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return;
        }
        const key = prop.key;
        const name = key.type === "Identifier" ? key.name : key.value;
        if (name === "__proto__") {
          if (isRecord) {
            this.raise(ErrorMessages.RecordNoProto, {
              node: key
            });
            return;
          }
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(ErrorMessages.DuplicateProto, {
                node: key
              });
            }
          }
          protoRef.used = true;
        }
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(135)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.state.comments;
        expr.errors = this.state.errors;
        if (this.options.tokens) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(12)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$loc;
        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        if (this.isContextual(105)) {
          if (this.prodParam.hasYield) {
            let left2 = this.parseYield();
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startPos, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node = this.startNodeAt(startPos, startLoc);
          const operator = this.state.value;
          node.operator = operator;
          if (this.match(29)) {
            node.left = this.toAssignable(left, true);
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node.left = left;
          }
          this.checkLVal(left, "assignment expression");
          this.next();
          node.right = this.parseMaybeAssign();
          return this.finishNode(node, "AssignmentExpression");
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startPos, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startPos, startLoc, -1);
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(ErrorMessages.PrivateInExpectedIn, {
              node: left
            }, value);
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node = this.startNodeAt(leftStartPos, leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(ErrorMessages.UnexpectedAwaitAfterPipelineBody, {
                  at: this.state.startLoc
                });
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(ErrorMessages.MixingCoalesceWithLogical, {
                at: this.state.startLoc
              });
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "smart":
                return this.withTopicBindingContext(() => {
                  if (this.prodParam.hasYield && this.isContextual(105)) {
                    throw this.raise(ErrorMessages.PipeBodyIsTighter, {
                      at: this.state.startLoc
                    }, this.state.value);
                  }
                  return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        if (invalidHackPipeBodies.has(body.type) && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(ErrorMessages.PipeUnparenthesizedBody, {
            at: startLoc
          }, invalidHackPipeBodies.get(body.type));
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(ErrorMessages.PipeTopicUnused, {
            at: startLoc
          });
        }
        return body;
      }
      checkExponentialAfterUnary(node) {
        if (this.match(57)) {
          this.raise(ErrorMessages.UnexpectedTokenUnaryExponentiation, {
            node: node.argument
          });
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.isAwaitAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startPos, startLoc);
          if (!sawUnary)
            this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(ErrorMessages.StrictDelete, {
                node
              });
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(ErrorMessages.DeletePrivateField, {
                node
              });
            }
          }
          if (!update) {
            if (!sawUnary)
              this.checkExponentialAfterUnary(node);
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousAwait()) {
            this.raiseOverwrite(startLoc, ErrorMessages.AwaitNotInAsyncContext);
            return this.parseAwait(startPos, startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          this.checkLVal(node.argument, "prefix operation");
          return this.finishNode(node, "UpdateExpression");
        }
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false))
          return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.checkLVal(expr, "postfix operation");
          this.next();
          expr = this.finishNode(node2, "UpdateExpression");
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startPos, startLoc);
      }
      parseSubscripts(base, startPos, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startPos, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startPos, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls && this.lookaheadCharCode() === 40) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startPos, startLoc, state, computed, optional);
          } else {
            state.stop = true;
            return base;
          }
        }
      }
      parseMember(base, startPos, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(134)) {
          if (base.type === "Super") {
            this.raise(ErrorMessages.SuperPrivateField, {
              at: startLoc
            });
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node.property = this.parsePrivateName();
        } else {
          node.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startPos, startLoc, noCalls, state) {
        const node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        let node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments(11);
        } else {
          node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
        }
        this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startPos, startLoc, state) {
        const node = this.startNodeAt(startPos, startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(ErrorMessages.OptionalChainingNoTemplate, {
            at: startLoc
          });
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 2) {
            {
              if (!this.hasPlugin("moduleAttributes")) {
                this.expectPlugin("importAssertions");
              }
            }
          }
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(ErrorMessages.ImportCallArity, {
              node
            }, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(ErrorMessages.ImportCallSpreadArgument, {
                  node: arg
                });
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                this.raise(ErrorMessages.ImportCallArgumentTrailingComma, {
                  at: this.state.lastTokStartLoc
                });
              }
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node, call.callee.trailingComments);
        }
        return node;
      }
      parseNoCallExpr() {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaProperty(node);
            }
            if (!this.match(10)) {
              this.raise(ErrorMessages.UnsupportedImport, {
                at: this.state.lastTokStartLoc
              });
            }
            return this.finishNode(node, "Import");
          case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 130:
            return this.parseNumericLiteral(this.state.value);
          case 131:
            return this.parseBigIntLiteral(this.state.value);
          case 132:
            return this.parseDecimalLiteral(this.state.value);
          case 129:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 2:
          case 1: {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 6:
          case 7: {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            this.parseDecorators();
          case 80:
            node = this.startNode();
            this.takeDecorators(node);
            return this.parseClass(node, false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(ErrorMessages.UnsupportedBind, {
                node: callee
              });
            }
          }
          case 134: {
            this.raise(ErrorMessages.PrivateInExpectedIn, {
              at: this.state.startLoc
            }, this.state.value);
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            } else {
              throw this.unexpected();
            }
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
              break;
            } else {
              throw this.unexpected();
            }
          }
          default:
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseFunction(this.startNodeAtNode(id), void 0, true);
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              throw this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          throw this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
          const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(pipeProposal === "smart" ? ErrorMessages.PrimaryTopicNotAllowed : ErrorMessages.PipeTopicUnbound, {
              at: startLoc
            });
          }
          this.registerTopicReference();
          return this.finishNode(node, nodeType);
        } else {
          throw this.raise(ErrorMessages.PipeTopicUnconfiguredToken, {
            at: startLoc
          }, tokenLabelName(tokenType));
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }
          case "smart":
            return tokenType === 27;
          default:
            throw this.raise(ErrorMessages.PipeTopicRequiresHackPipes, {
              at: startLoc
            });
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(ErrorMessages.LineTerminatorBeforeArrow, {
            at: this.state.curPosition()
          });
        }
        this.expect(19);
        this.parseArrowExpression(node, params, true);
        return node;
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(PARAM_AWAIT);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(ErrorMessages.SuperNotAllowed, {
            node
          });
        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(ErrorMessages.UnexpectedSuper, {
            node
          });
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(ErrorMessages.UnsupportedSuper, {
            node
          });
        }
        return this.finishNode(node, "Super");
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(this.state.start + 1, new Position3(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1));
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          if (this.match(102)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(ErrorMessages.UnsupportedMetaProperty, {
            node: node.property
          }, meta.name, propertyName);
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaProperty(node) {
        const id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.next();
        if (this.isContextual(100)) {
          if (!this.inModule) {
            this.raise(SourceTypeModuleErrorMessages.ImportMetaOutsideModule, {
              node: id
            });
          }
          this.sawUnambiguousESM = true;
        }
        return this.parseMetaProperty(node, id, "meta");
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.parseLiteral(value.value, "RegExpLiteral");
        node.pattern = value.pattern;
        node.flags = value.flags;
        return node;
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartPos = this.state.start;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartPos = this.state.start;
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startPos, startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc)
          this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc)
          this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        if (!this.options.createParenthesizedExpressions) {
          this.addExtra(val, "parenthesized", true);
          this.addExtra(val, "parenStart", startPos);
          this.takeSurroundingComments(val, startPos, this.state.lastTokEndLoc.index);
          return val;
        }
        const parenExpression = this.startNodeAt(startPos, startLoc);
        parenExpression.expression = val;
        this.finishNode(parenExpression, "ParenthesizedExpression");
        return parenExpression;
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19)) {
          return node;
        }
      }
      parseParenItem(node, startPos, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
            this.raise(ErrorMessages.UnexpectedNewTarget, {
              node: metaProp
            });
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        node.callee = this.parseNoCallExpr();
        if (node.callee.type === "Import") {
          this.raise(ErrorMessages.ImportCallNotNewExpression, {
            node: node.callee
          });
        } else if (this.isOptionalChain(node.callee)) {
          this.raise(ErrorMessages.OptionalChainingNoNew, {
            at: this.state.lastTokEndLoc
          });
        } else if (this.eat(18)) {
          this.raise(ErrorMessages.OptionalChainingNoNew, {
            at: this.state.startLoc
          });
        }
        this.parseNewArguments(node);
        return this.finishNode(node, "NewExpression");
      }
      parseNewArguments(node) {
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(ErrorMessages.InvalidEscapeSequenceTemplate, {
              at: createPositionWithColumnOffset(startLoc, 2)
            });
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(elem, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return elem;
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        node.expressions = [];
        let curElt = this.parseTemplateElement(isTagged);
        node.quasis = [curElt];
        while (!curElt.tail) {
          node.expressions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          node.quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = /* @__PURE__ */ Object.create(null);
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(node);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            this.checkProto(prop, isRecord, propHash, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(ErrorMessages.InvalidRecordProperty, {
              node: prop
            });
          }
          if (prop.shorthand) {
            this.addExtra(prop, "shorthand", true);
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStart);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(ErrorMessages.UnsupportedPropertyDecorator, {
              at: this.state.startLoc
            });
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startPos;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length)
            this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startPos = this.state.start;
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        const key = this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(ErrorMessages.AccessorIsGenerator, {
                at: this.state.curPosition()
              }, keyName);
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
        return prop;
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? ErrorMessages.BadGetterArity : ErrorMessages.BadSetterArity, {
            node: method
          });
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(ErrorMessages.BadSetterRestParameter, {
            node: method
          });
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(prop);
          return prop;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern)
            this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(ErrorMessages.InvalidCoverInitializedName, {
                at: shorthandAssignLoc
              });
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
        if (!node)
          this.unexpected();
        return node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 130:
                key = this.parseNumericLiteral(value);
                break;
              case 129:
                key = this.parseStringLiteral(value);
                break;
              case 131:
                key = this.parseBigIntLiteral(value);
                break;
              case 132:
                key = this.parseDecimalLiteral(value);
                break;
              case 134: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(ErrorMessages.UnexpectedPrivateField, {
                    at: privateKeyLoc
                  });
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                throw this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 134) {
            prop.computed = false;
          }
        }
        return prop.key;
      }
      initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = !!isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = !!isGenerator;
        const allowModifiers = isConstructor;
        this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, allowModifiers);
        this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return node;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= PARAM_IN;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        node.params = this.toAssignableList(params, trailingCommaLoc, false);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
          node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node.params);
            if (hasStrictModeDirective && nonSimple) {
              const errorOrigin = (node.kind === "method" || node.kind === "constructor") && !!node.key ? {
                at: node.key.loc.end
              } : {
                node
              };
              this.raise(ErrorMessages.IllegalLanguageModeDirective, errorOrigin);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node.id) {
              this.checkLVal(node.id, "function name", BIND_OUTSIDE, void 0, void 0, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (params[i].type !== "Identifier")
            return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = /* @__PURE__ */ new Set();
        for (const param of node.params) {
          this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, void 0, strictModeChanged);
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(ErrorMessages.UnexpectedToken, {
              at: this.state.curPosition()
            }, ",");
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartPos = this.state.start;
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(ErrorMessages.UnexpectedArgumentPlaceholder, {
              at: this.state.startLoc
            });
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(node.start, liberal);
        return this.createIdentifier(node, name);
      }
      createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
      }
      parseIdentifierName(pos, liberal) {
        let name;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name = this.state.value;
        } else {
          throw this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(128);
          }
        } else {
          this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(ErrorMessages.YieldBindingIdentifier, {
              at: startLoc
            });
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(ErrorMessages.AwaitBindingIdentifier, {
              at: startLoc
            });
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(ErrorMessages.AwaitBindingIdentifierInStaticBlock, {
              at: startLoc
            });
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(ErrorMessages.AwaitBindingIdentifier, startLoc);
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(ErrorMessages.ArgumentsInClass, {
              at: startLoc
            });
            return;
          }
        }
        if (checkKeywords && isKeyword(word)) {
          this.raise(ErrorMessages.UnexpectedKeyword, {
            at: startLoc
          }, word);
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(ErrorMessages.UnexpectedReservedWord, {
            at: startLoc
          }, word);
        }
      }
      isAwaitAllowed() {
        if (this.prodParam.hasAwait)
          return true;
        if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
          return true;
        }
        return false;
      }
      parseAwait(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        this.expressionScope.recordParameterInitializerError(node.loc.start, ErrorMessages.AwaitExpressionFormalParameter);
        if (this.eat(55)) {
          this.raise(ErrorMessages.ObsoleteAwaitStar, {
            node
          });
        }
        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
          if (this.isAmbiguousAwait()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak())
          return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 133 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield() {
        const node = this.startNode();
        this.expressionScope.recordParameterInitializerError(node.loc.start, ErrorMessages.YieldInParameter);
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 135:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating)
                break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(ErrorMessages.PipelineHeadSequenceExpression, {
              at: leftStartLoc
            });
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
        const bodyNode = this.startNodeAt(startPos, startLoc);
        if (this.isSimpleReference(childExpr)) {
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(ErrorMessages.PipelineBodyNoArrow, {
            at: this.state.startLoc
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(ErrorMessages.PipelineTopicUnused, {
            at: startLoc
          });
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = PARAM_IN & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | PARAM_IN);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = PARAM_IN & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~PARAM_IN);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        this.eat(5);
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        const program = this.startNode();
        try {
          node.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        this.eat(8);
        return this.finishNode(node, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: "loop"
    };
    var switchLabel = {
      kind: "switch"
    };
    var FUNC_NO_FLAGS = 0;
    var FUNC_STATEMENT = 1;
    var FUNC_HANGING_STATEMENT = 2;
    var FUNC_NULLABLE_ID = 4;
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input) {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {
          type
        } = token;
        if (typeof type === "number") {
          {
            if (type === 134) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const hashEndPos = start + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(128),
                value,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const backquoteEnd = start + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start) === 96) {
                startToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token({
                  type: getExportedToken(8),
                  value: "}",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value === null ? null : value.slice(1, -1);
                endToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value === null ? null : value.slice(1, -2);
                endToken = new Token({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.state.comments;
        if (this.options.tokens) {
          file.tokens = babel7CompatTokens(this.tokens, this.input);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program, end = 135, sourceType = this.options.sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
          for (const [name, loc] of Array.from(this.scope.undefinedExports)) {
            this.raise(ErrorMessages.ModuleExportUndefined, {
              at: loc
            }, name);
          }
        }
        return this.finishNode(program, "Program");
      }
      stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet(context) {
        if (!this.isContextual(99)) {
          return false;
        }
        return this.isLetKeyword(context);
      }
      isLetKeyword(context) {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        if (nextCh === 92 || nextCh === 91) {
          return true;
        }
        if (context)
          return false;
        if (nextCh === 123)
          return true;
        if (isIdentifierStart(nextCh)) {
          keywordRelationalOperator.lastIndex = next;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      parseStatement(context, topLevel) {
        if (this.match(26)) {
          this.parseDecorators(true);
        }
        return this.parseStatementContent(context, topLevel);
      }
      parseStatementContent(context, topLevel) {
        let starttype = this.state.type;
        const node = this.startNode();
        let kind;
        if (this.isLet(context)) {
          starttype = 74;
          kind = "let";
        }
        switch (starttype) {
          case 60:
            return this.parseBreakContinueStatement(node, true);
          case 63:
            return this.parseBreakContinueStatement(node, false);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46)
              break;
            if (context) {
              if (this.state.strict) {
                this.raise(ErrorMessages.StrictFunction, {
                  at: this.state.startLoc
                });
              } else if (context !== "if" && context !== "label") {
                this.raise(ErrorMessages.SloppyFunction, {
                  at: this.state.startLoc
                });
              }
            }
            return this.parseFunctionStatement(node, false, !context);
          case 80:
            if (context)
              this.unexpected();
            return this.parseClass(node, true);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 75:
          case 74:
            kind = kind || this.state.value;
            if (context && kind !== "var") {
              this.raise(ErrorMessages.UnexpectedLexicalDeclaration, {
                at: this.state.startLoc
              });
            }
            return this.parseVarStatement(node, kind);
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(ErrorMessages.UnexpectedImportExport, {
                at: this.state.startLoc
              });
            }
            this.next();
            let result;
            if (starttype === 83) {
              result = this.parseImport(node);
              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);
              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }
            this.assertModuleNodeAllowed(node);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(ErrorMessages.AsyncFunctionInSingleStatementContext, {
                  at: this.state.startLoc
                });
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node, maybeName, expr, context);
        } else {
          return this.parseExpressionStatement(node, expr);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) {
          this.raise(SourceTypeModuleErrorMessages.ImportOutsideModule, {
            node
          });
        }
      }
      takeDecorators(node) {
        const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        if (decorators.length) {
          node.decorators = decorators;
          this.resetStartLocationFromNode(node, decorators[0]);
          this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
        }
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        while (this.match(26)) {
          const decorator = this.parseDecorator();
          currentContextDecorators.push(decorator);
        }
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.raise(ErrorMessages.DecoratorExportClass, {
              at: this.state.startLoc
            });
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(ErrorMessages.UnexpectedLeadingDecorator, {
            at: this.state.startLoc
          });
        }
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators-legacy", "decorators"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          this.state.decoratorStack.push([]);
          const startPos = this.state.start;
          const startLoc = this.state.startLoc;
          let expr;
          if (this.eat(10)) {
            expr = this.parseExpression();
            this.expect(11);
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.object = expr;
              node2.property = this.parseIdentifier(true);
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
          }
          node.expression = this.parseMaybeDecoratorArguments(expr);
          this.state.decoratorStack.pop();
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.eat(10)) {
          const node = this.startNodeAtNode(expr);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(11, false);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop"))
              break;
            if (node.label && isBreak)
              break;
          }
        }
        if (i === this.state.labels.length) {
          this.raise(ErrorMessages.IllegalBreakContinue, {
            node
          }, isBreak ? "break" : "continue");
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do"));
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isAwaitAllowed() && this.eatContextual(96)) {
          awaitAt = this.state.lastTokStartLoc;
        }
        this.scope.enter(SCOPE_OTHER);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(99);
        const isLet = startsWithLet && this.isLetKeyword();
        if (this.match(74) || this.match(75) || isLet) {
          const init2 = this.startNode();
          const kind = isLet ? "let" : this.state.value;
          this.next();
          this.parseVar(init2, true, kind);
          this.finishNode(init2, "VariableDeclaration");
          if ((this.match(58) || this.isContextual(101)) && init2.declarations.length === 1) {
            return this.parseForIn(node, init2, awaitAt);
          }
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init2);
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(101);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(ErrorMessages.ForOfLet, {
              node: init
            });
          }
          if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
            this.raise(ErrorMessages.ForOfAsync, {
              node: init
            });
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init, true);
          const description = isForOf ? "for-of statement" : "for-in statement";
          this.checkLVal(init, description);
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(66) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
          this.raise(ErrorMessages.IllegalReturn, {
            at: this.state.startLoc
          });
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(SCOPE_OTHER);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur)
              this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(ErrorMessages.MultipleDefaultsInSwitch, {
                  at: this.state.lastTokStartLoc
                });
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatement(null));
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur)
          this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(ErrorMessages.NewlineAfterThrow, {
            at: this.state.lastTokEndLoc
          });
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        const simple = param.type === "Identifier";
        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLVal(param, "catch clause", BIND_LEXICAL);
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(SCOPE_OTHER);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(ErrorMessages.NoCatchOrFinally, {
            node
          });
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while"));
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(ErrorMessages.StrictWith, {
            at: this.state.startLoc
          });
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with"));
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, context) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(ErrorMessages.LabelRedeclaration, {
              node: expr
            }, maybeName);
          }
        }
        const kind = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node.start) {
            label.statementStart = this.state.start;
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.state.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(SCOPE_OTHER);
        }
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = this.parseStatement(null, topLevel);
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        if (afterBlockParse) {
          afterBlockParse.call(this, hasStrictModeDirective);
        }
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null)
            this.unexpected(awaitAt);
        } else {
          node.await = awaitAt !== null;
        }
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(ErrorMessages.ForInOfLoopInitializer, {
            node: init
          }, isForIn ? "for-in" : "for-of");
        }
        if (init.type === "AssignmentPattern") {
          this.raise(ErrorMessages.InvalidLhs, {
            node: init
          }, "for-loop");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for"));
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind) {
        const declarations = node.declarations = [];
        const isTypescript = this.hasPlugin("typescript");
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(29)) {
            decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          } else {
            if (kind === "const" && !(this.match(58) || this.isContextual(101))) {
              if (!isTypescript) {
                this.raise(ErrorMessages.DeclarationMissingInitializer, {
                  at: this.state.lastTokEndLoc
                }, "Const declarations");
              }
            } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(101)))) {
              this.raise(ErrorMessages.DeclarationMissingInitializer, {
                at: this.state.lastTokEndLoc
              }, "Complex binding patterns");
            }
            decl.init = null;
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(12))
            break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, void 0, kind !== "var");
      }
      parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
        const isStatement = statement & FUNC_STATEMENT;
        const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
        const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
        this.initFunction(node, isAsync);
        if (this.match(55) && isHangingStatement) {
          this.raise(ErrorMessages.GeneratorInSingleStatementContext, {
            at: this.state.startLoc
          });
        }
        node.generator = this.eat(55);
        if (isStatement) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(SCOPE_FUNCTION);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isStatement) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isStatement && !isHangingStatement) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, allowModifiers) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, false, allowModifiers);
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id)
          return;
        this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        this.takeDecorators(node);
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(ErrorMessages.DecoratorSemicolon, {
                  at: this.state.lastTokEndLoc
                });
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(ErrorMessages.DecoratorConstructor, {
                node: member
              });
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(ErrorMessages.TrailingDecorator, {
            at: this.state.startLoc
          });
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(104);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(134);
          this.parseClassElementName(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(ErrorMessages.ConstructorIsGenerator, {
              node: publicMethod.key
            });
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;
        const isPrivate = this.match(134);
        const key = this.parseClassElementName(member);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(ErrorMessages.DuplicateConstructor, {
                node: key
              });
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(ErrorMessages.OverrideOnConstructor, {
                node: key
              });
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (isContextual && key.name === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(134);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(ErrorMessages.ConstructorIsAsync, {
                node: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if (isContextual && (key.name === "get" || key.name === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = key.name;
          const isPrivate2 = this.match(134);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(ErrorMessages.ConstructorIsAccessor, {
                node: publicMethod.key
              });
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (isContextual && key.name === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key);
          const isPrivate2 = this.match(134);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value
        } = this.state;
        if ((type === 128 || type === 129) && member.static && value === "prototype") {
          this.raise(ErrorMessages.StaticPrototype, {
            at: this.state.startLoc
          });
        }
        if (type === 134) {
          if (value === "constructor") {
            this.raise(ErrorMessages.ConstructorClassPrivateField, {
              at: this.state.startLoc
            });
          }
          const key = this.parsePrivateName();
          member.key = key;
          return key;
        }
        return this.parsePropertyName(member);
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(PARAM);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(ErrorMessages.DecoratorStaticBlock, {
            node: member
          });
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
          this.raise(ErrorMessages.ConstructorClassField, {
            node: prop.key
          });
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed) {
          const key = prop.key;
          if (key.name === "constructor" || key.value === "constructor") {
            this.raise(ErrorMessages.ConstructorClassField, {
              node: key
            });
          }
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(PARAM);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          if (isStatement) {
            this.checkLVal(node.id, "class name", bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            throw this.raise(ErrorMessages.MissingClassName, {
              at: this.state.startLoc
            });
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node) {
        const hasDefault = this.maybeParseExportDefaultSpecifier(node);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault)
            this.unexpected();
          this.parseExportFrom(node, true);
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
          throw this.unexpected(null, 5);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          this.checkExport(node, true, false, !!node.source);
          return this.finishNode(node, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          node.declaration = this.parseExportDefaultExpression();
          this.checkExport(node, true, true);
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        throw this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node) {
        if (this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom");
          const specifier = this.startNode();
          specifier.exported = this.parseIdentifier(true);
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          if (!node.specifiers)
            node.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          if (!node.specifiers)
            node.specifiers = [];
          const isTypeExport = node.exportKind === "type";
          node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node.source = null;
          node.declaration = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          }
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          }
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95))
          return false;
        const next = this.nextTokenStart();
        return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        const isAsync = this.isAsyncFunction();
        if (this.match(68) || isAsync) {
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.raise(ErrorMessages.DecoratorBeforeExport, {
              at: this.state.startLoc
            });
          }
          this.parseDecorators(false);
          return this.parseClass(expr, true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet()) {
          throw this.raise(ErrorMessages.UnsupportedDefaultExport, {
            at: this.state.startLoc
          });
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node) {
        return this.parseStatement(null);
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 99) {
            return false;
          }
          if ((type === 126 || type === 125) && !this.state.containsEsc) {
            const {
              type: nextType
            } = this.lookahead();
            if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual(97)) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          const assertions = this.maybeParseImportAssertions();
          if (assertions) {
            node.assertions = assertions;
          }
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
              throw this.raise(ErrorMessages.DecoratorBeforeExport, {
                at: this.state.startLoc
              });
            }
            return true;
          }
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(ErrorMessages.ExportDefaultFromAsIdentifier, {
                  node: declaration
                });
              }
            }
          } else if (node.specifiers && node.specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportedName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(ErrorMessages.ExportBindingIsString, {
                    node: specifier
                  }, local.value, exportedName);
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
              const id = node.declaration.id;
              if (!id)
                throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (node.declaration.type === "VariableDeclaration") {
              for (const declaration of node.declaration.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
        const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
        if (currentContextDecorators.length) {
          throw this.raise(ErrorMessages.UnsupportedDecoratorExport, {
            node
          });
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, name) {
        if (this.exportedIdentifiers.has(name)) {
          this.raise(name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, {
            node
          }, name);
        }
        this.exportedIdentifiers.add(name);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.eat(8))
              break;
          }
          const isMaybeTypeOnly = this.isContextual(126);
          const isString = this.match(129);
          const node = this.startNode();
          node.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node.exported = this.parseModuleExportName();
        } else if (isString) {
          node.exported = cloneStringLiteral(node.local);
        } else if (!node.exported) {
          node.exported = cloneIdentifier(node.local);
        }
        return this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(129)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = result.value.match(loneSurrogate);
          if (surrogate) {
            this.raise(ErrorMessages.ModuleExportNameHasLoneSurrogate, {
              node: result
            }, surrogate[0].charCodeAt(0).toString(16));
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      parseImport(node) {
        node.specifiers = [];
        if (!this.match(129)) {
          const hasDefault = this.maybeParseDefaultImportSpecifier(node);
          const parseNext = !hasDefault || this.eat(12);
          const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
          if (parseNext && !hasStar)
            this.parseNamedImportSpecifiers(node);
          this.expectContextual(97);
        }
        node.source = this.parseImportSource();
        const assertions = this.maybeParseImportAssertions();
        if (assertions) {
          node.assertions = assertions;
        } else {
          const attributes = this.maybeParseModuleAttributes();
          if (attributes) {
            node.attributes = attributes;
          }
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(129))
          this.unexpected();
        return this.parseExprAtom();
      }
      shouldParseDefaultImport(node) {
        return tokenIsIdentifier(this.state.type);
      }
      parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = this.parseIdentifier();
        this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, type));
      }
      parseAssertEntries() {
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys, {
              at: this.state.startLoc
            }, keyName);
          }
          attrNames.add(keyName);
          if (this.match(129)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(129)) {
            throw this.raise(ErrorMessages.ModuleAttributeInvalidValue, {
              at: this.state.startLoc
            });
          }
          node.value = this.parseStringLiteral(this.state.value);
          this.finishNode(node, "ImportAttribute");
          attrs.push(node);
        } while (this.eat(12));
        return attrs;
      }
      maybeParseModuleAttributes() {
        if (this.match(76) && !this.hasPrecedingLineBreak()) {
          this.expectPlugin("moduleAttributes");
          this.next();
        } else {
          if (this.hasPlugin("moduleAttributes"))
            return [];
          return null;
        }
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(ErrorMessages.ModuleAttributeDifferentFromType, {
              node: node.key
            }, node.key.name);
          }
          if (attributes.has(node.key.name)) {
            this.raise(ErrorMessages.ModuleAttributesWithDuplicateKeys, {
              node: node.key
            }, node.key.name);
          }
          attributes.add(node.key.name);
          this.expect(14);
          if (!this.match(129)) {
            throw this.raise(ErrorMessages.ModuleAttributeInvalidValue, {
              at: this.state.startLoc
            });
          }
          node.value = this.parseStringLiteral(this.state.value);
          this.finishNode(node, "ImportAttribute");
          attrs.push(node);
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAssertions() {
        if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          this.expectPlugin("importAssertions");
          this.next();
        } else {
          if (this.hasPlugin("importAssertions"))
            return [];
          return null;
        }
        this.eat(5);
        const attrs = this.parseAssertEntries();
        this.eat(8);
        return attrs;
      }
      maybeParseDefaultImportSpecifier(node) {
        if (this.shouldParseDefaultImport(node)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(ErrorMessages.DestructureNamedImport, {
                at: this.state.startLoc
              });
            }
            this.expect(12);
            if (this.eat(8))
              break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(129);
          const isMaybeTypeOnly = this.isContextual(126);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly);
          node.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(ErrorMessages.ImportBindingIsString, {
              node: specifier
            }, imported.value);
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = cloneIdentifier(imported);
          }
        }
        this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
        return this.finishNode(specifier, "ImportSpecifier");
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap(this.options.plugins);
        this.filename = options.sourceFilename;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        return file;
      }
    };
    function pluginsMap(plugins) {
      const pluginMap = /* @__PURE__ */ new Map();
      for (const plugin of plugins) {
        const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
        if (!pluginMap.has(name))
          pluginMap.set(name, options || {});
      }
      return pluginMap;
    }
    function parse2(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes2 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes2;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser;
      if (options != null && options.plugins) {
        validatePlugins(options.plugins);
        cls = getParserClass(options.plugins);
      }
      return new cls(options, input);
    }
    var parserClassCache = {};
    function getParserClass(pluginsFromOptions) {
      const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
      const key = pluginList.join("/");
      let cls = parserClassCache[key];
      if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache[key] = cls;
      }
      return cls;
    }
    exports2.parse = parse2;
    exports2.parseExpression = parseExpression;
    exports2.tokTypes = tokTypes;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js"(exports2) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js"(exports2) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`);
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports2.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js"(exports2) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports2.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    var util = require_util();
    var binarySearch2 = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch2.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch2.search(needle, this._sections, function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      });
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports2.SourceNode = SourceNode;
  }
});

// ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// ../../node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/dist/esm/estree-walker.js
var estree_walker_exports = {};
__export(estree_walker_exports, {
  asyncWalk: () => asyncWalk,
  walk: () => walk
});
function walk(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast, null);
}
async function asyncWalk(ast, { enter, leave }) {
  const instance = new AsyncWalker(enter, leave);
  return await instance.visit(ast, null);
}
var WalkerBase, SyncWalker, AsyncWalker;
var init_estree_walker = __esm({
  "../../node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/dist/esm/estree-walker.js"() {
    WalkerBase = class {
      constructor() {
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.context = {
          skip: () => this.should_skip = true,
          remove: () => this.should_remove = true,
          replace: (node) => this.replacement = node
        };
      }
      replace(parent, prop, index, node) {
        if (parent) {
          if (index !== null) {
            parent[prop][index] = node;
          } else {
            parent[prop] = node;
          }
        }
      }
      remove(parent, prop, index) {
        if (parent) {
          if (index !== null) {
            parent[prop].splice(index, 1);
          } else {
            delete parent[prop];
          }
        }
      }
    };
    SyncWalker = class extends WalkerBase {
      constructor(enter, leave) {
        super();
        this.enter = enter;
        this.leave = leave;
      }
      visit(node, parent, prop, index) {
        if (node) {
          if (this.enter) {
            const _should_skip = this.should_skip;
            const _should_remove = this.should_remove;
            const _replacement = this.replacement;
            this.should_skip = false;
            this.should_remove = false;
            this.replacement = null;
            this.enter.call(this.context, node, parent, prop, index);
            if (this.replacement) {
              node = this.replacement;
              this.replace(parent, prop, index, node);
            }
            if (this.should_remove) {
              this.remove(parent, prop, index);
            }
            const skipped = this.should_skip;
            const removed = this.should_remove;
            this.should_skip = _should_skip;
            this.should_remove = _should_remove;
            this.replacement = _replacement;
            if (skipped)
              return node;
            if (removed)
              return null;
          }
          for (const key in node) {
            const value = node[key];
            if (typeof value !== "object") {
              continue;
            } else if (Array.isArray(value)) {
              for (let i = 0; i < value.length; i += 1) {
                if (value[i] !== null && typeof value[i].type === "string") {
                  if (!this.visit(value[i], node, key, i)) {
                    i--;
                  }
                }
              }
            } else if (value !== null && typeof value.type === "string") {
              this.visit(value, node, key, null);
            }
          }
          if (this.leave) {
            const _replacement = this.replacement;
            const _should_remove = this.should_remove;
            this.replacement = null;
            this.should_remove = false;
            this.leave.call(this.context, node, parent, prop, index);
            if (this.replacement) {
              node = this.replacement;
              this.replace(parent, prop, index, node);
            }
            if (this.should_remove) {
              this.remove(parent, prop, index);
            }
            const removed = this.should_remove;
            this.replacement = _replacement;
            this.should_remove = _should_remove;
            if (removed)
              return null;
          }
        }
        return node;
      }
    };
    AsyncWalker = class extends WalkerBase {
      constructor(enter, leave) {
        super();
        this.enter = enter;
        this.leave = leave;
      }
      async visit(node, parent, prop, index) {
        if (node) {
          if (this.enter) {
            const _should_skip = this.should_skip;
            const _should_remove = this.should_remove;
            const _replacement = this.replacement;
            this.should_skip = false;
            this.should_remove = false;
            this.replacement = null;
            await this.enter.call(this.context, node, parent, prop, index);
            if (this.replacement) {
              node = this.replacement;
              this.replace(parent, prop, index, node);
            }
            if (this.should_remove) {
              this.remove(parent, prop, index);
            }
            const skipped = this.should_skip;
            const removed = this.should_remove;
            this.should_skip = _should_skip;
            this.should_remove = _should_remove;
            this.replacement = _replacement;
            if (skipped)
              return node;
            if (removed)
              return null;
          }
          for (const key in node) {
            const value = node[key];
            if (typeof value !== "object") {
              continue;
            } else if (Array.isArray(value)) {
              for (let i = 0; i < value.length; i += 1) {
                if (value[i] !== null && typeof value[i].type === "string") {
                  if (!await this.visit(value[i], node, key, i)) {
                    i--;
                  }
                }
              }
            } else if (value !== null && typeof value.type === "string") {
              await this.visit(value, node, key, null);
            }
          }
          if (this.leave) {
            const _replacement = this.replacement;
            const _should_remove = this.should_remove;
            this.replacement = null;
            this.should_remove = false;
            await this.leave.call(this.context, node, parent, prop, index);
            if (this.replacement) {
              node = this.replacement;
              this.replace(parent, prop, index, node);
            }
            if (this.should_remove) {
              this.remove(parent, prop, index);
            }
            const removed = this.should_remove;
            this.replacement = _replacement;
            this.should_remove = _should_remove;
            if (removed)
              return null;
          }
        }
        return node;
      }
    };
  }
});

// ../../node_modules/.pnpm/@vue+compiler-core@3.2.31/node_modules/@vue/compiler-core/dist/compiler-core.cjs.prod.js
var require_compiler_core_cjs_prod = __commonJS({
  "../../node_modules/.pnpm/@vue+compiler-core@3.2.31/node_modules/@vue/compiler-core/dist/compiler-core.cjs.prod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var shared = require_shared();
    var parser = require_lib();
    var sourceMap = require_source_map();
    var estreeWalker = (init_estree_walker(), __toCommonJS(estree_walker_exports));
    function defaultOnError(error) {
      throw error;
    }
    function defaultOnWarn(msg) {
    }
    function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = (messages || errorMessages)[code] + (additionalMessage || ``);
      const error = new SyntaxError(String(msg));
      error.code = code;
      error.loc = loc;
      return error;
    }
    var errorMessages = {
      [0]: "Illegal comment.",
      [1]: "CDATA section is allowed only in XML context.",
      [2]: "Duplicate attribute.",
      [3]: "End tag cannot have attributes.",
      [4]: "Illegal '/' in tags.",
      [5]: "Unexpected EOF in tag.",
      [6]: "Unexpected EOF in CDATA section.",
      [7]: "Unexpected EOF in comment.",
      [8]: "Unexpected EOF in script.",
      [9]: "Unexpected EOF in tag.",
      [10]: "Incorrectly closed comment.",
      [11]: "Incorrectly opened comment.",
      [12]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13]: "Attribute value was expected.",
      [14]: "End tag name was expected.",
      [15]: "Whitespace was expected.",
      [16]: "Unexpected '<!--' in comment.",
      [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
      [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
      [19]: "Attribute name cannot start with '='.",
      [21]: "'<?' is allowed only in XML context.",
      [20]: `Unexpected null character.`,
      [22]: "Illegal '/' in tags.",
      [23]: "Invalid end tag.",
      [24]: "Element is missing end tag.",
      [25]: "Interpolation end sign was not found.",
      [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
      [26]: "Legal directive name was expected.",
      [28]: `v-if/v-else-if is missing expression.`,
      [29]: `v-if/else branches must use unique keys.`,
      [30]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,
      [31]: `v-for is missing expression.`,
      [32]: `v-for has invalid expression.`,
      [33]: `<template v-for> key should be placed on the <template> tag.`,
      [34]: `v-bind is missing expression.`,
      [35]: `v-on is missing expression.`,
      [36]: `Unexpected custom directive on <slot> outlet.`,
      [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
      [38]: `Duplicate slot names found. `,
      [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
      [40]: `v-slot can only be used on components or <template> tags.`,
      [41]: `v-model is missing expression.`,
      [42]: `v-model value must be a valid JavaScript member expression.`,
      [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [44]: `Error parsing JavaScript expression: `,
      [45]: `<KeepAlive> expects exactly one child component.`,
      [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [47]: `ES module mode is not supported in this build of compiler.`,
      [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [49]: `"scopeId" option is only supported in module mode.`,
      [50]: ``
    };
    var FRAGMENT = Symbol(``);
    var TELEPORT = Symbol(``);
    var SUSPENSE = Symbol(``);
    var KEEP_ALIVE = Symbol(``);
    var BASE_TRANSITION = Symbol(``);
    var OPEN_BLOCK = Symbol(``);
    var CREATE_BLOCK = Symbol(``);
    var CREATE_ELEMENT_BLOCK = Symbol(``);
    var CREATE_VNODE = Symbol(``);
    var CREATE_ELEMENT_VNODE = Symbol(``);
    var CREATE_COMMENT = Symbol(``);
    var CREATE_TEXT = Symbol(``);
    var CREATE_STATIC = Symbol(``);
    var RESOLVE_COMPONENT = Symbol(``);
    var RESOLVE_DYNAMIC_COMPONENT = Symbol(``);
    var RESOLVE_DIRECTIVE = Symbol(``);
    var RESOLVE_FILTER = Symbol(``);
    var WITH_DIRECTIVES = Symbol(``);
    var RENDER_LIST = Symbol(``);
    var RENDER_SLOT = Symbol(``);
    var CREATE_SLOTS = Symbol(``);
    var TO_DISPLAY_STRING = Symbol(``);
    var MERGE_PROPS = Symbol(``);
    var NORMALIZE_CLASS = Symbol(``);
    var NORMALIZE_STYLE = Symbol(``);
    var NORMALIZE_PROPS = Symbol(``);
    var GUARD_REACTIVE_PROPS = Symbol(``);
    var TO_HANDLERS = Symbol(``);
    var CAMELIZE = Symbol(``);
    var CAPITALIZE = Symbol(``);
    var TO_HANDLER_KEY = Symbol(``);
    var SET_BLOCK_TRACKING = Symbol(``);
    var PUSH_SCOPE_ID = Symbol(``);
    var POP_SCOPE_ID = Symbol(``);
    var WITH_CTX = Symbol(``);
    var UNREF = Symbol(``);
    var IS_REF = Symbol(``);
    var WITH_MEMO = Symbol(``);
    var IS_MEMO_SAME = Symbol(``);
    var helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_ELEMENT_VNODE]: `createElementVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [NORMALIZE_CLASS]: `normalizeClass`,
      [NORMALIZE_STYLE]: `normalizeStyle`,
      [NORMALIZE_PROPS]: `normalizeProps`,
      [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`,
      [WITH_MEMO]: `withMemo`,
      [IS_MEMO_SAME]: `isMemoSame`
    };
    function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach((s) => {
        helperNameMap[s] = helpers[s];
      });
    }
    var locStub = {
      source: "",
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
    };
    function createRoot(children, loc = locStub) {
      return {
        type: 0,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: void 0,
        loc
      };
    }
    function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
      if (context) {
        if (isBlock) {
          context.helper(OPEN_BLOCK);
          context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
        } else {
          context.helper(getVNodeHelper(context.inSSR, isComponent2));
        }
        if (directives) {
          context.helper(WITH_DIRECTIVES);
        }
      }
      return {
        type: 13,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        disableTracking,
        isComponent: isComponent2,
        loc
      };
    }
    function createArrayExpression(elements, loc = locStub) {
      return {
        type: 17,
        loc,
        elements
      };
    }
    function createObjectExpression(properties, loc = locStub) {
      return {
        type: 15,
        loc,
        properties
      };
    }
    function createObjectProperty(key, value) {
      return {
        type: 16,
        loc: locStub,
        key: shared.isString(key) ? createSimpleExpression(key, true) : key,
        value
      };
    }
    function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
      return {
        type: 4,
        loc,
        content,
        isStatic,
        constType: isStatic ? 3 : constType
      };
    }
    function createInterpolation(content, loc) {
      return {
        type: 5,
        loc,
        content: shared.isString(content) ? createSimpleExpression(content, false, loc) : content
      };
    }
    function createCompoundExpression(children, loc = locStub) {
      return {
        type: 8,
        loc,
        children
      };
    }
    function createCallExpression(callee, args = [], loc = locStub) {
      return {
        type: 14,
        loc,
        callee,
        arguments: args
      };
    }
    function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
      return {
        type: 18,
        params,
        returns,
        newline,
        isSlot,
        loc
      };
    }
    function createConditionalExpression(test, consequent, alternate, newline = true) {
      return {
        type: 19,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
      };
    }
    function createCacheExpression(index, value, isVNode = false) {
      return {
        type: 20,
        index,
        value,
        isVNode,
        loc: locStub
      };
    }
    function createBlockStatement(body) {
      return {
        type: 21,
        body,
        loc: locStub
      };
    }
    function createTemplateLiteral(elements) {
      return {
        type: 22,
        elements,
        loc: locStub
      };
    }
    function createIfStatement(test, consequent, alternate) {
      return {
        type: 23,
        test,
        consequent,
        alternate,
        loc: locStub
      };
    }
    function createAssignmentExpression(left, right) {
      return {
        type: 24,
        left,
        right,
        loc: locStub
      };
    }
    function createSequenceExpression(expressions) {
      return {
        type: 25,
        expressions,
        loc: locStub
      };
    }
    function createReturnStatement(returns) {
      return {
        type: 26,
        returns,
        loc: locStub
      };
    }
    var isStaticExp = (p) => p.type === 4 && p.isStatic;
    var isBuiltInType = (tag, expected) => tag === expected || tag === shared.hyphenate(expected);
    function isCoreComponent(tag) {
      if (isBuiltInType(tag, "Teleport")) {
        return TELEPORT;
      } else if (isBuiltInType(tag, "Suspense")) {
        return SUSPENSE;
      } else if (isBuiltInType(tag, "KeepAlive")) {
        return KEEP_ALIVE;
      } else if (isBuiltInType(tag, "BaseTransition")) {
        return BASE_TRANSITION;
      }
    }
    var nonIdentifierRE = /^\d|[^\$\w]/;
    var isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
    var validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
    var validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
    var whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
    var isMemberExpressionBrowser = (path) => {
      path = path.trim().replace(whitespaceRE, (s) => s.trim());
      let state = 0;
      let stateStack = [];
      let currentOpenBracketCount = 0;
      let currentOpenParensCount = 0;
      let currentStringType = null;
      for (let i = 0; i < path.length; i++) {
        const char = path.charAt(i);
        switch (state) {
          case 0:
            if (char === "[") {
              stateStack.push(state);
              state = 1;
              currentOpenBracketCount++;
            } else if (char === "(") {
              stateStack.push(state);
              state = 2;
              currentOpenParensCount++;
            } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
              return false;
            }
            break;
          case 1:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `[`) {
              currentOpenBracketCount++;
            } else if (char === `]`) {
              if (!--currentOpenBracketCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 2:
            if (char === `'` || char === `"` || char === "`") {
              stateStack.push(state);
              state = 3;
              currentStringType = char;
            } else if (char === `(`) {
              currentOpenParensCount++;
            } else if (char === `)`) {
              if (i === path.length - 1) {
                return false;
              }
              if (!--currentOpenParensCount) {
                state = stateStack.pop();
              }
            }
            break;
          case 3:
            if (char === currentStringType) {
              state = stateStack.pop();
              currentStringType = null;
            }
            break;
        }
      }
      return !currentOpenBracketCount && !currentOpenParensCount;
    };
    var isMemberExpressionNode = (path, context) => {
      try {
        let ret = parser.parseExpression(path, {
          plugins: context.expressionPlugins
        });
        if (ret.type === "TSAsExpression" || ret.type === "TSTypeAssertion") {
          ret = ret.expression;
        }
        return ret.type === "MemberExpression" || ret.type === "OptionalMemberExpression" || ret.type === "Identifier";
      } catch (e) {
        return false;
      }
    };
    var isMemberExpression = isMemberExpressionNode;
    function getInnerRange(loc, offset, length) {
      const source = loc.source.slice(offset, offset + length);
      const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
      };
      if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
      }
      return newLoc;
    }
    function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
      return advancePositionWithMutation(shared.extend({}, pos), source, numberOfCharacters);
    }
    function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10) {
          linesCount++;
          lastNewLinePos = i;
        }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
      return pos;
    }
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
      }
    }
    function findDir(node, name, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 && (allowEmpty || p.exp) && (shared.isString(name) ? p.name === name : name.test(p.name))) {
          return p;
        }
      }
    }
    function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          if (dynamicOnly)
            continue;
          if (p.name === name && (p.value || allowEmpty)) {
            return p;
          }
        } else if (p.name === "bind" && (p.exp || allowEmpty) && isStaticArgOf(p.arg, name)) {
          return p;
        }
      }
    }
    function isStaticArgOf(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
    }
    function hasDynamicKeyVBind(node) {
      return node.props.some((p) => p.type === 7 && p.name === "bind" && (!p.arg || p.arg.type !== 4 || !p.arg.isStatic));
    }
    function isText(node) {
      return node.type === 5 || node.type === 2;
    }
    function isVSlot(p) {
      return p.type === 7 && p.name === "slot";
    }
    function isTemplateNode(node) {
      return node.type === 1 && node.tagType === 3;
    }
    function isSlotOutlet(node) {
      return node.type === 1 && node.tagType === 2;
    }
    function getVNodeHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
    }
    function getVNodeBlockHelper(ssr, isComponent2) {
      return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
    }
    var propsHelperSet = /* @__PURE__ */ new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
    function getUnnormalizedProps(props, callPath = []) {
      if (props && !shared.isString(props) && props.type === 14) {
        const callee = props.callee;
        if (!shared.isString(callee) && propsHelperSet.has(callee)) {
          return getUnnormalizedProps(props.arguments[0], callPath.concat(props));
        }
      }
      return [props, callPath];
    }
    function injectProp(node, prop, context) {
      let propsWithInjection;
      let props = node.type === 13 ? node.props : node.arguments[2];
      let callPath = [];
      let parentCall;
      if (props && !shared.isString(props) && props.type === 14) {
        const ret = getUnnormalizedProps(props);
        props = ret[0];
        callPath = ret[1];
        parentCall = callPath[callPath.length - 1];
      }
      if (props == null || shared.isString(props)) {
        propsWithInjection = createObjectExpression([prop]);
      } else if (props.type === 14) {
        const first = props.arguments[0];
        if (!shared.isString(first) && first.type === 15) {
          first.properties.unshift(prop);
        } else {
          if (props.callee === TO_HANDLERS) {
            propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
              createObjectExpression([prop]),
              props
            ]);
          } else {
            props.arguments.unshift(createObjectExpression([prop]));
          }
        }
        !propsWithInjection && (propsWithInjection = props);
      } else if (props.type === 15) {
        let alreadyExists = false;
        if (prop.key.type === 4) {
          const propKeyName = prop.key.content;
          alreadyExists = props.properties.some((p) => p.key.type === 4 && p.key.content === propKeyName);
        }
        if (!alreadyExists) {
          props.properties.unshift(prop);
        }
        propsWithInjection = props;
      } else {
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
          createObjectExpression([prop]),
          props
        ]);
        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
          parentCall = callPath[callPath.length - 2];
        }
      }
      if (node.type === 13) {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node.props = propsWithInjection;
        }
      } else {
        if (parentCall) {
          parentCall.arguments[0] = propsWithInjection;
        } else {
          node.arguments[2] = propsWithInjection;
        }
      }
    }
    function toValidAssetId(name, type) {
      return `_${type}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
        return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
      })}`;
    }
    function hasScopeRef(node, ids) {
      if (!node || Object.keys(ids).length === 0) {
        return false;
      }
      switch (node.type) {
        case 1:
          for (let i = 0; i < node.props.length; i++) {
            const p = node.props[i];
            if (p.type === 7 && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
              return true;
            }
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 11:
          if (hasScopeRef(node.source, ids)) {
            return true;
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 9:
          return node.branches.some((b) => hasScopeRef(b, ids));
        case 10:
          if (hasScopeRef(node.condition, ids)) {
            return true;
          }
          return node.children.some((c) => hasScopeRef(c, ids));
        case 4:
          return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];
        case 8:
          return node.children.some((c) => shared.isObject(c) && hasScopeRef(c, ids));
        case 5:
        case 12:
          return hasScopeRef(node.content, ids);
        case 2:
        case 3:
          return false;
        default:
          return false;
      }
    }
    function getMemoedVNodeCall(node) {
      if (node.type === 14 && node.callee === WITH_MEMO) {
        return node.arguments[1].returns;
      } else {
        return node;
      }
    }
    function makeBlock(node, { helper, removeHelper, inSSR }) {
      if (!node.isBlock) {
        node.isBlock = true;
        removeHelper(getVNodeHelper(inSSR, node.isComponent));
        helper(OPEN_BLOCK);
        helper(getVNodeBlockHelper(inSSR, node.isComponent));
      }
    }
    var deprecationData = {
      ["COMPILER_IS_ON_ELEMENT"]: {
        message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC"]: {
        message: (key) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key}.sync\` should be changed to \`v-model:${key}\`.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
      },
      ["COMPILER_V_BIND_PROP"]: {
        message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER"]: {
        message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE"]: {
        message: `.native modifier for v-on has been removed as is no longer necessary.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
        message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`
      },
      ["COMPILER_NATIVE_TEMPLATE"]: {
        message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE"]: {
        message: `"inline-template" has been removed in Vue 3.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`
      },
      ["COMPILER_FILTER"]: {
        message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
      }
    };
    function getCompatValue(key, context) {
      const config = context.options ? context.options.compatConfig : context.compatConfig;
      const value = config && config[key];
      if (key === "MODE") {
        return value || 3;
      } else {
        return value;
      }
    }
    function isCompatEnabled(key, context) {
      const mode = getCompatValue("MODE", context);
      const value = getCompatValue(key, context);
      return mode === 3 ? value === true : value !== false;
    }
    function checkCompatEnabled(key, context, loc, ...args) {
      const enabled = isCompatEnabled(key, context);
      return enabled;
    }
    function warnDeprecation(key, context, loc, ...args) {
      const val = getCompatValue(key, context);
      if (val === "suppress-warning") {
        return;
      }
      const { message, link } = deprecationData[key];
      const msg = `(deprecation ${key}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
      const err = new SyntaxError(msg);
      err.code = key;
      if (loc)
        err.loc = loc;
      context.onWarn(err);
    }
    var decodeRE = /&(gt|lt|amp|apos|quot);/g;
    var decodeMap = {
      gt: ">",
      lt: "<",
      amp: "&",
      apos: "'",
      quot: '"'
    };
    var defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0,
      getTextMode: () => 0,
      isVoidTag: shared.NO,
      isPreTag: shared.NO,
      isCustomElement: shared.NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: false
    };
    function baseParse(content, options = {}) {
      const context = createParserContext(content, options);
      const start = getCursor(context);
      return createRoot(parseChildren(context, 0, []), getSelection(context, start));
    }
    function createParserContext(content, rawOptions) {
      const options = shared.extend({}, defaultParserOptions);
      let key;
      for (key in rawOptions) {
        options[key] = rawOptions[key] === void 0 ? defaultParserOptions[key] : rawOptions[key];
      }
      return {
        options,
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false,
        onWarn: options.onWarn
      };
    }
    function parseChildren(context, mode, ancestors) {
      const parent = last(ancestors);
      const ns = parent ? parent.ns : 0;
      const nodes = [];
      while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = void 0;
        if (mode === 0 || mode === 1) {
          if (!context.inVPre && startsWith2(s, context.options.delimiters[0])) {
            node = parseInterpolation(context, mode);
          } else if (mode === 0 && s[0] === "<") {
            if (s.length === 1) {
              emitError(context, 5, 1);
            } else if (s[1] === "!") {
              if (startsWith2(s, "<!--")) {
                node = parseComment(context);
              } else if (startsWith2(s, "<!DOCTYPE")) {
                node = parseBogusComment(context);
              } else if (startsWith2(s, "<![CDATA[")) {
                if (ns !== 0) {
                  node = parseCDATA(context, ancestors);
                } else {
                  emitError(context, 1);
                  node = parseBogusComment(context);
                }
              } else {
                emitError(context, 11);
                node = parseBogusComment(context);
              }
            } else if (s[1] === "/") {
              if (s.length === 2) {
                emitError(context, 5, 2);
              } else if (s[2] === ">") {
                emitError(context, 14, 2);
                advanceBy(context, 3);
                continue;
              } else if (/[a-z]/i.test(s[2])) {
                emitError(context, 23);
                parseTag(context, 1, parent);
                continue;
              } else {
                emitError(context, 12, 2);
                node = parseBogusComment(context);
              }
            } else if (/[a-z]/i.test(s[1])) {
              node = parseElement(context, ancestors);
              if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
                node = node.children;
              }
            } else if (s[1] === "?") {
              emitError(context, 21, 1);
              node = parseBogusComment(context);
            } else {
              emitError(context, 12, 1);
            }
          }
        }
        if (!node) {
          node = parseText(context, mode);
        }
        if (shared.isArray(node)) {
          for (let i = 0; i < node.length; i++) {
            pushNode(nodes, node[i]);
          }
        } else {
          pushNode(nodes, node);
        }
      }
      let removedWhitespace = false;
      if (mode !== 2 && mode !== 1) {
        const shouldCondense = context.options.whitespace !== "preserve";
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!context.inPre && node.type === 2) {
            if (!/[^\t\r\n\f ]/.test(node.content)) {
              const prev = nodes[i - 1];
              const next = nodes[i + 1];
              if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
                removedWhitespace = true;
                nodes[i] = null;
              } else {
                node.content = " ";
              }
            } else if (shouldCondense) {
              node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
            }
          } else if (node.type === 3 && !context.options.comments) {
            removedWhitespace = true;
            nodes[i] = null;
          }
        }
        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
          const first = nodes[0];
          if (first && first.type === 2) {
            first.content = first.content.replace(/^\r?\n/, "");
          }
        }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
    }
    function pushNode(nodes, node) {
      if (node.type === 2) {
        const prev = last(nodes);
        if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
          prev.content += node.content;
          prev.loc.end = node.loc.end;
          prev.loc.source += node.loc.source;
          return;
        }
      }
      nodes.push(node);
    }
    function parseCDATA(context, ancestors) {
      advanceBy(context, 9);
      const nodes = parseChildren(context, 3, ancestors);
      if (context.source.length === 0) {
        emitError(context, 6);
      } else {
        advanceBy(context, 3);
      }
      return nodes;
    }
    function parseComment(context) {
      const start = getCursor(context);
      let content;
      const match = /--(\!)?>/.exec(context.source);
      if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7);
      } else {
        if (match.index <= 3) {
          emitError(context, 0);
        }
        if (match[1]) {
          emitError(context, 10);
        }
        content = context.source.slice(4, match.index);
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf("<!--", prevIndex)) !== -1) {
          advanceBy(context, nestedIndex - prevIndex + 1);
          if (nestedIndex + 4 < s.length) {
            emitError(context, 16);
          }
          prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
      }
      return {
        type: 3,
        content,
        loc: getSelection(context, start)
      };
    }
    function parseBogusComment(context) {
      const start = getCursor(context);
      const contentStart = context.source[1] === "?" ? 1 : 2;
      let content;
      const closeIndex = context.source.indexOf(">");
      if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
      } else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
      }
      return {
        type: 3,
        content,
        loc: getSelection(context, start)
      };
    }
    function parseElement(context, ancestors) {
      const wasInPre = context.inPre;
      const wasInVPre = context.inVPre;
      const parent = last(ancestors);
      const element = parseTag(context, 0, parent);
      const isPreBoundary = context.inPre && !wasInPre;
      const isVPreBoundary = context.inVPre && !wasInVPre;
      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        if (isPreBoundary) {
          context.inPre = false;
        }
        if (isVPreBoundary) {
          context.inVPre = false;
        }
        return element;
      }
      ancestors.push(element);
      const mode = context.options.getTextMode(element, parent);
      const children = parseChildren(context, mode, ancestors);
      ancestors.pop();
      {
        const inlineTemplateProp = element.props.find((p) => p.type === 6 && p.name === "inline-template");
        if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
          const loc = getSelection(context, element.loc.end);
          inlineTemplateProp.value = {
            type: 2,
            content: loc.source,
            loc
          };
        }
      }
      element.children = children;
      if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1, parent);
      } else {
        emitError(context, 24, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
          const first = children[0];
          if (first && startsWith2(first.loc.source, "<!--")) {
            emitError(context, 8);
          }
        }
      }
      element.loc = getSelection(context, element.loc.start);
      if (isPreBoundary) {
        context.inPre = false;
      }
      if (isVPreBoundary) {
        context.inVPre = false;
      }
      return element;
    }
    var isSpecialTemplateDirective = /* @__PURE__ */ shared.makeMap(`if,else,else-if,for,slot`);
    function parseTag(context, type, parent) {
      const start = getCursor(context);
      const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
      const tag = match[1];
      const ns = context.options.getNamespace(tag, parent);
      advanceBy(context, match[0].length);
      advanceSpaces(context);
      const cursor = getCursor(context);
      const currentSource = context.source;
      if (context.options.isPreTag(tag)) {
        context.inPre = true;
      }
      let props = parseAttributes(context, type);
      if (type === 0 && !context.inVPre && props.some((p) => p.type === 7 && p.name === "pre")) {
        context.inVPre = true;
        shared.extend(context, cursor);
        context.source = currentSource;
        props = parseAttributes(context, type).filter((p) => p.name !== "v-pre");
      }
      let isSelfClosing = false;
      if (context.source.length === 0) {
        emitError(context, 9);
      } else {
        isSelfClosing = startsWith2(context.source, "/>");
        if (type === 1 && isSelfClosing) {
          emitError(context, 4);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
      }
      if (type === 1) {
        return;
      }
      let tagType = 0;
      if (!context.inVPre) {
        if (tag === "slot") {
          tagType = 2;
        } else if (tag === "template") {
          if (props.some((p) => p.type === 7 && isSpecialTemplateDirective(p.name))) {
            tagType = 3;
          }
        } else if (isComponent(tag, props, context)) {
          tagType = 1;
        }
      }
      return {
        type: 1,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: void 0
      };
    }
    function isComponent(tag, props, context) {
      const options = context.options;
      if (options.isCustomElement(tag)) {
        return false;
      }
      if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
        return true;
      }
      for (let i = 0; i < props.length; i++) {
        const p = props[i];
        if (p.type === 6) {
          if (p.name === "is" && p.value) {
            if (p.value.content.startsWith("vue:")) {
              return true;
            } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
              return true;
            }
          }
        } else {
          if (p.name === "is") {
            return true;
          } else if (p.name === "bind" && isStaticArgOf(p.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p.loc)) {
            return true;
          }
        }
      }
    }
    function parseAttributes(context, type) {
      const props = [];
      const attributeNames = /* @__PURE__ */ new Set();
      while (context.source.length > 0 && !startsWith2(context.source, ">") && !startsWith2(context.source, "/>")) {
        if (startsWith2(context.source, "/")) {
          emitError(context, 22);
          advanceBy(context, 1);
          advanceSpaces(context);
          continue;
        }
        if (type === 1) {
          emitError(context, 3);
        }
        const attr = parseAttribute(context, attributeNames);
        if (attr.type === 6 && attr.value && attr.name === "class") {
          attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
        }
        if (type === 0) {
          props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
          emitError(context, 15);
        }
        advanceSpaces(context);
      }
      return props;
    }
    function parseAttribute(context, nameSet) {
      const start = getCursor(context);
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
      const name = match[0];
      if (nameSet.has(name)) {
        emitError(context, 2);
      }
      nameSet.add(name);
      if (name[0] === "=") {
        emitError(context, 19);
      }
      {
        const pattern = /["'<]/g;
        let m;
        while (m = pattern.exec(name)) {
          emitError(context, 17, m.index);
        }
      }
      advanceBy(context, name.length);
      let value = void 0;
      if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
          emitError(context, 13);
        }
      }
      const loc = getSelection(context, start);
      if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
        const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
        let isPropShorthand = startsWith2(name, ".");
        let dirName = match2[1] || (isPropShorthand || startsWith2(name, ":") ? "bind" : startsWith2(name, "@") ? "on" : "slot");
        let arg;
        if (match2[2]) {
          const isSlot = dirName === "slot";
          const startOffset = name.lastIndexOf(match2[2]);
          const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
          let content = match2[2];
          let isStatic = true;
          if (content.startsWith("[")) {
            isStatic = false;
            if (!content.endsWith("]")) {
              emitError(context, 27);
              content = content.slice(1);
            } else {
              content = content.slice(1, content.length - 1);
            }
          } else if (isSlot) {
            content += match2[3] || "";
          }
          arg = {
            type: 4,
            content,
            isStatic,
            constType: isStatic ? 3 : 0,
            loc: loc2
          };
        }
        if (value && value.isQuoted) {
          const valueLoc = value.loc;
          valueLoc.start.offset++;
          valueLoc.start.column++;
          valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
          valueLoc.source = valueLoc.source.slice(1, -1);
        }
        const modifiers = match2[3] ? match2[3].slice(1).split(".") : [];
        if (isPropShorthand)
          modifiers.push("prop");
        if (dirName === "bind" && arg) {
          if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
            dirName = "model";
            modifiers.splice(modifiers.indexOf("sync"), 1);
          }
        }
        return {
          type: 7,
          name: dirName,
          exp: value && {
            type: 4,
            content: value.content,
            isStatic: false,
            constType: 0,
            loc: value.loc
          },
          arg,
          modifiers,
          loc
        };
      }
      if (!context.inVPre && startsWith2(name, "v-")) {
        emitError(context, 26);
      }
      return {
        type: 6,
        name,
        value: value && {
          type: 2,
          content: value.content,
          loc: value.loc
        },
        loc
      };
    }
    function parseAttributeValue(context) {
      const start = getCursor(context);
      let content;
      const quote = context.source[0];
      const isQuoted = quote === `"` || quote === `'`;
      if (isQuoted) {
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
          content = parseTextData(context, context.source.length, 4);
        } else {
          content = parseTextData(context, endIndex, 4);
          advanceBy(context, 1);
        }
      } else {
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
          return void 0;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while (m = unexpectedChars.exec(match[0])) {
          emitError(context, 18, m.index);
        }
        content = parseTextData(context, match[0].length, 4);
      }
      return { content, isQuoted, loc: getSelection(context, start) };
    }
    function parseInterpolation(context, mode) {
      const [open, close] = context.options.delimiters;
      const closeIndex = context.source.indexOf(close, open.length);
      if (closeIndex === -1) {
        emitError(context, 25);
        return void 0;
      }
      const start = getCursor(context);
      advanceBy(context, open.length);
      const innerStart = getCursor(context);
      const innerEnd = getCursor(context);
      const rawContentLength = closeIndex - open.length;
      const rawContent = context.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context, rawContentLength, mode);
      const content = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content);
      if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context, close.length);
      return {
        type: 5,
        content: {
          type: 4,
          isStatic: false,
          constType: 0,
          content,
          loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
      };
    }
    function parseText(context, mode) {
      const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
      let endIndex = context.source.length;
      for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
          endIndex = index;
        }
      }
      const start = getCursor(context);
      const content = parseTextData(context, endIndex, mode);
      return {
        type: 2,
        content,
        loc: getSelection(context, start)
      };
    }
    function parseTextData(context, length, mode) {
      const rawText = context.source.slice(0, length);
      advanceBy(context, length);
      if (mode === 2 || mode === 3 || !rawText.includes("&")) {
        return rawText;
      } else {
        return context.options.decodeEntities(rawText, mode === 4);
      }
    }
    function getCursor(context) {
      const { column, line, offset } = context;
      return { column, line, offset };
    }
    function getSelection(context, start, end) {
      end = end || getCursor(context);
      return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
      };
    }
    function last(xs) {
      return xs[xs.length - 1];
    }
    function startsWith2(source, searchString) {
      return source.startsWith(searchString);
    }
    function advanceBy(context, numberOfCharacters) {
      const { source } = context;
      advancePositionWithMutation(context, source, numberOfCharacters);
      context.source = source.slice(numberOfCharacters);
    }
    function advanceSpaces(context) {
      const match = /^[\t\r\n\f ]+/.exec(context.source);
      if (match) {
        advanceBy(context, match[0].length);
      }
    }
    function getNewPosition(context, start, numberOfCharacters) {
      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
    }
    function emitError(context, code, offset, loc = getCursor(context)) {
      if (offset) {
        loc.offset += offset;
        loc.column += offset;
      }
      context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ""
      }));
    }
    function isEnd(context, mode, ancestors) {
      const s = context.source;
      switch (mode) {
        case 0:
          if (startsWith2(s, "</")) {
            for (let i = ancestors.length - 1; i >= 0; --i) {
              if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                return true;
              }
            }
          }
          break;
        case 1:
        case 2: {
          const parent = last(ancestors);
          if (parent && startsWithEndTagOpen(s, parent.tag)) {
            return true;
          }
          break;
        }
        case 3:
          if (startsWith2(s, "]]>")) {
            return true;
          }
          break;
      }
      return !s;
    }
    function startsWithEndTagOpen(source, tag) {
      return startsWith2(source, "</") && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
    }
    function hoistStatic(root, context) {
      walk2(root, context, isSingleElementRoot(root, root.children[0]));
    }
    function isSingleElementRoot(root, child) {
      const { children } = root;
      return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
    }
    function walk2(node, context, doNotHoistNode = false) {
      const { children } = node;
      const originalCount = children.length;
      let hoistedCount = 0;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.type === 1 && child.tagType === 0) {
          const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
          if (constantType > 0) {
            if (constantType >= 2) {
              child.codegenNode.patchFlag = -1 + ``;
              child.codegenNode = context.hoist(child.codegenNode);
              hoistedCount++;
              continue;
            }
          } else {
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13) {
              const flag = getPatchFlag(codegenNode);
              if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
                const props = getNodeProps(child);
                if (props) {
                  codegenNode.props = context.hoist(props);
                }
              }
              if (codegenNode.dynamicProps) {
                codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
              }
            }
          }
        } else if (child.type === 12 && getConstantType(child.content, context) >= 2) {
          child.codegenNode = context.hoist(child.codegenNode);
          hoistedCount++;
        }
        if (child.type === 1) {
          const isComponent2 = child.tagType === 1;
          if (isComponent2) {
            context.scopes.vSlot++;
          }
          walk2(child, context);
          if (isComponent2) {
            context.scopes.vSlot--;
          }
        } else if (child.type === 11) {
          walk2(child, context, child.children.length === 1);
        } else if (child.type === 9) {
          for (let i2 = 0; i2 < child.branches.length; i2++) {
            walk2(child.branches[i2], context, child.branches[i2].children.length === 1);
          }
        }
      }
      if (hoistedCount && context.transformHoist) {
        context.transformHoist(children, context, node);
      }
      if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && shared.isArray(node.codegenNode.children)) {
        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
      }
    }
    function getConstantType(node, context) {
      const { constantCache } = context;
      switch (node.type) {
        case 1:
          if (node.tagType !== 0) {
            return 0;
          }
          const cached = constantCache.get(node);
          if (cached !== void 0) {
            return cached;
          }
          const codegenNode = node.codegenNode;
          if (codegenNode.type !== 13) {
            return 0;
          }
          if (codegenNode.isBlock && node.tag !== "svg" && node.tag !== "foreignObject") {
            return 0;
          }
          const flag = getPatchFlag(codegenNode);
          if (!flag) {
            let returnType2 = 3;
            const generatedPropsType = getGeneratedPropsConstantType(node, context);
            if (generatedPropsType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (generatedPropsType < returnType2) {
              returnType2 = generatedPropsType;
            }
            for (let i = 0; i < node.children.length; i++) {
              const childType = getConstantType(node.children[i], context);
              if (childType === 0) {
                constantCache.set(node, 0);
                return 0;
              }
              if (childType < returnType2) {
                returnType2 = childType;
              }
            }
            if (returnType2 > 1) {
              for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 && p.name === "bind" && p.exp) {
                  const expType = getConstantType(p.exp, context);
                  if (expType === 0) {
                    constantCache.set(node, 0);
                    return 0;
                  }
                  if (expType < returnType2) {
                    returnType2 = expType;
                  }
                }
              }
            }
            if (codegenNode.isBlock) {
              context.removeHelper(OPEN_BLOCK);
              context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
              codegenNode.isBlock = false;
              context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
            }
            constantCache.set(node, returnType2);
            return returnType2;
          } else {
            constantCache.set(node, 0);
            return 0;
          }
        case 2:
        case 3:
          return 3;
        case 9:
        case 11:
        case 10:
          return 0;
        case 5:
        case 12:
          return getConstantType(node.content, context);
        case 4:
          return node.constType;
        case 8:
          let returnType = 3;
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (shared.isString(child) || shared.isSymbol(child)) {
              continue;
            }
            const childType = getConstantType(child, context);
            if (childType === 0) {
              return 0;
            } else if (childType < returnType) {
              returnType = childType;
            }
          }
          return returnType;
        default:
          return 0;
      }
    }
    var allowHoistedHelperSet = /* @__PURE__ */ new Set([
      NORMALIZE_CLASS,
      NORMALIZE_STYLE,
      NORMALIZE_PROPS,
      GUARD_REACTIVE_PROPS
    ]);
    function getConstantTypeOfHelperCall(value, context) {
      if (value.type === 14 && !shared.isString(value.callee) && allowHoistedHelperSet.has(value.callee)) {
        const arg = value.arguments[0];
        if (arg.type === 4) {
          return getConstantType(arg, context);
        } else if (arg.type === 14) {
          return getConstantTypeOfHelperCall(arg, context);
        }
      }
      return 0;
    }
    function getGeneratedPropsConstantType(node, context) {
      let returnType = 3;
      const props = getNodeProps(node);
      if (props && props.type === 15) {
        const { properties } = props;
        for (let i = 0; i < properties.length; i++) {
          const { key, value } = properties[i];
          const keyType = getConstantType(key, context);
          if (keyType === 0) {
            return keyType;
          }
          if (keyType < returnType) {
            returnType = keyType;
          }
          let valueType;
          if (value.type === 4) {
            valueType = getConstantType(value, context);
          } else if (value.type === 14) {
            valueType = getConstantTypeOfHelperCall(value, context);
          } else {
            valueType = 0;
          }
          if (valueType === 0) {
            return valueType;
          }
          if (valueType < returnType) {
            returnType = valueType;
          }
        }
      }
      return returnType;
    }
    function getNodeProps(node) {
      const codegenNode = node.codegenNode;
      if (codegenNode.type === 13) {
        return codegenNode.props;
      }
    }
    function getPatchFlag(node) {
      const flag = node.patchFlag;
      return flag ? parseInt(flag, 10) : void 0;
    }
    function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = shared.NOOP, isCustomElement = shared.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = shared.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
      const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
      const context = {
        selfName: nameMatch && shared.capitalize(shared.camelize(nameMatch[1])),
        prefixIdentifiers,
        hoistStatic: hoistStatic2,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        isCustomElement,
        expressionPlugins,
        scopeId,
        slotted,
        ssr,
        inSSR,
        ssrCssVars,
        bindingMetadata,
        inline,
        isTS,
        onError,
        onWarn,
        compatConfig,
        root,
        helpers: /* @__PURE__ */ new Map(),
        components: /* @__PURE__ */ new Set(),
        directives: /* @__PURE__ */ new Set(),
        hoists: [],
        imports: [],
        constantCache: /* @__PURE__ */ new Map(),
        temps: 0,
        cached: 0,
        identifiers: /* @__PURE__ */ Object.create(null),
        scopes: {
          vFor: 0,
          vSlot: 0,
          vPre: 0,
          vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        inVOnce: false,
        helper(name) {
          const count = context.helpers.get(name) || 0;
          context.helpers.set(name, count + 1);
          return name;
        },
        removeHelper(name) {
          const count = context.helpers.get(name);
          if (count) {
            const currentCount = count - 1;
            if (!currentCount) {
              context.helpers.delete(name);
            } else {
              context.helpers.set(name, currentCount);
            }
          }
        },
        helperString(name) {
          return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
          context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
          const list = context.parent.children;
          const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
          if (!node || node === context.currentNode) {
            context.currentNode = null;
            context.onNodeRemoved();
          } else {
            if (context.childIndex > removalIndex) {
              context.childIndex--;
              context.onNodeRemoved();
            }
          }
          context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => {
        },
        addIdentifiers(exp) {
          {
            if (shared.isString(exp)) {
              addId(exp);
            } else if (exp.identifiers) {
              exp.identifiers.forEach(addId);
            } else if (exp.type === 4) {
              addId(exp.content);
            }
          }
        },
        removeIdentifiers(exp) {
          {
            if (shared.isString(exp)) {
              removeId(exp);
            } else if (exp.identifiers) {
              exp.identifiers.forEach(removeId);
            } else if (exp.type === 4) {
              removeId(exp.content);
            }
          }
        },
        hoist(exp) {
          if (shared.isString(exp))
            exp = createSimpleExpression(exp);
          context.hoists.push(exp);
          const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
          identifier.hoisted = exp;
          return identifier;
        },
        cache(exp, isVNode = false) {
          return createCacheExpression(context.cached++, exp, isVNode);
        }
      };
      {
        context.filters = /* @__PURE__ */ new Set();
      }
      function addId(id) {
        const { identifiers } = context;
        if (identifiers[id] === void 0) {
          identifiers[id] = 0;
        }
        identifiers[id]++;
      }
      function removeId(id) {
        context.identifiers[id]--;
      }
      return context;
    }
    function transform(root, options) {
      const context = createTransformContext(root, options);
      traverseNode(root, context);
      if (options.hoistStatic) {
        hoistStatic(root, context);
      }
      if (!options.ssr) {
        createRootCodegen(root, context);
      }
      root.helpers = [...context.helpers.keys()];
      root.components = [...context.components];
      root.directives = [...context.directives];
      root.imports = context.imports;
      root.hoists = context.hoists;
      root.temps = context.temps;
      root.cached = context.cached;
      {
        root.filters = [...context.filters];
      }
    }
    function createRootCodegen(root, context) {
      const { helper } = context;
      const { children } = root;
      if (children.length === 1) {
        const child = children[0];
        if (isSingleElementRoot(root, child) && child.codegenNode) {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            makeBlock(codegenNode, context);
          }
          root.codegenNode = codegenNode;
        } else {
          root.codegenNode = child;
        }
      } else if (children.length > 1) {
        let patchFlag = 64;
        shared.PatchFlagNames[64];
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + ``, void 0, void 0, true, void 0, false);
      } else
        ;
    }
    function traverseChildren(parent, context) {
      let i = 0;
      const nodeRemoved = () => {
        i--;
      };
      for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if (shared.isString(child))
          continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
      }
    }
    function traverseNode(node, context) {
      context.currentNode = node;
      const { nodeTransforms } = context;
      const exitFns = [];
      for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
        const onExit = nodeTransforms[i2](node, context);
        if (onExit) {
          if (shared.isArray(onExit)) {
            exitFns.push(...onExit);
          } else {
            exitFns.push(onExit);
          }
        }
        if (!context.currentNode) {
          return;
        } else {
          node = context.currentNode;
        }
      }
      switch (node.type) {
        case 3:
          if (!context.ssr) {
            context.helper(CREATE_COMMENT);
          }
          break;
        case 5:
          if (!context.ssr) {
            context.helper(TO_DISPLAY_STRING);
          }
          break;
        case 9:
          for (let i2 = 0; i2 < node.branches.length; i2++) {
            traverseNode(node.branches[i2], context);
          }
          break;
        case 10:
        case 11:
        case 1:
        case 0:
          traverseChildren(node, context);
          break;
      }
      context.currentNode = node;
      let i = exitFns.length;
      while (i--) {
        exitFns[i]();
      }
    }
    function createStructuralDirectiveTransform(name, fn) {
      const matches = shared.isString(name) ? (n) => n === name : (n) => name.test(n);
      return (node, context) => {
        if (node.type === 1) {
          const { props } = node;
          if (node.tagType === 3 && props.some(isVSlot)) {
            return;
          }
          const exitFns = [];
          for (let i = 0; i < props.length; i++) {
            const prop = props[i];
            if (prop.type === 7 && matches(prop.name)) {
              props.splice(i, 1);
              i--;
              const onExit = fn(node, prop, context);
              if (onExit)
                exitFns.push(onExit);
            }
          }
          return exitFns;
        }
      };
    }
    var PURE_ANNOTATION = `/*#__PURE__*/`;
    function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap: sourceMap$1 = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = "vue/server-renderer", ssr = false, isTS = false, inSSR = false }) {
      const context = {
        mode,
        prefixIdentifiers,
        sourceMap: sourceMap$1,
        filename,
        scopeId,
        optimizeImports,
        runtimeGlobalName,
        runtimeModuleName,
        ssrRuntimeModuleName,
        ssr,
        isTS,
        inSSR,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: void 0,
        helper(key) {
          return `_${helperNameMap[key]}`;
        },
        push(code, node) {
          context.code += code;
          if (context.map) {
            if (node) {
              let name;
              if (node.type === 4 && !node.isStatic) {
                const content = node.content.replace(/^_ctx\./, "");
                if (content !== node.content && isSimpleIdentifier(content)) {
                  name = content;
                }
              }
              addMapping(node.loc.start, name);
            }
            advancePositionWithMutation(context, code);
            if (node && node.loc !== locStub) {
              addMapping(node.loc.end);
            }
          }
        },
        indent() {
          newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
          if (withoutNewLine) {
            --context.indentLevel;
          } else {
            newline(--context.indentLevel);
          }
        },
        newline() {
          newline(context.indentLevel);
        }
      };
      function newline(n) {
        context.push("\n" + `  `.repeat(n));
      }
      function addMapping(loc, name) {
        context.map.addMapping({
          name,
          source: context.filename,
          original: {
            line: loc.line,
            column: loc.column - 1
          },
          generated: {
            line: context.line,
            column: context.column - 1
          }
        });
      }
      if (sourceMap$1) {
        context.map = new sourceMap.SourceMapGenerator();
        context.map.setSourceContent(filename, context.source);
      }
      return context;
    }
    function generate(ast, options = {}) {
      const context = createCodegenContext(ast, options);
      if (options.onContextCreated)
        options.onContextCreated(context);
      const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
      const hasHelpers = ast.helpers.length > 0;
      const useWithBlock = !prefixIdentifiers && mode !== "module";
      const genScopeId = scopeId != null && mode === "module";
      const isSetupInlined = !!options.inline;
      const preambleContext = isSetupInlined ? createCodegenContext(ast, options) : context;
      if (mode === "module") {
        genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);
      } else {
        genFunctionPreamble(ast, preambleContext);
      }
      const functionName = ssr ? `ssrRender` : `render`;
      const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
      if (options.bindingMetadata && !options.inline) {
        args.push("$props", "$setup", "$data", "$options");
      }
      const signature = options.isTS ? args.map((arg) => `${arg}: any`).join(",") : args.join(", ");
      if (isSetupInlined) {
        push(`(${signature}) => {`);
      } else {
        push(`function ${functionName}(${signature}) {`);
      }
      indent();
      if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        if (hasHelpers) {
          push(`const { ${ast.helpers.map((s) => `${helperNameMap[s]}: _${helperNameMap[s]}`).join(", ")} } = _Vue`);
          push(`
`);
          newline();
        }
      }
      if (ast.components.length) {
        genAssets(ast.components, "component", context);
        if (ast.directives.length || ast.temps > 0) {
          newline();
        }
      }
      if (ast.directives.length) {
        genAssets(ast.directives, "directive", context);
        if (ast.temps > 0) {
          newline();
        }
      }
      if (ast.filters && ast.filters.length) {
        newline();
        genAssets(ast.filters, "filter", context);
        newline();
      }
      if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
          push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
      }
      if (ast.components.length || ast.directives.length || ast.temps) {
        push(`
`);
        newline();
      }
      if (!ssr) {
        push(`return `);
      }
      if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
      } else {
        push(`null`);
      }
      if (useWithBlock) {
        deindent();
        push(`}`);
      }
      deindent();
      push(`}`);
      return {
        ast,
        code: context.code,
        preamble: isSetupInlined ? preambleContext.code : ``,
        map: context.map ? context.map.toJSON() : void 0
      };
    }
    function genFunctionPreamble(ast, context) {
      const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;
      const VueBinding = ssr ? `require(${JSON.stringify(runtimeModuleName)})` : runtimeGlobalName;
      const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
      if (ast.helpers.length > 0) {
        if (prefixIdentifiers) {
          push(`const { ${ast.helpers.map(aliasHelper).join(", ")} } = ${VueBinding}
`);
        } else {
          push(`const _Vue = ${VueBinding}
`);
          if (ast.hoists.length) {
            const staticHelpers = [
              CREATE_VNODE,
              CREATE_ELEMENT_VNODE,
              CREATE_COMMENT,
              CREATE_TEXT,
              CREATE_STATIC
            ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
            push(`const { ${staticHelpers} } = _Vue
`);
          }
        }
      }
      if (ast.ssrHelpers && ast.ssrHelpers.length) {
        push(`const { ${ast.ssrHelpers.map(aliasHelper).join(", ")} } = require("${ssrRuntimeModuleName}")
`);
      }
      genHoists(ast.hoists, context);
      newline();
      push(`return `);
    }
    function genModulePreamble(ast, context, genScopeId, inline) {
      const { push, newline, optimizeImports, runtimeModuleName, ssrRuntimeModuleName } = context;
      if (genScopeId && ast.hoists.length) {
        ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID);
      }
      if (ast.helpers.length) {
        if (optimizeImports) {
          push(`import { ${ast.helpers.map((s) => helperNameMap[s]).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`);
          push(`
// Binding optimization for webpack code-split
const ${ast.helpers.map((s) => `_${helperNameMap[s]} = ${helperNameMap[s]}`).join(", ")}
`);
        } else {
          push(`import { ${ast.helpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from ${JSON.stringify(runtimeModuleName)}
`);
        }
      }
      if (ast.ssrHelpers && ast.ssrHelpers.length) {
        push(`import { ${ast.ssrHelpers.map((s) => `${helperNameMap[s]} as _${helperNameMap[s]}`).join(", ")} } from "${ssrRuntimeModuleName}"
`);
      }
      if (ast.imports.length) {
        genImports(ast.imports, context);
        newline();
      }
      genHoists(ast.hoists, context);
      newline();
      if (!inline) {
        push(`export `);
      }
    }
    function genAssets(assets, type, { helper, push, newline, isTS }) {
      const resolver = helper(type === "filter" ? RESOLVE_FILTER : type === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
      for (let i = 0; i < assets.length; i++) {
        let id = assets[i];
        const maybeSelfReference = id.endsWith("__self");
        if (maybeSelfReference) {
          id = id.slice(0, -6);
        }
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
        if (i < assets.length - 1) {
          newline();
        }
      }
    }
    function genHoists(hoists, context) {
      if (!hoists.length) {
        return;
      }
      context.pure = true;
      const { push, newline, helper, scopeId, mode } = context;
      const genScopeId = scopeId != null && mode !== "function";
      newline();
      if (genScopeId) {
        push(`const _withScopeId = n => (${helper(PUSH_SCOPE_ID)}("${scopeId}"),n=n(),${helper(POP_SCOPE_ID)}(),n)`);
        newline();
      }
      for (let i = 0; i < hoists.length; i++) {
        const exp = hoists[i];
        if (exp) {
          const needScopeIdWrapper = genScopeId && exp.type === 13;
          push(`const _hoisted_${i + 1} = ${needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``}`);
          genNode(exp, context);
          if (needScopeIdWrapper) {
            push(`)`);
          }
          newline();
        }
      }
      context.pure = false;
    }
    function genImports(importsOptions, context) {
      if (!importsOptions.length) {
        return;
      }
      importsOptions.forEach((imports) => {
        context.push(`import `);
        genNode(imports.exp, context);
        context.push(` from '${imports.path}'`);
        context.newline();
      });
    }
    function isText$1(n) {
      return shared.isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
    }
    function genNodeListAsArray(nodes, context) {
      const multilines = nodes.length > 3 || nodes.some((n) => shared.isArray(n) || !isText$1(n));
      context.push(`[`);
      multilines && context.indent();
      genNodeList(nodes, context, multilines);
      multilines && context.deindent();
      context.push(`]`);
    }
    function genNodeList(nodes, context, multilines = false, comma = true) {
      const { push, newline } = context;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (shared.isString(node)) {
          push(node);
        } else if (shared.isArray(node)) {
          genNodeListAsArray(node, context);
        } else {
          genNode(node, context);
        }
        if (i < nodes.length - 1) {
          if (multilines) {
            comma && push(",");
            newline();
          } else {
            comma && push(", ");
          }
        }
      }
    }
    function genNode(node, context) {
      if (shared.isString(node)) {
        context.push(node);
        return;
      }
      if (shared.isSymbol(node)) {
        context.push(context.helper(node));
        return;
      }
      switch (node.type) {
        case 1:
        case 9:
        case 11:
          genNode(node.codegenNode, context);
          break;
        case 2:
          genText(node, context);
          break;
        case 4:
          genExpression(node, context);
          break;
        case 5:
          genInterpolation(node, context);
          break;
        case 12:
          genNode(node.codegenNode, context);
          break;
        case 8:
          genCompoundExpression(node, context);
          break;
        case 3:
          genComment(node, context);
          break;
        case 13:
          genVNodeCall(node, context);
          break;
        case 14:
          genCallExpression(node, context);
          break;
        case 15:
          genObjectExpression(node, context);
          break;
        case 17:
          genArrayExpression(node, context);
          break;
        case 18:
          genFunctionExpression(node, context);
          break;
        case 19:
          genConditionalExpression(node, context);
          break;
        case 20:
          genCacheExpression(node, context);
          break;
        case 21:
          genNodeList(node.body, context, true, false);
          break;
        case 22:
          genTemplateLiteral(node, context);
          break;
        case 23:
          genIfStatement(node, context);
          break;
        case 24:
          genAssignmentExpression(node, context);
          break;
        case 25:
          genSequenceExpression(node, context);
          break;
        case 26:
          genReturnStatement(node, context);
          break;
      }
    }
    function genText(node, context) {
      context.push(JSON.stringify(node.content), node);
    }
    function genExpression(node, context) {
      const { content, isStatic } = node;
      context.push(isStatic ? JSON.stringify(content) : content, node);
    }
    function genInterpolation(node, context) {
      const { push, helper, pure } = context;
      if (pure)
        push(PURE_ANNOTATION);
      push(`${helper(TO_DISPLAY_STRING)}(`);
      genNode(node.content, context);
      push(`)`);
    }
    function genCompoundExpression(node, context) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (shared.isString(child)) {
          context.push(child);
        } else {
          genNode(child, context);
        }
      }
    }
    function genExpressionAsPropertyKey(node, context) {
      const { push } = context;
      if (node.type === 8) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
      } else if (node.isStatic) {
        const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
        push(text, node);
      } else {
        push(`[${node.content}]`, node);
      }
    }
    function genComment(node, context) {
      const { push, helper, pure } = context;
      if (pure) {
        push(PURE_ANNOTATION);
      }
      push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
    }
    function genVNodeCall(node, context) {
      const { push, helper, pure } = context;
      const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent: isComponent2 } = node;
      if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
      }
      if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
      }
      if (pure) {
        push(PURE_ANNOTATION);
      }
      const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
      push(helper(callHelper) + `(`, node);
      genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
      push(`)`);
      if (isBlock) {
        push(`)`);
      }
      if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
      }
    }
    function genNullableArgs(args) {
      let i = args.length;
      while (i--) {
        if (args[i] != null)
          break;
      }
      return args.slice(0, i + 1).map((arg) => arg || `null`);
    }
    function genCallExpression(node, context) {
      const { push, helper, pure } = context;
      const callee = shared.isString(node.callee) ? node.callee : helper(node.callee);
      if (pure) {
        push(PURE_ANNOTATION);
      }
      push(callee + `(`, node);
      genNodeList(node.arguments, context);
      push(`)`);
    }
    function genObjectExpression(node, context) {
      const { push, indent, deindent, newline } = context;
      const { properties } = node;
      if (!properties.length) {
        push(`{}`, node);
        return;
      }
      const multilines = properties.length > 1 || properties.some((p) => p.value.type !== 4);
      push(multilines ? `{` : `{ `);
      multilines && indent();
      for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        genNode(value, context);
        if (i < properties.length - 1) {
          push(`,`);
          newline();
        }
      }
      multilines && deindent();
      push(multilines ? `}` : ` }`);
    }
    function genArrayExpression(node, context) {
      genNodeListAsArray(node.elements, context);
    }
    function genFunctionExpression(node, context) {
      const { push, indent, deindent } = context;
      const { params, returns, body, newline, isSlot } = node;
      if (isSlot) {
        push(`_${helperNameMap[WITH_CTX]}(`);
      }
      push(`(`, node);
      if (shared.isArray(params)) {
        genNodeList(params, context);
      } else if (params) {
        genNode(params, context);
      }
      push(`) => `);
      if (newline || body) {
        push(`{`);
        indent();
      }
      if (returns) {
        if (newline) {
          push(`return `);
        }
        if (shared.isArray(returns)) {
          genNodeListAsArray(returns, context);
        } else {
          genNode(returns, context);
        }
      } else if (body) {
        genNode(body, context);
      }
      if (newline || body) {
        deindent();
        push(`}`);
      }
      if (isSlot) {
        if (node.isNonScopedSlot) {
          push(`, undefined, true`);
        }
        push(`)`);
      }
    }
    function genConditionalExpression(node, context) {
      const { test, consequent, alternate, newline: needNewline } = node;
      const { push, indent, deindent, newline } = context;
      if (test.type === 4) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
      } else {
        push(`(`);
        genNode(test, context);
        push(`)`);
      }
      needNewline && indent();
      context.indentLevel++;
      needNewline || push(` `);
      push(`? `);
      genNode(consequent, context);
      context.indentLevel--;
      needNewline && newline();
      needNewline || push(` `);
      push(`: `);
      const isNested = alternate.type === 19;
      if (!isNested) {
        context.indentLevel++;
      }
      genNode(alternate, context);
      if (!isNested) {
        context.indentLevel--;
      }
      needNewline && deindent(true);
    }
    function genCacheExpression(node, context) {
      const { push, helper, indent, deindent, newline } = context;
      push(`_cache[${node.index}] || (`);
      if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
      }
      push(`_cache[${node.index}] = `);
      genNode(node.value, context);
      if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
      }
      push(`)`);
    }
    function genTemplateLiteral(node, context) {
      const { push, indent, deindent } = context;
      push("`");
      const l = node.elements.length;
      const multilines = l > 3;
      for (let i = 0; i < l; i++) {
        const e = node.elements[i];
        if (shared.isString(e)) {
          push(e.replace(/(`|\$|\\)/g, "\\$1"));
        } else {
          push("${");
          if (multilines)
            indent();
          genNode(e, context);
          if (multilines)
            deindent();
          push("}");
        }
      }
      push("`");
    }
    function genIfStatement(node, context) {
      const { push, indent, deindent } = context;
      const { test, consequent, alternate } = node;
      push(`if (`);
      genNode(test, context);
      push(`) {`);
      indent();
      genNode(consequent, context);
      deindent();
      push(`}`);
      if (alternate) {
        push(` else `);
        if (alternate.type === 23) {
          genIfStatement(alternate, context);
        } else {
          push(`{`);
          indent();
          genNode(alternate, context);
          deindent();
          push(`}`);
        }
      }
    }
    function genAssignmentExpression(node, context) {
      genNode(node.left, context);
      context.push(` = `);
      genNode(node.right, context);
    }
    function genSequenceExpression(node, context) {
      context.push(`(`);
      genNodeList(node.expressions, context);
      context.push(`)`);
    }
    function genReturnStatement({ returns }, context) {
      context.push(`return `);
      if (shared.isArray(returns)) {
        genNodeListAsArray(returns, context);
      } else {
        genNode(returns, context);
      }
    }
    function walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = /* @__PURE__ */ Object.create(null)) {
      const rootExp = root.type === "Program" && root.body[0].type === "ExpressionStatement" && root.body[0].expression;
      estreeWalker.walk(root, {
        enter(node, parent) {
          parent && parentStack.push(parent);
          if (parent && parent.type.startsWith("TS") && parent.type !== "TSAsExpression" && parent.type !== "TSNonNullExpression" && parent.type !== "TSTypeAssertion") {
            return this.skip();
          }
          if (node.type === "Identifier") {
            const isLocal = !!knownIds[node.name];
            const isRefed = isReferencedIdentifier(node, parent, parentStack);
            if (includeAll || isRefed && !isLocal) {
              onIdentifier(node, parent, parentStack, isRefed, isLocal);
            }
          } else if (node.type === "ObjectProperty" && parent.type === "ObjectPattern") {
            node.inPattern = true;
          } else if (isFunctionType(node)) {
            walkFunctionParams(node, (id) => markScopeIdentifier(node, id, knownIds));
          } else if (node.type === "BlockStatement") {
            walkBlockDeclarations(node, (id) => markScopeIdentifier(node, id, knownIds));
          }
        },
        leave(node, parent) {
          parent && parentStack.pop();
          if (node !== rootExp && node.scopeIds) {
            for (const id of node.scopeIds) {
              knownIds[id]--;
              if (knownIds[id] === 0) {
                delete knownIds[id];
              }
            }
          }
        }
      });
    }
    function isReferencedIdentifier(id, parent, parentStack) {
      if (!parent) {
        return true;
      }
      if (id.name === "arguments") {
        return false;
      }
      if (isReferenced(id, parent)) {
        return true;
      }
      switch (parent.type) {
        case "AssignmentExpression":
        case "AssignmentPattern":
          return true;
        case "ObjectPattern":
        case "ArrayPattern":
          return isInDestructureAssignment(parent, parentStack);
      }
      return false;
    }
    function isInDestructureAssignment(parent, parentStack) {
      if (parent && (parent.type === "ObjectProperty" || parent.type === "ArrayPattern")) {
        let i = parentStack.length;
        while (i--) {
          const p = parentStack[i];
          if (p.type === "AssignmentExpression") {
            return true;
          } else if (p.type !== "ObjectProperty" && !p.type.endsWith("Pattern")) {
            break;
          }
        }
      }
      return false;
    }
    function walkFunctionParams(node, onIdent) {
      for (const p of node.params) {
        for (const id of extractIdentifiers(p)) {
          onIdent(id);
        }
      }
    }
    function walkBlockDeclarations(block, onIdent) {
      for (const stmt of block.body) {
        if (stmt.type === "VariableDeclaration") {
          if (stmt.declare)
            continue;
          for (const decl of stmt.declarations) {
            for (const id of extractIdentifiers(decl.id)) {
              onIdent(id);
            }
          }
        } else if (stmt.type === "FunctionDeclaration" || stmt.type === "ClassDeclaration") {
          if (stmt.declare || !stmt.id)
            continue;
          onIdent(stmt.id);
        }
      }
    }
    function extractIdentifiers(param, nodes = []) {
      switch (param.type) {
        case "Identifier":
          nodes.push(param);
          break;
        case "MemberExpression":
          let object = param;
          while (object.type === "MemberExpression") {
            object = object.object;
          }
          nodes.push(object);
          break;
        case "ObjectPattern":
          for (const prop of param.properties) {
            if (prop.type === "RestElement") {
              extractIdentifiers(prop.argument, nodes);
            } else {
              extractIdentifiers(prop.value, nodes);
            }
          }
          break;
        case "ArrayPattern":
          param.elements.forEach((element) => {
            if (element)
              extractIdentifiers(element, nodes);
          });
          break;
        case "RestElement":
          extractIdentifiers(param.argument, nodes);
          break;
        case "AssignmentPattern":
          extractIdentifiers(param.left, nodes);
          break;
      }
      return nodes;
    }
    function markScopeIdentifier(node, child, knownIds) {
      const { name } = child;
      if (node.scopeIds && node.scopeIds.has(name)) {
        return;
      }
      if (name in knownIds) {
        knownIds[name]++;
      } else {
        knownIds[name] = 1;
      }
      (node.scopeIds || (node.scopeIds = /* @__PURE__ */ new Set())).add(name);
    }
    var isFunctionType = (node) => {
      return /Function(?:Expression|Declaration)$|Method$/.test(node.type);
    };
    var isStaticProperty = (node) => node && (node.type === "ObjectProperty" || node.type === "ObjectMethod") && !node.computed;
    var isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;
    function isReferenced(node, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node) {
            return !!parent.computed;
          }
          return parent.object === node;
        case "JSXMemberExpression":
          return parent.object === node;
        case "VariableDeclarator":
          return parent.init === node;
        case "ArrowFunctionExpression":
          return parent.body === node;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node;
        case "AssignmentExpression":
          return parent.right === node;
        case "AssignmentPattern":
          return parent.right === node;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent === null || grandparent === void 0 ? void 0 : grandparent.source) {
            return false;
          }
          return parent.local === node;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node;
        case "TSEnumMember":
          return parent.id !== node;
        case "TSPropertySignature":
          if (parent.key === node) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
    var isLiteralWhitelisted = /* @__PURE__ */ shared.makeMap("true,false,null,this");
    var transformExpression = (node, context) => {
      if (node.type === 5) {
        node.content = processExpression(node.content, context);
      } else if (node.type === 1) {
        for (let i = 0; i < node.props.length; i++) {
          const dir = node.props[i];
          if (dir.type === 7 && dir.name !== "for") {
            const exp = dir.exp;
            const arg = dir.arg;
            if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
              dir.exp = processExpression(exp, context, dir.name === "slot");
            }
            if (arg && arg.type === 4 && !arg.isStatic) {
              dir.arg = processExpression(arg, context);
            }
          }
        }
      }
    };
    function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
      if (!context.prefixIdentifiers || !node.content.trim()) {
        return node;
      }
      const { inline, bindingMetadata } = context;
      const rewriteIdentifier = (raw, parent, id) => {
        const type = shared.hasOwn(bindingMetadata, raw) && bindingMetadata[raw];
        if (inline) {
          const isAssignmentLVal = parent && parent.type === "AssignmentExpression" && parent.left === id;
          const isUpdateArg = parent && parent.type === "UpdateExpression" && parent.argument === id;
          const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);
          if (type === "setup-const" || localVars[raw]) {
            return raw;
          } else if (type === "setup-ref") {
            return `${raw}.value`;
          } else if (type === "setup-maybe-ref") {
            return isAssignmentLVal || isUpdateArg || isDestructureAssignment ? `${raw}.value` : `${context.helperString(UNREF)}(${raw})`;
          } else if (type === "setup-let") {
            if (isAssignmentLVal) {
              const { right: rVal, operator } = parent;
              const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);
              const rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp, false), context, false, false, knownIds));
              return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${raw}.value ${operator} ${rExpString} : ${raw}`;
            } else if (isUpdateArg) {
              id.start = parent.start;
              id.end = parent.end;
              const { prefix: isPrefix, operator } = parent;
              const prefix = isPrefix ? operator : ``;
              const postfix = isPrefix ? `` : operator;
              return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore
` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;
            } else if (isDestructureAssignment) {
              return raw;
            } else {
              return `${context.helperString(UNREF)}(${raw})`;
            }
          } else if (type === "props") {
            return `__props.${raw}`;
          } else if (type === "props-aliased") {
            return `__props.${bindingMetadata.__propsAliases[raw]}`;
          }
        } else {
          if (type && type.startsWith("setup")) {
            return `$setup.${raw}`;
          } else if (type === "props-aliased") {
            return `$props.${bindingMetadata.__propsAliases[raw]}`;
          } else if (type) {
            return `$${type}.${raw}`;
          }
        }
        return `_ctx.${raw}`;
      };
      const rawExp = node.content;
      const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf(".") > 0;
      if (isSimpleIdentifier(rawExp)) {
        const isScopeVarReference = context.identifiers[rawExp];
        const isAllowedGlobal = shared.isGloballyWhitelisted(rawExp);
        const isLiteral = isLiteralWhitelisted(rawExp);
        if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {
          if (bindingMetadata[node.content] === "setup-const") {
            node.constType = 1;
          }
          node.content = rewriteIdentifier(rawExp);
        } else if (!isScopeVarReference) {
          if (isLiteral) {
            node.constType = 3;
          } else {
            node.constType = 2;
          }
        }
        return node;
      }
      let ast;
      const source = asRawStatements ? ` ${rawExp} ` : `(${rawExp})${asParams ? `=>{}` : ``}`;
      try {
        ast = parser.parse(source, {
          plugins: context.expressionPlugins
        }).program;
      } catch (e) {
        context.onError(createCompilerError(44, node.loc, void 0, e.message));
        return node;
      }
      const ids = [];
      const parentStack = [];
      const knownIds = Object.create(context.identifiers);
      walkIdentifiers(ast, (node2, parent, _, isReferenced2, isLocal) => {
        if (isStaticPropertyKey(node2, parent)) {
          return;
        }
        if (node2.name.startsWith("_filter_")) {
          return;
        }
        const needPrefix = isReferenced2 && canPrefix(node2);
        if (needPrefix && !isLocal) {
          if (isStaticProperty(parent) && parent.shorthand) {
            node2.prefix = `${node2.name}: `;
          }
          node2.name = rewriteIdentifier(node2.name, parent, node2);
          ids.push(node2);
        } else {
          if (!(needPrefix && isLocal) && !bailConstant) {
            node2.isConstant = true;
          }
          ids.push(node2);
        }
      }, true, parentStack, knownIds);
      const children = [];
      ids.sort((a, b) => a.start - b.start);
      ids.forEach((id, i) => {
        const start = id.start - 1;
        const end = id.end - 1;
        const last2 = ids[i - 1];
        const leadingText = rawExp.slice(last2 ? last2.end - 1 : 0, start);
        if (leadingText.length || id.prefix) {
          children.push(leadingText + (id.prefix || ``));
        }
        const source2 = rawExp.slice(start, end);
        children.push(createSimpleExpression(id.name, false, {
          source: source2,
          start: advancePositionWithClone(node.loc.start, source2, start),
          end: advancePositionWithClone(node.loc.start, source2, end)
        }, id.isConstant ? 3 : 0));
        if (i === ids.length - 1 && end < rawExp.length) {
          children.push(rawExp.slice(end));
        }
      });
      let ret;
      if (children.length) {
        ret = createCompoundExpression(children, node.loc);
      } else {
        ret = node;
        ret.constType = bailConstant ? 0 : 3;
      }
      ret.identifiers = Object.keys(knownIds);
      return ret;
    }
    function canPrefix(id) {
      if (shared.isGloballyWhitelisted(id.name)) {
        return false;
      }
      if (id.name === "require") {
        return false;
      }
      return true;
    }
    function stringifyExpression(exp) {
      if (shared.isString(exp)) {
        return exp;
      } else if (exp.type === 4) {
        return exp.content;
      } else {
        return exp.children.map(stringifyExpression).join("");
      }
    }
    var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
      return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        const siblings = context.parent.children;
        let i = siblings.indexOf(ifNode);
        let key = 0;
        while (i-- >= 0) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 9) {
            key += sibling.branches.length;
          }
        }
        return () => {
          if (isRoot) {
            ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
          } else {
            const parentCondition = getParentCondition(ifNode.codegenNode);
            parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
          }
        };
      });
    });
    function processIf(node, dir, context, processCodegen) {
      if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(28, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
      }
      if (context.prefixIdentifiers && dir.exp) {
        dir.exp = processExpression(dir.exp, context);
      }
      if (dir.name === "if") {
        const branch = createIfBranch(node, dir);
        const ifNode = {
          type: 9,
          loc: node.loc,
          branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
          return processCodegen(ifNode, branch, true);
        }
      } else {
        const siblings = context.parent.children;
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
          const sibling = siblings[i];
          if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
            context.removeNode(sibling);
            continue;
          }
          if (sibling && sibling.type === 9) {
            if (dir.name === "else-if" && sibling.branches[sibling.branches.length - 1].condition === void 0) {
              context.onError(createCompilerError(30, node.loc));
            }
            context.removeNode();
            const branch = createIfBranch(node, dir);
            {
              const key = branch.userKey;
              if (key) {
                sibling.branches.forEach(({ userKey }) => {
                  if (isSameKey(userKey, key)) {
                    context.onError(createCompilerError(29, branch.userKey.loc));
                  }
                });
              }
            }
            sibling.branches.push(branch);
            const onExit = processCodegen && processCodegen(sibling, branch, false);
            traverseNode(branch, context);
            if (onExit)
              onExit();
            context.currentNode = null;
          } else {
            context.onError(createCompilerError(30, node.loc));
          }
          break;
        }
      }
    }
    function createIfBranch(node, dir) {
      return {
        type: 10,
        loc: node.loc,
        condition: dir.name === "else" ? void 0 : dir.exp,
        children: node.tagType === 3 && !findDir(node, "for") ? node.children : [node],
        userKey: findProp(node, `key`)
      };
    }
    function createCodegenNodeForBranch(branch, keyIndex, context) {
      if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
          '""',
          "true"
        ]));
      } else {
        return createChildrenCodegenNode(branch, keyIndex, context);
      }
    }
    function createChildrenCodegenNode(branch, keyIndex, context) {
      const { helper } = context;
      const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
      const { children } = branch;
      const firstChild = children[0];
      const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
      if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11) {
          const vnodeCall = firstChild.codegenNode;
          injectProp(vnodeCall, keyProperty, context);
          return vnodeCall;
        } else {
          let patchFlag = 64;
          shared.PatchFlagNames[64];
          return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ``, void 0, void 0, true, false, false, branch.loc);
        }
      } else {
        const ret = firstChild.codegenNode;
        const vnodeCall = getMemoedVNodeCall(ret);
        if (vnodeCall.type === 13) {
          makeBlock(vnodeCall, context);
        }
        injectProp(vnodeCall, keyProperty, context);
        return ret;
      }
    }
    function isSameKey(a, b) {
      if (!a || a.type !== b.type) {
        return false;
      }
      if (a.type === 6) {
        if (a.value.content !== b.value.content) {
          return false;
        }
      } else {
        const exp = a.exp;
        const branchExp = b.exp;
        if (exp.type !== branchExp.type) {
          return false;
        }
        if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
          return false;
        }
      }
      return true;
    }
    function getParentCondition(node) {
      while (true) {
        if (node.type === 19) {
          if (node.alternate.type === 19) {
            node = node.alternate;
          } else {
            return node;
          }
        } else if (node.type === 20) {
          node = node.value;
        }
      }
    }
    var transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
      const { helper, removeHelper } = context;
      return processFor(node, dir, context, (forNode) => {
        const renderExp = createCallExpression(helper(RENDER_LIST), [
          forNode.source
        ]);
        const isTemplate = isTemplateNode(node);
        const memo = findDir(node, "memo");
        const keyProp = findProp(node, `key`);
        const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
        if (isTemplate) {
          if (memo) {
            memo.exp = processExpression(memo.exp, context);
          }
          if (keyProperty && keyProp.type !== 6) {
            keyProperty.value = processExpression(keyProperty.value, context);
          }
        }
        const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
        const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + ``, void 0, void 0, true, !isStableFragment, false, node.loc);
        return () => {
          let childBlock;
          const { children } = forNode;
          if (isTemplate) {
            node.children.some((c) => {
              if (c.type === 1) {
                const key = findProp(c, "key");
                if (key) {
                  context.onError(createCompilerError(33, key.loc));
                  return true;
                }
              }
            });
          }
          const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
          const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
          if (slotOutlet) {
            childBlock = slotOutlet.codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
          } else if (needFragmentWrapper) {
            childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + ``, void 0, void 0, true, void 0, false);
          } else {
            childBlock = children[0].codegenNode;
            if (isTemplate && keyProperty) {
              injectProp(childBlock, keyProperty, context);
            }
            if (childBlock.isBlock !== !isStableFragment) {
              if (childBlock.isBlock) {
                removeHelper(OPEN_BLOCK);
                removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            childBlock.isBlock = !isStableFragment;
            if (childBlock.isBlock) {
              helper(OPEN_BLOCK);
              helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
            } else {
              helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
            }
          }
          if (memo) {
            const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
              createSimpleExpression(`_cached`)
            ]));
            loop.body = createBlockStatement([
              createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
              createCompoundExpression([
                `if (_cached`,
                ...keyExp ? [` && _cached.key === `, keyExp] : [],
                ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
              ]),
              createCompoundExpression([`const _item = `, childBlock]),
              createSimpleExpression(`_item.memo = _memo`),
              createSimpleExpression(`return _item`)
            ]);
            renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
          } else {
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
          }
        };
      });
    });
    function processFor(node, dir, context, processCodegen) {
      if (!dir.exp) {
        context.onError(createCompilerError(31, dir.loc));
        return;
      }
      const parseResult = parseForExpression(dir.exp, context);
      if (!parseResult) {
        context.onError(createCompilerError(32, dir.loc));
        return;
      }
      const { addIdentifiers, removeIdentifiers, scopes } = context;
      const { source, value, key, index } = parseResult;
      const forNode = {
        type: 11,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: isTemplateNode(node) ? node.children : [node]
      };
      context.replaceNode(forNode);
      scopes.vFor++;
      if (context.prefixIdentifiers) {
        value && addIdentifiers(value);
        key && addIdentifiers(key);
        index && addIdentifiers(index);
      }
      const onExit = processCodegen && processCodegen(forNode);
      return () => {
        scopes.vFor--;
        if (context.prefixIdentifiers) {
          value && removeIdentifiers(value);
          key && removeIdentifiers(key);
          index && removeIdentifiers(index);
        }
        if (onExit)
          onExit();
      };
    }
    var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    var stripParensRE = /^\(|\)$/g;
    function parseForExpression(input, context) {
      const loc = input.loc;
      const exp = input.content;
      const inMatch = exp.match(forAliasRE);
      if (!inMatch)
        return;
      const [, LHS, RHS] = inMatch;
      const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: void 0,
        key: void 0,
        index: void 0
      };
      if (context.prefixIdentifiers) {
        result.source = processExpression(result.source, context);
      }
      let valueContent = LHS.trim().replace(stripParensRE, "").trim();
      const trimmedOffset = LHS.indexOf(valueContent);
      const iteratorMatch = valueContent.match(forIteratorRE);
      if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, "").trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
          keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
          result.key = createAliasExpression(loc, keyContent, keyOffset);
          if (context.prefixIdentifiers) {
            result.key = processExpression(result.key, context, true);
          }
        }
        if (iteratorMatch[2]) {
          const indexContent = iteratorMatch[2].trim();
          if (indexContent) {
            result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
            if (context.prefixIdentifiers) {
              result.index = processExpression(result.index, context, true);
            }
          }
        }
      }
      if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
        if (context.prefixIdentifiers) {
          result.value = processExpression(result.value, context, true);
        }
      }
      return result;
    }
    function createAliasExpression(range, content, offset) {
      return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
    }
    function createForLoopParams({ value, key, index }, memoArgs = []) {
      return createParamsList([value, key, index, ...memoArgs]);
    }
    function createParamsList(args) {
      let i = args.length;
      while (i--) {
        if (args[i])
          break;
      }
      return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
    }
    var defaultFallback = createSimpleExpression(`undefined`, false);
    var trackSlotScopes = (node, context) => {
      if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
        const vSlot = findDir(node, "slot");
        if (vSlot) {
          const slotProps = vSlot.exp;
          if (context.prefixIdentifiers) {
            slotProps && context.addIdentifiers(slotProps);
          }
          context.scopes.vSlot++;
          return () => {
            if (context.prefixIdentifiers) {
              slotProps && context.removeIdentifiers(slotProps);
            }
            context.scopes.vSlot--;
          };
        }
      }
    };
    var trackVForSlotScopes = (node, context) => {
      let vFor;
      if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, "for"))) {
        const result = vFor.parseResult = parseForExpression(vFor.exp, context);
        if (result) {
          const { value, key, index } = result;
          const { addIdentifiers, removeIdentifiers } = context;
          value && addIdentifiers(value);
          key && addIdentifiers(key);
          index && addIdentifiers(index);
          return () => {
            value && removeIdentifiers(value);
            key && removeIdentifiers(key);
            index && removeIdentifiers(index);
          };
        }
      }
    };
    var buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false, true, children.length ? children[0].loc : loc);
    function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
      context.helper(WITH_CTX);
      const { children, loc } = node;
      const slotsProperties = [];
      const dynamicSlots = [];
      let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
      if (!context.ssr && context.prefixIdentifiers) {
        hasDynamicSlots = hasScopeRef(node, context.identifiers);
      }
      const onComponentSlot = findDir(node, "slot", true);
      if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        if (arg && !isStaticExp(arg)) {
          hasDynamicSlots = true;
        }
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
      }
      let hasTemplateSlots = false;
      let hasNamedDefaultSlot = false;
      const implicitDefaultChildren = [];
      const seenSlotNames = /* @__PURE__ */ new Set();
      for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
          if (slotElement.type !== 3) {
            implicitDefaultChildren.push(slotElement);
          }
          continue;
        }
        if (onComponentSlot) {
          context.onError(createCompilerError(37, slotDir.loc));
          break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        let staticSlotName;
        if (isStaticExp(slotName)) {
          staticSlotName = slotName ? slotName.content : `default`;
        } else {
          hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        let vIf;
        let vElse;
        let vFor;
        if (vIf = findDir(slotElement, "if")) {
          hasDynamicSlots = true;
          dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
          let j = i;
          let prev;
          while (j--) {
            prev = children[j];
            if (prev.type !== 3) {
              break;
            }
          }
          if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
            children.splice(i, 1);
            i--;
            let conditional = dynamicSlots[dynamicSlots.length - 1];
            while (conditional.alternate.type === 19) {
              conditional = conditional.alternate;
            }
            conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
          } else {
            context.onError(createCompilerError(30, vElse.loc));
          }
        } else if (vFor = findDir(slotElement, "for")) {
          hasDynamicSlots = true;
          const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
          if (parseResult) {
            dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
              parseResult.source,
              createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
            ]));
          } else {
            context.onError(createCompilerError(32, vFor.loc));
          }
        } else {
          if (staticSlotName) {
            if (seenSlotNames.has(staticSlotName)) {
              context.onError(createCompilerError(38, dirLoc));
              continue;
            }
            seenSlotNames.add(staticSlotName);
            if (staticSlotName === "default") {
              hasNamedDefaultSlot = true;
            }
          }
          slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
      }
      if (!onComponentSlot) {
        const buildDefaultSlotProperty = (props, children2) => {
          const fn = buildSlotFn(props, children2, loc);
          if (context.compatConfig) {
            fn.isNonScopedSlot = true;
          }
          return createObjectProperty(`default`, fn);
        };
        if (!hasTemplateSlots) {
          slotsProperties.push(buildDefaultSlotProperty(void 0, children));
        } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
          if (hasNamedDefaultSlot) {
            context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
          } else {
            slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
          }
        }
      }
      const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
      let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + ``, false))), loc);
      if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
          slots,
          createArrayExpression(dynamicSlots)
        ]);
      }
      return {
        slots,
        hasDynamicSlots
      };
    }
    function buildDynamicSlot(name, fn) {
      return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
      ]);
    }
    function hasForwardedSlots(children) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        switch (child.type) {
          case 1:
            if (child.tagType === 2 || hasForwardedSlots(child.children)) {
              return true;
            }
            break;
          case 9:
            if (hasForwardedSlots(child.branches))
              return true;
            break;
          case 10:
          case 11:
            if (hasForwardedSlots(child.children))
              return true;
            break;
        }
      }
      return false;
    }
    function isNonWhitespaceContent(node) {
      if (node.type !== 2 && node.type !== 12)
        return true;
      return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
    }
    var directiveImportMap = /* @__PURE__ */ new WeakMap();
    var transformElement = (node, context) => {
      return function postTransformElement() {
        node = context.currentNode;
        if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
          return;
        }
        const { tag, props } = node;
        const isComponent2 = node.tagType === 1;
        let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
        const isDynamicComponent = shared.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject");
        if (props.length > 0) {
          const propsBuildResult = buildProps(node, context);
          vnodeProps = propsBuildResult.props;
          patchFlag = propsBuildResult.patchFlag;
          dynamicPropNames = propsBuildResult.dynamicPropNames;
          const directives = propsBuildResult.directives;
          vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
          if (propsBuildResult.shouldUseBlock) {
            shouldUseBlock = true;
          }
        }
        if (node.children.length > 0) {
          if (vnodeTag === KEEP_ALIVE) {
            shouldUseBlock = true;
            patchFlag |= 1024;
          }
          const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
          if (shouldBuildAsSlots) {
            const { slots, hasDynamicSlots } = buildSlots(node, context);
            vnodeChildren = slots;
            if (hasDynamicSlots) {
              patchFlag |= 1024;
            }
          } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
            const child = node.children[0];
            const type = child.type;
            const hasDynamicTextChild = type === 5 || type === 8;
            if (hasDynamicTextChild && getConstantType(child, context) === 0) {
              patchFlag |= 1;
            }
            if (hasDynamicTextChild || type === 2) {
              vnodeChildren = child;
            } else {
              vnodeChildren = node.children;
            }
          } else {
            vnodeChildren = node.children;
          }
        }
        if (patchFlag !== 0) {
          {
            vnodePatchFlag = String(patchFlag);
          }
          if (dynamicPropNames && dynamicPropNames.length) {
            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
          }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
      };
    };
    function resolveComponentType(node, context, ssr = false) {
      let { tag } = node;
      const isExplicitDynamic = isComponentTag(tag);
      const isProp = findProp(node, "is");
      if (isProp) {
        if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
          const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
          if (exp) {
            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
              exp
            ]);
          }
        } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
          tag = isProp.value.content.slice(4);
        }
      }
      const isDir = !isExplicitDynamic && findDir(node, "is");
      if (isDir && isDir.exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
          isDir.exp
        ]);
      }
      const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
      if (builtIn) {
        if (!ssr)
          context.helper(builtIn);
        return builtIn;
      }
      {
        const fromSetup = resolveSetupReference(tag, context);
        if (fromSetup) {
          return fromSetup;
        }
        const dotIndex = tag.indexOf(".");
        if (dotIndex > 0) {
          const ns = resolveSetupReference(tag.slice(0, dotIndex), context);
          if (ns) {
            return ns + tag.slice(dotIndex);
          }
        }
      }
      if (context.selfName && shared.capitalize(shared.camelize(tag)) === context.selfName) {
        context.helper(RESOLVE_COMPONENT);
        context.components.add(tag + `__self`);
        return toValidAssetId(tag, `component`);
      }
      context.helper(RESOLVE_COMPONENT);
      context.components.add(tag);
      return toValidAssetId(tag, `component`);
    }
    function resolveSetupReference(name, context) {
      const bindings = context.bindingMetadata;
      if (!bindings || bindings.__isScriptSetup === false) {
        return;
      }
      const camelName = shared.camelize(name);
      const PascalName = shared.capitalize(camelName);
      const checkType = (type) => {
        if (bindings[name] === type) {
          return name;
        }
        if (bindings[camelName] === type) {
          return camelName;
        }
        if (bindings[PascalName] === type) {
          return PascalName;
        }
      };
      const fromConst = checkType("setup-const");
      if (fromConst) {
        return context.inline ? fromConst : `$setup[${JSON.stringify(fromConst)}]`;
      }
      const fromMaybeRef = checkType("setup-let") || checkType("setup-ref") || checkType("setup-maybe-ref");
      if (fromMaybeRef) {
        return context.inline ? `${context.helperString(UNREF)}(${fromMaybeRef})` : `$setup[${JSON.stringify(fromMaybeRef)}]`;
      }
    }
    function buildProps(node, context, props = node.props, ssr = false) {
      const { tag, loc: elementLoc, children } = node;
      const isComponent2 = node.tagType === 1;
      let properties = [];
      const mergeArgs = [];
      const runtimeDirectives = [];
      const hasChildren = children.length > 0;
      let shouldUseBlock = false;
      let patchFlag = 0;
      let hasRef = false;
      let hasClassBinding = false;
      let hasStyleBinding = false;
      let hasHydrationEventBinding = false;
      let hasDynamicKeys = false;
      let hasVnodeHook = false;
      const dynamicPropNames = [];
      const analyzePatchFlag = ({ key, value }) => {
        if (isStaticExp(key)) {
          const name = key.content;
          const isEventHandler = shared.isOn(name);
          if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !shared.isReservedProp(name)) {
            hasHydrationEventBinding = true;
          }
          if (isEventHandler && shared.isReservedProp(name)) {
            hasVnodeHook = true;
          }
          if (value.type === 20 || (value.type === 4 || value.type === 8) && getConstantType(value, context) > 0) {
            return;
          }
          if (name === "ref") {
            hasRef = true;
          } else if (name === "class") {
            hasClassBinding = true;
          } else if (name === "style") {
            hasStyleBinding = true;
          } else if (name !== "key" && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
          if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
            dynamicPropNames.push(name);
          }
        } else {
          hasDynamicKeys = true;
        }
      };
      for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        if (prop.type === 6) {
          const { loc, name, value } = prop;
          let isStatic = true;
          if (name === "ref") {
            hasRef = true;
            if (context.scopes.vFor > 0) {
              properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
            }
            if (value && context.inline && context.bindingMetadata[value.content]) {
              isStatic = false;
              properties.push(createObjectProperty(createSimpleExpression("ref_key", true), createSimpleExpression(value.content, true, value.loc)));
            }
          }
          if (name === "is" && (isComponentTag(tag) || value && value.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
            continue;
          }
          properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : "", isStatic, value ? value.loc : loc)));
        } else {
          const { name, arg, exp, loc } = prop;
          const isVBind = name === "bind";
          const isVOn = name === "on";
          if (name === "slot") {
            if (!isComponent2) {
              context.onError(createCompilerError(40, loc));
            }
            continue;
          }
          if (name === "once" || name === "memo") {
            continue;
          }
          if (name === "is" || isVBind && isStaticArgOf(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
            continue;
          }
          if (isVOn && ssr) {
            continue;
          }
          if (isVBind && isStaticArgOf(arg, "key") || isVOn && hasChildren && isStaticArgOf(arg, "vue:before-update")) {
            shouldUseBlock = true;
          }
          if (isVBind && isStaticArgOf(arg, "ref") && context.scopes.vFor > 0) {
            properties.push(createObjectProperty(createSimpleExpression("ref_for", true), createSimpleExpression("true")));
          }
          if (!arg && (isVBind || isVOn)) {
            hasDynamicKeys = true;
            if (exp) {
              if (properties.length) {
                mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                properties = [];
              }
              if (isVBind) {
                {
                  if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                    mergeArgs.unshift(exp);
                    continue;
                  }
                }
                mergeArgs.push(exp);
              } else {
                mergeArgs.push({
                  type: 14,
                  loc,
                  callee: context.helper(TO_HANDLERS),
                  arguments: [exp]
                });
              }
            } else {
              context.onError(createCompilerError(isVBind ? 34 : 35, loc));
            }
            continue;
          }
          const directiveTransform = context.directiveTransforms[name];
          if (directiveTransform) {
            const { props: props2, needRuntime } = directiveTransform(prop, node, context);
            !ssr && props2.forEach(analyzePatchFlag);
            properties.push(...props2);
            if (needRuntime) {
              runtimeDirectives.push(prop);
              if (shared.isSymbol(needRuntime)) {
                directiveImportMap.set(prop, needRuntime);
              }
            }
          } else if (!shared.isBuiltInDirective(name)) {
            runtimeDirectives.push(prop);
            if (hasChildren) {
              shouldUseBlock = true;
            }
          }
        }
      }
      let propsExpression = void 0;
      if (mergeArgs.length) {
        if (properties.length) {
          mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
          propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        } else {
          propsExpression = mergeArgs[0];
        }
      } else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
      }
      if (hasDynamicKeys) {
        patchFlag |= 16;
      } else {
        if (hasClassBinding && !isComponent2) {
          patchFlag |= 2;
        }
        if (hasStyleBinding && !isComponent2) {
          patchFlag |= 4;
        }
        if (dynamicPropNames.length) {
          patchFlag |= 8;
        }
        if (hasHydrationEventBinding) {
          patchFlag |= 32;
        }
      }
      if (!shouldUseBlock && (patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
        patchFlag |= 512;
      }
      if (!context.inSSR && propsExpression) {
        switch (propsExpression.type) {
          case 15:
            let classKeyIndex = -1;
            let styleKeyIndex = -1;
            let hasDynamicKey = false;
            for (let i = 0; i < propsExpression.properties.length; i++) {
              const key = propsExpression.properties[i].key;
              if (isStaticExp(key)) {
                if (key.content === "class") {
                  classKeyIndex = i;
                } else if (key.content === "style") {
                  styleKeyIndex = i;
                }
              } else if (!key.isHandlerKey) {
                hasDynamicKey = true;
              }
            }
            const classProp = propsExpression.properties[classKeyIndex];
            const styleProp = propsExpression.properties[styleKeyIndex];
            if (!hasDynamicKey) {
              if (classProp && !isStaticExp(classProp.value)) {
                classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
              }
              if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
                styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
              }
            } else {
              propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
            }
            break;
          case 14:
            break;
          default:
            propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
              createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
                propsExpression
              ])
            ]);
            break;
        }
      }
      return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames,
        shouldUseBlock
      };
    }
    function dedupeProperties(properties) {
      const knownProps = /* @__PURE__ */ new Map();
      const deduped = [];
      for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        if (prop.key.type === 8 || !prop.key.isStatic) {
          deduped.push(prop);
          continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
          if (name === "style" || name === "class" || shared.isOn(name)) {
            mergeAsArray(existing, prop);
          }
        } else {
          knownProps.set(name, prop);
          deduped.push(prop);
        }
      }
      return deduped;
    }
    function mergeAsArray(existing, incoming) {
      if (existing.value.type === 17) {
        existing.value.elements.push(incoming.value);
      } else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
      }
    }
    function buildDirectiveArgs(dir, context) {
      const dirArgs = [];
      const runtime = directiveImportMap.get(dir);
      if (runtime) {
        dirArgs.push(context.helperString(runtime));
      } else {
        const fromSetup = resolveSetupReference("v-" + dir.name, context);
        if (fromSetup) {
          dirArgs.push(fromSetup);
        } else {
          context.helper(RESOLVE_DIRECTIVE);
          context.directives.add(dir.name);
          dirArgs.push(toValidAssetId(dir.name, `directive`));
        }
      }
      const { loc } = dir;
      if (dir.exp)
        dirArgs.push(dir.exp);
      if (dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
      }
      if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
          if (!dir.exp) {
            dirArgs.push(`void 0`);
          }
          dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
      }
      return createArrayExpression(dirArgs, dir.loc);
    }
    function stringifyDynamicPropNames(props) {
      let propsNamesString = `[`;
      for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
          propsNamesString += ", ";
      }
      return propsNamesString + `]`;
    }
    function isComponentTag(tag) {
      return tag === "component" || tag === "Component";
    }
    var cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    var camelizeRE = /-(\w)/g;
    var camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    var transformSlotOutlet = (node, context) => {
      if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
          context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
          slotName,
          "{}",
          "undefined",
          "true"
        ];
        let expectedLen = 2;
        if (slotProps) {
          slotArgs[2] = slotProps;
          expectedLen = 3;
        }
        if (children.length) {
          slotArgs[3] = createFunctionExpression([], children, false, false, loc);
          expectedLen = 4;
        }
        if (context.scopeId && !context.slotted) {
          expectedLen = 5;
        }
        slotArgs.splice(expectedLen);
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
      }
    };
    function processSlotOutlet(node, context) {
      let slotName = `"default"`;
      let slotProps = void 0;
      const nonNameProps = [];
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          if (p.value) {
            if (p.name === "name") {
              slotName = JSON.stringify(p.value.content);
            } else {
              p.name = camelize(p.name);
              nonNameProps.push(p);
            }
          }
        } else {
          if (p.name === "bind" && isStaticArgOf(p.arg, "name")) {
            if (p.exp)
              slotName = p.exp;
          } else {
            if (p.name === "bind" && p.arg && isStaticExp(p.arg)) {
              p.arg.content = camelize(p.arg.content);
            }
            nonNameProps.push(p);
          }
        }
      }
      if (nonNameProps.length > 0) {
        const { props, directives } = buildProps(node, context, nonNameProps);
        slotProps = props;
        if (directives.length) {
          context.onError(createCompilerError(36, directives[0].loc));
        }
      }
      return {
        slotName,
        slotProps
      };
    }
    var fnExpRE = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;
    var transformOn = (dir, node, context, augmentor) => {
      const { loc, modifiers, arg } = dir;
      if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(35, loc));
      }
      let eventName;
      if (arg.type === 4) {
        if (arg.isStatic) {
          let rawName = arg.content;
          if (rawName.startsWith("vue:")) {
            rawName = `vnode-${rawName.slice(4)}`;
          }
          eventName = createSimpleExpression(shared.toHandlerKey(shared.camelize(rawName)), true, arg.loc);
        } else {
          eventName = createCompoundExpression([
            `${context.helperString(TO_HANDLER_KEY)}(`,
            arg,
            `)`
          ]);
        }
      } else {
        eventName = arg;
        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
        eventName.children.push(`)`);
      }
      let exp = dir.exp;
      if (exp && !exp.content.trim()) {
        exp = void 0;
      }
      let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
      if (exp) {
        const isMemberExp = isMemberExpression(exp.content, context);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (context.prefixIdentifiers) {
          isInlineStatement && context.addIdentifiers(`$event`);
          exp = dir.exp = processExpression(exp, context, false, hasMultipleStatements);
          isInlineStatement && context.removeIdentifiers(`$event`);
          shouldCache = context.cacheHandlers && !context.inVOnce && !(exp.type === 4 && exp.constType > 0) && !(isMemberExp && node.tagType === 1) && !hasScopeRef(exp, context.identifiers);
          if (shouldCache && isMemberExp) {
            if (exp.type === 4) {
              exp.content = `${exp.content} && ${exp.content}(...args)`;
            } else {
              exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];
            }
          }
        }
        if (isInlineStatement || shouldCache && isMemberExp) {
          exp = createCompoundExpression([
            `${isInlineStatement ? context.isTS ? `($event: any)` : `$event` : `${context.isTS ? `
//@ts-ignore
` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
            exp,
            hasMultipleStatements ? `}` : `)`
          ]);
        }
      }
      let ret = {
        props: [
          createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
      };
      if (augmentor) {
        ret = augmentor(ret);
      }
      if (shouldCache) {
        ret.props[0].value = context.cache(ret.props[0].value);
      }
      ret.props.forEach((p) => p.key.isHandlerKey = true);
      return ret;
    };
    var transformBind = (dir, _node, context) => {
      const { exp, modifiers, loc } = dir;
      const arg = dir.arg;
      if (arg.type !== 4) {
        arg.children.unshift(`(`);
        arg.children.push(`) || ""`);
      } else if (!arg.isStatic) {
        arg.content = `${arg.content} || ""`;
      }
      if (modifiers.includes("camel")) {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = shared.camelize(arg.content);
          } else {
            arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
          }
        } else {
          arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
          arg.children.push(`)`);
        }
      }
      if (!context.inSSR) {
        if (modifiers.includes("prop")) {
          injectPrefix(arg, ".");
        }
        if (modifiers.includes("attr")) {
          injectPrefix(arg, "^");
        }
      }
      if (!exp || exp.type === 4 && !exp.content.trim()) {
        context.onError(createCompilerError(34, loc));
        return {
          props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
        };
      }
      return {
        props: [createObjectProperty(arg, exp)]
      };
    };
    var injectPrefix = (arg, prefix) => {
      if (arg.type === 4) {
        if (arg.isStatic) {
          arg.content = prefix + arg.content;
        } else {
          arg.content = `\`${prefix}\${${arg.content}}\``;
        }
      } else {
        arg.children.unshift(`'${prefix}' + (`);
        arg.children.push(`)`);
      }
    };
    var transformText = (node, context) => {
      if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
        return () => {
          const children = node.children;
          let currentContainer = void 0;
          let hasText = false;
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child)) {
              hasText = true;
              for (let j = i + 1; j < children.length; j++) {
                const next = children[j];
                if (isText(next)) {
                  if (!currentContainer) {
                    currentContainer = children[i] = {
                      type: 8,
                      loc: child.loc,
                      children: [child]
                    };
                  }
                  currentContainer.children.push(` + `, next);
                  children.splice(j, 1);
                  j--;
                } else {
                  currentContainer = void 0;
                  break;
                }
              }
            }
          }
          if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p) => p.type === 7 && !context.directiveTransforms[p.name]) && !(node.tag === "template"))) {
            return;
          }
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (isText(child) || child.type === 8) {
              const callArgs = [];
              if (child.type !== 2 || child.content !== " ") {
                callArgs.push(child);
              }
              if (!context.ssr && getConstantType(child, context) === 0) {
                callArgs.push(1 + ``);
              }
              children[i] = {
                type: 12,
                content: child,
                loc: child.loc,
                codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
              };
            }
          }
        };
      }
    };
    var seen = /* @__PURE__ */ new WeakSet();
    var transformOnce = (node, context) => {
      if (node.type === 1 && findDir(node, "once", true)) {
        if (seen.has(node) || context.inVOnce) {
          return;
        }
        seen.add(node);
        context.inVOnce = true;
        context.helper(SET_BLOCK_TRACKING);
        return () => {
          context.inVOnce = false;
          const cur = context.currentNode;
          if (cur.codegenNode) {
            cur.codegenNode = context.cache(cur.codegenNode, true);
          }
        };
      }
    };
    var transformModel = (dir, node, context) => {
      const { exp, arg } = dir;
      if (!exp) {
        context.onError(createCompilerError(41, dir.loc));
        return createTransformProps();
      }
      const rawExp = exp.loc.source;
      const expString = exp.type === 4 ? exp.content : rawExp;
      const bindingType = context.bindingMetadata[rawExp];
      const maybeRef = context.inline && bindingType && bindingType !== "setup-const";
      if (!expString.trim() || !isMemberExpression(expString, context) && !maybeRef) {
        context.onError(createCompilerError(42, exp.loc));
        return createTransformProps();
      }
      if (context.prefixIdentifiers && isSimpleIdentifier(expString) && context.identifiers[expString]) {
        context.onError(createCompilerError(43, exp.loc));
        return createTransformProps();
      }
      const propName = arg ? arg : createSimpleExpression("modelValue", true);
      const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
      let assignmentExp;
      const eventArg = context.isTS ? `($event: any)` : `$event`;
      if (maybeRef) {
        if (bindingType === "setup-ref") {
          assignmentExp = createCompoundExpression([
            `${eventArg} => ((`,
            createSimpleExpression(rawExp, false, exp.loc),
            `).value = $event)`
          ]);
        } else {
          const altAssignment = bindingType === "setup-let" ? `${rawExp} = $event` : `null`;
          assignmentExp = createCompoundExpression([
            `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,
            createSimpleExpression(rawExp, false, exp.loc),
            `).value = $event : ${altAssignment})`
          ]);
        }
      } else {
        assignmentExp = createCompoundExpression([
          `${eventArg} => ((`,
          exp,
          `) = $event)`
        ]);
      }
      const props = [
        createObjectProperty(propName, dir.exp),
        createObjectProperty(eventName, assignmentExp)
      ];
      if (context.prefixIdentifiers && !context.inVOnce && context.cacheHandlers && !hasScopeRef(exp, context.identifiers)) {
        props[1].value = context.cache(props[1].value);
      }
      if (dir.modifiers.length && node.tagType === 1) {
        const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
        const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
      }
      return createTransformProps(props);
    };
    function createTransformProps(props = []) {
      return { props };
    }
    var validDivisionCharRE = /[\w).+\-_$\]]/;
    var transformFilter = (node, context) => {
      if (!isCompatEnabled("COMPILER_FILTER", context)) {
        return;
      }
      if (node.type === 5) {
        rewriteFilter(node.content, context);
      }
      if (node.type === 1) {
        node.props.forEach((prop) => {
          if (prop.type === 7 && prop.name !== "for" && prop.exp) {
            rewriteFilter(prop.exp, context);
          }
        });
      }
    };
    function rewriteFilter(node, context) {
      if (node.type === 4) {
        parseFilter(node, context);
      } else {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (typeof child !== "object")
            continue;
          if (child.type === 4) {
            parseFilter(child, context);
          } else if (child.type === 8) {
            rewriteFilter(node, context);
          } else if (child.type === 5) {
            rewriteFilter(child.content, context);
          }
        }
      }
    }
    function parseFilter(node, context) {
      const exp = node.content;
      let inSingle = false;
      let inDouble = false;
      let inTemplateString = false;
      let inRegex = false;
      let curly = 0;
      let square = 0;
      let paren = 0;
      let lastFilterIndex = 0;
      let c, prev, i, expression, filters = [];
      for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
          if (c === 39 && prev !== 92)
            inSingle = false;
        } else if (inDouble) {
          if (c === 34 && prev !== 92)
            inDouble = false;
        } else if (inTemplateString) {
          if (c === 96 && prev !== 92)
            inTemplateString = false;
        } else if (inRegex) {
          if (c === 47 && prev !== 92)
            inRegex = false;
        } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
          if (expression === void 0) {
            lastFilterIndex = i + 1;
            expression = exp.slice(0, i).trim();
          } else {
            pushFilter();
          }
        } else {
          switch (c) {
            case 34:
              inDouble = true;
              break;
            case 39:
              inSingle = true;
              break;
            case 96:
              inTemplateString = true;
              break;
            case 40:
              paren++;
              break;
            case 41:
              paren--;
              break;
            case 91:
              square++;
              break;
            case 93:
              square--;
              break;
            case 123:
              curly++;
              break;
            case 125:
              curly--;
              break;
          }
          if (c === 47) {
            let j = i - 1;
            let p;
            for (; j >= 0; j--) {
              p = exp.charAt(j);
              if (p !== " ")
                break;
            }
            if (!p || !validDivisionCharRE.test(p)) {
              inRegex = true;
            }
          }
        }
      }
      if (expression === void 0) {
        expression = exp.slice(0, i).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }
      function pushFilter() {
        filters.push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
      }
      if (filters.length) {
        for (i = 0; i < filters.length; i++) {
          expression = wrapFilter(expression, filters[i], context);
        }
        node.content = expression;
      }
    }
    function wrapFilter(exp, filter, context) {
      context.helper(RESOLVE_FILTER);
      const i = filter.indexOf("(");
      if (i < 0) {
        context.filters.add(filter);
        return `${toValidAssetId(filter, "filter")}(${exp})`;
      } else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        context.filters.add(name);
        return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
      }
    }
    var seen$1 = /* @__PURE__ */ new WeakSet();
    var transformMemo = (node, context) => {
      if (node.type === 1) {
        const dir = findDir(node, "memo");
        if (!dir || seen$1.has(node)) {
          return;
        }
        seen$1.add(node);
        return () => {
          const codegenNode = node.codegenNode || context.currentNode.codegenNode;
          if (codegenNode && codegenNode.type === 13) {
            if (node.tagType !== 1) {
              makeBlock(codegenNode, context);
            }
            node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
              dir.exp,
              createFunctionExpression(void 0, codegenNode),
              `_cache`,
              String(context.cached++)
            ]);
          }
        };
      }
    };
    function getBaseTransformPreset(prefixIdentifiers) {
      return [
        [
          transformOnce,
          transformIf,
          transformMemo,
          transformFor,
          ...[transformFilter],
          ...prefixIdentifiers ? [
            trackVForSlotScopes,
            transformExpression
          ] : [],
          transformSlotOutlet,
          transformElement,
          trackSlotScopes,
          transformText
        ],
        {
          on: transformOn,
          bind: transformBind,
          model: transformModel
        }
      ];
    }
    function baseCompile(template, options = {}) {
      const onError = options.onError || defaultOnError;
      const isModuleMode = options.mode === "module";
      const prefixIdentifiers = options.prefixIdentifiers === true || isModuleMode;
      if (!prefixIdentifiers && options.cacheHandlers) {
        onError(createCompilerError(48));
      }
      if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(49));
      }
      const ast = shared.isString(template) ? baseParse(template, options) : template;
      const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);
      if (options.isTS) {
        const { expressionPlugins } = options;
        if (!expressionPlugins || !expressionPlugins.includes("typescript")) {
          options.expressionPlugins = [...expressionPlugins || [], "typescript"];
        }
      }
      transform(ast, shared.extend({}, options, {
        prefixIdentifiers,
        nodeTransforms: [
          ...nodeTransforms,
          ...options.nodeTransforms || []
        ],
        directiveTransforms: shared.extend({}, directiveTransforms, options.directiveTransforms || {})
      }));
      return generate(ast, shared.extend({}, options, {
        prefixIdentifiers
      }));
    }
    var noopDirectiveTransform = () => ({ props: [] });
    exports2.generateCodeFrame = shared.generateCodeFrame;
    exports2.BASE_TRANSITION = BASE_TRANSITION;
    exports2.CAMELIZE = CAMELIZE;
    exports2.CAPITALIZE = CAPITALIZE;
    exports2.CREATE_BLOCK = CREATE_BLOCK;
    exports2.CREATE_COMMENT = CREATE_COMMENT;
    exports2.CREATE_ELEMENT_BLOCK = CREATE_ELEMENT_BLOCK;
    exports2.CREATE_ELEMENT_VNODE = CREATE_ELEMENT_VNODE;
    exports2.CREATE_SLOTS = CREATE_SLOTS;
    exports2.CREATE_STATIC = CREATE_STATIC;
    exports2.CREATE_TEXT = CREATE_TEXT;
    exports2.CREATE_VNODE = CREATE_VNODE;
    exports2.FRAGMENT = FRAGMENT;
    exports2.GUARD_REACTIVE_PROPS = GUARD_REACTIVE_PROPS;
    exports2.IS_MEMO_SAME = IS_MEMO_SAME;
    exports2.IS_REF = IS_REF;
    exports2.KEEP_ALIVE = KEEP_ALIVE;
    exports2.MERGE_PROPS = MERGE_PROPS;
    exports2.NORMALIZE_CLASS = NORMALIZE_CLASS;
    exports2.NORMALIZE_PROPS = NORMALIZE_PROPS;
    exports2.NORMALIZE_STYLE = NORMALIZE_STYLE;
    exports2.OPEN_BLOCK = OPEN_BLOCK;
    exports2.POP_SCOPE_ID = POP_SCOPE_ID;
    exports2.PUSH_SCOPE_ID = PUSH_SCOPE_ID;
    exports2.RENDER_LIST = RENDER_LIST;
    exports2.RENDER_SLOT = RENDER_SLOT;
    exports2.RESOLVE_COMPONENT = RESOLVE_COMPONENT;
    exports2.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;
    exports2.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;
    exports2.RESOLVE_FILTER = RESOLVE_FILTER;
    exports2.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;
    exports2.SUSPENSE = SUSPENSE;
    exports2.TELEPORT = TELEPORT;
    exports2.TO_DISPLAY_STRING = TO_DISPLAY_STRING;
    exports2.TO_HANDLERS = TO_HANDLERS;
    exports2.TO_HANDLER_KEY = TO_HANDLER_KEY;
    exports2.UNREF = UNREF;
    exports2.WITH_CTX = WITH_CTX;
    exports2.WITH_DIRECTIVES = WITH_DIRECTIVES;
    exports2.WITH_MEMO = WITH_MEMO;
    exports2.advancePositionWithClone = advancePositionWithClone;
    exports2.advancePositionWithMutation = advancePositionWithMutation;
    exports2.assert = assert;
    exports2.baseCompile = baseCompile;
    exports2.baseParse = baseParse;
    exports2.buildDirectiveArgs = buildDirectiveArgs;
    exports2.buildProps = buildProps;
    exports2.buildSlots = buildSlots;
    exports2.checkCompatEnabled = checkCompatEnabled;
    exports2.createArrayExpression = createArrayExpression;
    exports2.createAssignmentExpression = createAssignmentExpression;
    exports2.createBlockStatement = createBlockStatement;
    exports2.createCacheExpression = createCacheExpression;
    exports2.createCallExpression = createCallExpression;
    exports2.createCompilerError = createCompilerError;
    exports2.createCompoundExpression = createCompoundExpression;
    exports2.createConditionalExpression = createConditionalExpression;
    exports2.createForLoopParams = createForLoopParams;
    exports2.createFunctionExpression = createFunctionExpression;
    exports2.createIfStatement = createIfStatement;
    exports2.createInterpolation = createInterpolation;
    exports2.createObjectExpression = createObjectExpression;
    exports2.createObjectProperty = createObjectProperty;
    exports2.createReturnStatement = createReturnStatement;
    exports2.createRoot = createRoot;
    exports2.createSequenceExpression = createSequenceExpression;
    exports2.createSimpleExpression = createSimpleExpression;
    exports2.createStructuralDirectiveTransform = createStructuralDirectiveTransform;
    exports2.createTemplateLiteral = createTemplateLiteral;
    exports2.createTransformContext = createTransformContext;
    exports2.createVNodeCall = createVNodeCall;
    exports2.extractIdentifiers = extractIdentifiers;
    exports2.findDir = findDir;
    exports2.findProp = findProp;
    exports2.generate = generate;
    exports2.getBaseTransformPreset = getBaseTransformPreset;
    exports2.getInnerRange = getInnerRange;
    exports2.getMemoedVNodeCall = getMemoedVNodeCall;
    exports2.getVNodeBlockHelper = getVNodeBlockHelper;
    exports2.getVNodeHelper = getVNodeHelper;
    exports2.hasDynamicKeyVBind = hasDynamicKeyVBind;
    exports2.hasScopeRef = hasScopeRef;
    exports2.helperNameMap = helperNameMap;
    exports2.injectProp = injectProp;
    exports2.isBuiltInType = isBuiltInType;
    exports2.isCoreComponent = isCoreComponent;
    exports2.isFunctionType = isFunctionType;
    exports2.isInDestructureAssignment = isInDestructureAssignment;
    exports2.isMemberExpression = isMemberExpression;
    exports2.isMemberExpressionBrowser = isMemberExpressionBrowser;
    exports2.isMemberExpressionNode = isMemberExpressionNode;
    exports2.isReferencedIdentifier = isReferencedIdentifier;
    exports2.isSimpleIdentifier = isSimpleIdentifier;
    exports2.isSlotOutlet = isSlotOutlet;
    exports2.isStaticArgOf = isStaticArgOf;
    exports2.isStaticExp = isStaticExp;
    exports2.isStaticProperty = isStaticProperty;
    exports2.isStaticPropertyKey = isStaticPropertyKey;
    exports2.isTemplateNode = isTemplateNode;
    exports2.isText = isText;
    exports2.isVSlot = isVSlot;
    exports2.locStub = locStub;
    exports2.makeBlock = makeBlock;
    exports2.noopDirectiveTransform = noopDirectiveTransform;
    exports2.processExpression = processExpression;
    exports2.processFor = processFor;
    exports2.processIf = processIf;
    exports2.processSlotOutlet = processSlotOutlet;
    exports2.registerRuntimeHelpers = registerRuntimeHelpers;
    exports2.resolveComponentType = resolveComponentType;
    exports2.toValidAssetId = toValidAssetId;
    exports2.trackSlotScopes = trackSlotScopes;
    exports2.trackVForSlotScopes = trackVForSlotScopes;
    exports2.transform = transform;
    exports2.transformBind = transformBind;
    exports2.transformElement = transformElement;
    exports2.transformExpression = transformExpression;
    exports2.transformModel = transformModel;
    exports2.transformOn = transformOn;
    exports2.traverseNode = traverseNode;
    exports2.walkBlockDeclarations = walkBlockDeclarations;
    exports2.walkFunctionParams = walkFunctionParams;
    exports2.walkIdentifiers = walkIdentifiers;
    exports2.warnDeprecation = warnDeprecation;
  }
});

// ../../node_modules/.pnpm/@vue+compiler-core@3.2.31/node_modules/@vue/compiler-core/index.js
var require_compiler_core = __commonJS({
  "../../node_modules/.pnpm/@vue+compiler-core@3.2.31/node_modules/@vue/compiler-core/index.js"(exports2, module2) {
    "use strict";
    if (true) {
      module2.exports = require_compiler_core_cjs_prod();
    } else {
      module2.exports = null;
    }
  }
});

// ../../node_modules/.pnpm/@vue+compiler-dom@3.2.31/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.prod.js
var require_compiler_dom_cjs_prod = __commonJS({
  "../../node_modules/.pnpm/@vue+compiler-dom@3.2.31/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.prod.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var compilerCore = require_compiler_core();
    var shared = require_shared();
    var V_MODEL_RADIO = Symbol(``);
    var V_MODEL_CHECKBOX = Symbol(``);
    var V_MODEL_TEXT = Symbol(``);
    var V_MODEL_SELECT = Symbol(``);
    var V_MODEL_DYNAMIC = Symbol(``);
    var V_ON_WITH_MODIFIERS = Symbol(``);
    var V_ON_WITH_KEYS = Symbol(``);
    var V_SHOW = Symbol(``);
    var TRANSITION = Symbol(``);
    var TRANSITION_GROUP = Symbol(``);
    compilerCore.registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
    });
    var namedCharacterReferences = {
      GT: ">",
      gt: ">",
      LT: "<",
      lt: "<",
      "ac;": "\u223E",
      "af;": "\u2061",
      AMP: "&",
      amp: "&",
      "ap;": "\u2248",
      "DD;": "\u2145",
      "dd;": "\u2146",
      deg: "\xB0",
      "ee;": "\u2147",
      "eg;": "\u2A9A",
      "el;": "\u2A99",
      ETH: "\xD0",
      eth: "\xF0",
      "gE;": "\u2267",
      "ge;": "\u2265",
      "Gg;": "\u22D9",
      "gg;": "\u226B",
      "gl;": "\u2277",
      "GT;": ">",
      "Gt;": "\u226B",
      "gt;": ">",
      "ic;": "\u2063",
      "ii;": "\u2148",
      "Im;": "\u2111",
      "in;": "\u2208",
      "it;": "\u2062",
      "lE;": "\u2266",
      "le;": "\u2264",
      "lg;": "\u2276",
      "Ll;": "\u22D8",
      "ll;": "\u226A",
      "LT;": "<",
      "Lt;": "\u226A",
      "lt;": "<",
      "mp;": "\u2213",
      "Mu;": "\u039C",
      "mu;": "\u03BC",
      "ne;": "\u2260",
      "ni;": "\u220B",
      not: "\xAC",
      "Nu;": "\u039D",
      "nu;": "\u03BD",
      "Or;": "\u2A54",
      "or;": "\u2228",
      "oS;": "\u24C8",
      "Pi;": "\u03A0",
      "pi;": "\u03C0",
      "pm;": "\xB1",
      "Pr;": "\u2ABB",
      "pr;": "\u227A",
      "Re;": "\u211C",
      REG: "\xAE",
      reg: "\xAE",
      "rx;": "\u211E",
      "Sc;": "\u2ABC",
      "sc;": "\u227B",
      shy: "\xAD",
      uml: "\xA8",
      "wp;": "\u2118",
      "wr;": "\u2240",
      "Xi;": "\u039E",
      "xi;": "\u03BE",
      yen: "\xA5",
      "acd;": "\u223F",
      "acE;": "\u223E\u0333",
      "Acy;": "\u0410",
      "acy;": "\u0430",
      "Afr;": "\u{1D504}",
      "afr;": "\u{1D51E}",
      "AMP;": "&",
      "amp;": "&",
      "And;": "\u2A53",
      "and;": "\u2227",
      "ang;": "\u2220",
      "apE;": "\u2A70",
      "ape;": "\u224A",
      "ast;": "*",
      Auml: "\xC4",
      auml: "\xE4",
      "Bcy;": "\u0411",
      "bcy;": "\u0431",
      "Bfr;": "\u{1D505}",
      "bfr;": "\u{1D51F}",
      "bne;": "=\u20E5",
      "bot;": "\u22A5",
      "Cap;": "\u22D2",
      "cap;": "\u2229",
      cent: "\xA2",
      "Cfr;": "\u212D",
      "cfr;": "\u{1D520}",
      "Chi;": "\u03A7",
      "chi;": "\u03C7",
      "cir;": "\u25CB",
      COPY: "\xA9",
      copy: "\xA9",
      "Cup;": "\u22D3",
      "cup;": "\u222A",
      "Dcy;": "\u0414",
      "dcy;": "\u0434",
      "deg;": "\xB0",
      "Del;": "\u2207",
      "Dfr;": "\u{1D507}",
      "dfr;": "\u{1D521}",
      "die;": "\xA8",
      "div;": "\xF7",
      "Dot;": "\xA8",
      "dot;": "\u02D9",
      "Ecy;": "\u042D",
      "ecy;": "\u044D",
      "Efr;": "\u{1D508}",
      "efr;": "\u{1D522}",
      "egs;": "\u2A96",
      "ell;": "\u2113",
      "els;": "\u2A95",
      "ENG;": "\u014A",
      "eng;": "\u014B",
      "Eta;": "\u0397",
      "eta;": "\u03B7",
      "ETH;": "\xD0",
      "eth;": "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      "Fcy;": "\u0424",
      "fcy;": "\u0444",
      "Ffr;": "\u{1D509}",
      "ffr;": "\u{1D523}",
      "gap;": "\u2A86",
      "Gcy;": "\u0413",
      "gcy;": "\u0433",
      "gEl;": "\u2A8C",
      "gel;": "\u22DB",
      "geq;": "\u2265",
      "ges;": "\u2A7E",
      "Gfr;": "\u{1D50A}",
      "gfr;": "\u{1D524}",
      "ggg;": "\u22D9",
      "gla;": "\u2AA5",
      "glE;": "\u2A92",
      "glj;": "\u2AA4",
      "gnE;": "\u2269",
      "gne;": "\u2A88",
      "Hat;": "^",
      "Hfr;": "\u210C",
      "hfr;": "\u{1D525}",
      "Icy;": "\u0418",
      "icy;": "\u0438",
      "iff;": "\u21D4",
      "Ifr;": "\u2111",
      "ifr;": "\u{1D526}",
      "Int;": "\u222C",
      "int;": "\u222B",
      Iuml: "\xCF",
      iuml: "\xEF",
      "Jcy;": "\u0419",
      "jcy;": "\u0439",
      "Jfr;": "\u{1D50D}",
      "jfr;": "\u{1D527}",
      "Kcy;": "\u041A",
      "kcy;": "\u043A",
      "Kfr;": "\u{1D50E}",
      "kfr;": "\u{1D528}",
      "lap;": "\u2A85",
      "lat;": "\u2AAB",
      "Lcy;": "\u041B",
      "lcy;": "\u043B",
      "lEg;": "\u2A8B",
      "leg;": "\u22DA",
      "leq;": "\u2264",
      "les;": "\u2A7D",
      "Lfr;": "\u{1D50F}",
      "lfr;": "\u{1D529}",
      "lgE;": "\u2A91",
      "lnE;": "\u2268",
      "lne;": "\u2A87",
      "loz;": "\u25CA",
      "lrm;": "\u200E",
      "Lsh;": "\u21B0",
      "lsh;": "\u21B0",
      macr: "\xAF",
      "Map;": "\u2905",
      "map;": "\u21A6",
      "Mcy;": "\u041C",
      "mcy;": "\u043C",
      "Mfr;": "\u{1D510}",
      "mfr;": "\u{1D52A}",
      "mho;": "\u2127",
      "mid;": "\u2223",
      "nap;": "\u2249",
      nbsp: "\xA0",
      "Ncy;": "\u041D",
      "ncy;": "\u043D",
      "Nfr;": "\u{1D511}",
      "nfr;": "\u{1D52B}",
      "ngE;": "\u2267\u0338",
      "nge;": "\u2271",
      "nGg;": "\u22D9\u0338",
      "nGt;": "\u226B\u20D2",
      "ngt;": "\u226F",
      "nis;": "\u22FC",
      "niv;": "\u220B",
      "nlE;": "\u2266\u0338",
      "nle;": "\u2270",
      "nLl;": "\u22D8\u0338",
      "nLt;": "\u226A\u20D2",
      "nlt;": "\u226E",
      "Not;": "\u2AEC",
      "not;": "\xAC",
      "npr;": "\u2280",
      "nsc;": "\u2281",
      "num;": "#",
      "Ocy;": "\u041E",
      "ocy;": "\u043E",
      "Ofr;": "\u{1D512}",
      "ofr;": "\u{1D52C}",
      "ogt;": "\u29C1",
      "ohm;": "\u03A9",
      "olt;": "\u29C0",
      "ord;": "\u2A5D",
      ordf: "\xAA",
      ordm: "\xBA",
      "orv;": "\u2A5B",
      Ouml: "\xD6",
      ouml: "\xF6",
      "par;": "\u2225",
      para: "\xB6",
      "Pcy;": "\u041F",
      "pcy;": "\u043F",
      "Pfr;": "\u{1D513}",
      "pfr;": "\u{1D52D}",
      "Phi;": "\u03A6",
      "phi;": "\u03C6",
      "piv;": "\u03D6",
      "prE;": "\u2AB3",
      "pre;": "\u2AAF",
      "Psi;": "\u03A8",
      "psi;": "\u03C8",
      "Qfr;": "\u{1D514}",
      "qfr;": "\u{1D52E}",
      QUOT: '"',
      quot: '"',
      "Rcy;": "\u0420",
      "rcy;": "\u0440",
      "REG;": "\xAE",
      "reg;": "\xAE",
      "Rfr;": "\u211C",
      "rfr;": "\u{1D52F}",
      "Rho;": "\u03A1",
      "rho;": "\u03C1",
      "rlm;": "\u200F",
      "Rsh;": "\u21B1",
      "rsh;": "\u21B1",
      "scE;": "\u2AB4",
      "sce;": "\u2AB0",
      "Scy;": "\u0421",
      "scy;": "\u0441",
      sect: "\xA7",
      "Sfr;": "\u{1D516}",
      "sfr;": "\u{1D530}",
      "shy;": "\xAD",
      "sim;": "\u223C",
      "smt;": "\u2AAA",
      "sol;": "/",
      "squ;": "\u25A1",
      "Sub;": "\u22D0",
      "sub;": "\u2282",
      "Sum;": "\u2211",
      "sum;": "\u2211",
      "Sup;": "\u22D1",
      "sup;": "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      "Tab;": "	",
      "Tau;": "\u03A4",
      "tau;": "\u03C4",
      "Tcy;": "\u0422",
      "tcy;": "\u0442",
      "Tfr;": "\u{1D517}",
      "tfr;": "\u{1D531}",
      "top;": "\u22A4",
      "Ucy;": "\u0423",
      "ucy;": "\u0443",
      "Ufr;": "\u{1D518}",
      "ufr;": "\u{1D532}",
      "uml;": "\xA8",
      Uuml: "\xDC",
      uuml: "\xFC",
      "Vcy;": "\u0412",
      "vcy;": "\u0432",
      "Vee;": "\u22C1",
      "vee;": "\u2228",
      "Vfr;": "\u{1D519}",
      "vfr;": "\u{1D533}",
      "Wfr;": "\u{1D51A}",
      "wfr;": "\u{1D534}",
      "Xfr;": "\u{1D51B}",
      "xfr;": "\u{1D535}",
      "Ycy;": "\u042B",
      "ycy;": "\u044B",
      "yen;": "\xA5",
      "Yfr;": "\u{1D51C}",
      "yfr;": "\u{1D536}",
      yuml: "\xFF",
      "Zcy;": "\u0417",
      "zcy;": "\u0437",
      "Zfr;": "\u2128",
      "zfr;": "\u{1D537}",
      "zwj;": "\u200D",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      AElig: "\xC6",
      aelig: "\xE6",
      "andd;": "\u2A5C",
      "andv;": "\u2A5A",
      "ange;": "\u29A4",
      "Aopf;": "\u{1D538}",
      "aopf;": "\u{1D552}",
      "apid;": "\u224B",
      "apos;": "'",
      Aring: "\xC5",
      aring: "\xE5",
      "Ascr;": "\u{1D49C}",
      "ascr;": "\u{1D4B6}",
      "Auml;": "\xC4",
      "auml;": "\xE4",
      "Barv;": "\u2AE7",
      "bbrk;": "\u23B5",
      "Beta;": "\u0392",
      "beta;": "\u03B2",
      "beth;": "\u2136",
      "bNot;": "\u2AED",
      "bnot;": "\u2310",
      "Bopf;": "\u{1D539}",
      "bopf;": "\u{1D553}",
      "boxH;": "\u2550",
      "boxh;": "\u2500",
      "boxV;": "\u2551",
      "boxv;": "\u2502",
      "Bscr;": "\u212C",
      "bscr;": "\u{1D4B7}",
      "bsim;": "\u223D",
      "bsol;": "\\",
      "bull;": "\u2022",
      "bump;": "\u224E",
      "caps;": "\u2229\uFE00",
      "Cdot;": "\u010A",
      "cdot;": "\u010B",
      cedil: "\xB8",
      "cent;": "\xA2",
      "CHcy;": "\u0427",
      "chcy;": "\u0447",
      "circ;": "\u02C6",
      "cirE;": "\u29C3",
      "cire;": "\u2257",
      "comp;": "\u2201",
      "cong;": "\u2245",
      "Copf;": "\u2102",
      "copf;": "\u{1D554}",
      "COPY;": "\xA9",
      "copy;": "\xA9",
      "Cscr;": "\u{1D49E}",
      "cscr;": "\u{1D4B8}",
      "csub;": "\u2ACF",
      "csup;": "\u2AD0",
      "cups;": "\u222A\uFE00",
      "Darr;": "\u21A1",
      "dArr;": "\u21D3",
      "darr;": "\u2193",
      "dash;": "\u2010",
      "dHar;": "\u2965",
      "diam;": "\u22C4",
      "DJcy;": "\u0402",
      "djcy;": "\u0452",
      "Dopf;": "\u{1D53B}",
      "dopf;": "\u{1D555}",
      "Dscr;": "\u{1D49F}",
      "dscr;": "\u{1D4B9}",
      "DScy;": "\u0405",
      "dscy;": "\u0455",
      "dsol;": "\u29F6",
      "dtri;": "\u25BF",
      "DZcy;": "\u040F",
      "dzcy;": "\u045F",
      "ecir;": "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      "Edot;": "\u0116",
      "eDot;": "\u2251",
      "edot;": "\u0117",
      "emsp;": "\u2003",
      "ensp;": "\u2002",
      "Eopf;": "\u{1D53C}",
      "eopf;": "\u{1D556}",
      "epar;": "\u22D5",
      "epsi;": "\u03B5",
      "Escr;": "\u2130",
      "escr;": "\u212F",
      "Esim;": "\u2A73",
      "esim;": "\u2242",
      "Euml;": "\xCB",
      "euml;": "\xEB",
      "euro;": "\u20AC",
      "excl;": "!",
      "flat;": "\u266D",
      "fnof;": "\u0192",
      "Fopf;": "\u{1D53D}",
      "fopf;": "\u{1D557}",
      "fork;": "\u22D4",
      "Fscr;": "\u2131",
      "fscr;": "\u{1D4BB}",
      "Gdot;": "\u0120",
      "gdot;": "\u0121",
      "geqq;": "\u2267",
      "gesl;": "\u22DB\uFE00",
      "GJcy;": "\u0403",
      "gjcy;": "\u0453",
      "gnap;": "\u2A8A",
      "gneq;": "\u2A88",
      "Gopf;": "\u{1D53E}",
      "gopf;": "\u{1D558}",
      "Gscr;": "\u{1D4A2}",
      "gscr;": "\u210A",
      "gsim;": "\u2273",
      "gtcc;": "\u2AA7",
      "gvnE;": "\u2269\uFE00",
      "half;": "\xBD",
      "hArr;": "\u21D4",
      "harr;": "\u2194",
      "hbar;": "\u210F",
      "Hopf;": "\u210D",
      "hopf;": "\u{1D559}",
      "Hscr;": "\u210B",
      "hscr;": "\u{1D4BD}",
      Icirc: "\xCE",
      icirc: "\xEE",
      "Idot;": "\u0130",
      "IEcy;": "\u0415",
      "iecy;": "\u0435",
      iexcl: "\xA1",
      "imof;": "\u22B7",
      "IOcy;": "\u0401",
      "iocy;": "\u0451",
      "Iopf;": "\u{1D540}",
      "iopf;": "\u{1D55A}",
      "Iota;": "\u0399",
      "iota;": "\u03B9",
      "Iscr;": "\u2110",
      "iscr;": "\u{1D4BE}",
      "isin;": "\u2208",
      "Iuml;": "\xCF",
      "iuml;": "\xEF",
      "Jopf;": "\u{1D541}",
      "jopf;": "\u{1D55B}",
      "Jscr;": "\u{1D4A5}",
      "jscr;": "\u{1D4BF}",
      "KHcy;": "\u0425",
      "khcy;": "\u0445",
      "KJcy;": "\u040C",
      "kjcy;": "\u045C",
      "Kopf;": "\u{1D542}",
      "kopf;": "\u{1D55C}",
      "Kscr;": "\u{1D4A6}",
      "kscr;": "\u{1D4C0}",
      "Lang;": "\u27EA",
      "lang;": "\u27E8",
      laquo: "\xAB",
      "Larr;": "\u219E",
      "lArr;": "\u21D0",
      "larr;": "\u2190",
      "late;": "\u2AAD",
      "lcub;": "{",
      "ldca;": "\u2936",
      "ldsh;": "\u21B2",
      "leqq;": "\u2266",
      "lesg;": "\u22DA\uFE00",
      "lHar;": "\u2962",
      "LJcy;": "\u0409",
      "ljcy;": "\u0459",
      "lnap;": "\u2A89",
      "lneq;": "\u2A87",
      "Lopf;": "\u{1D543}",
      "lopf;": "\u{1D55D}",
      "lozf;": "\u29EB",
      "lpar;": "(",
      "Lscr;": "\u2112",
      "lscr;": "\u{1D4C1}",
      "lsim;": "\u2272",
      "lsqb;": "[",
      "ltcc;": "\u2AA6",
      "ltri;": "\u25C3",
      "lvnE;": "\u2268\uFE00",
      "macr;": "\xAF",
      "male;": "\u2642",
      "malt;": "\u2720",
      micro: "\xB5",
      "mlcp;": "\u2ADB",
      "mldr;": "\u2026",
      "Mopf;": "\u{1D544}",
      "mopf;": "\u{1D55E}",
      "Mscr;": "\u2133",
      "mscr;": "\u{1D4C2}",
      "nang;": "\u2220\u20D2",
      "napE;": "\u2A70\u0338",
      "nbsp;": "\xA0",
      "ncap;": "\u2A43",
      "ncup;": "\u2A42",
      "ngeq;": "\u2271",
      "nges;": "\u2A7E\u0338",
      "ngtr;": "\u226F",
      "nGtv;": "\u226B\u0338",
      "nisd;": "\u22FA",
      "NJcy;": "\u040A",
      "njcy;": "\u045A",
      "nldr;": "\u2025",
      "nleq;": "\u2270",
      "nles;": "\u2A7D\u0338",
      "nLtv;": "\u226A\u0338",
      "nmid;": "\u2224",
      "Nopf;": "\u2115",
      "nopf;": "\u{1D55F}",
      "npar;": "\u2226",
      "npre;": "\u2AAF\u0338",
      "nsce;": "\u2AB0\u0338",
      "Nscr;": "\u{1D4A9}",
      "nscr;": "\u{1D4C3}",
      "nsim;": "\u2241",
      "nsub;": "\u2284",
      "nsup;": "\u2285",
      "ntgl;": "\u2279",
      "ntlg;": "\u2278",
      "nvap;": "\u224D\u20D2",
      "nvge;": "\u2265\u20D2",
      "nvgt;": ">\u20D2",
      "nvle;": "\u2264\u20D2",
      "nvlt;": "<\u20D2",
      "oast;": "\u229B",
      "ocir;": "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      "odiv;": "\u2A38",
      "odot;": "\u2299",
      "ogon;": "\u02DB",
      "oint;": "\u222E",
      "omid;": "\u29B6",
      "Oopf;": "\u{1D546}",
      "oopf;": "\u{1D560}",
      "opar;": "\u29B7",
      "ordf;": "\xAA",
      "ordm;": "\xBA",
      "oror;": "\u2A56",
      "Oscr;": "\u{1D4AA}",
      "oscr;": "\u2134",
      "osol;": "\u2298",
      "Ouml;": "\xD6",
      "ouml;": "\xF6",
      "para;": "\xB6",
      "part;": "\u2202",
      "perp;": "\u22A5",
      "phiv;": "\u03D5",
      "plus;": "+",
      "Popf;": "\u2119",
      "popf;": "\u{1D561}",
      pound: "\xA3",
      "prap;": "\u2AB7",
      "prec;": "\u227A",
      "prnE;": "\u2AB5",
      "prod;": "\u220F",
      "prop;": "\u221D",
      "Pscr;": "\u{1D4AB}",
      "pscr;": "\u{1D4C5}",
      "qint;": "\u2A0C",
      "Qopf;": "\u211A",
      "qopf;": "\u{1D562}",
      "Qscr;": "\u{1D4AC}",
      "qscr;": "\u{1D4C6}",
      "QUOT;": '"',
      "quot;": '"',
      "race;": "\u223D\u0331",
      "Rang;": "\u27EB",
      "rang;": "\u27E9",
      raquo: "\xBB",
      "Rarr;": "\u21A0",
      "rArr;": "\u21D2",
      "rarr;": "\u2192",
      "rcub;": "}",
      "rdca;": "\u2937",
      "rdsh;": "\u21B3",
      "real;": "\u211C",
      "rect;": "\u25AD",
      "rHar;": "\u2964",
      "rhov;": "\u03F1",
      "ring;": "\u02DA",
      "Ropf;": "\u211D",
      "ropf;": "\u{1D563}",
      "rpar;": ")",
      "Rscr;": "\u211B",
      "rscr;": "\u{1D4C7}",
      "rsqb;": "]",
      "rtri;": "\u25B9",
      "scap;": "\u2AB8",
      "scnE;": "\u2AB6",
      "sdot;": "\u22C5",
      "sect;": "\xA7",
      "semi;": ";",
      "sext;": "\u2736",
      "SHcy;": "\u0428",
      "shcy;": "\u0448",
      "sime;": "\u2243",
      "simg;": "\u2A9E",
      "siml;": "\u2A9D",
      "smid;": "\u2223",
      "smte;": "\u2AAC",
      "solb;": "\u29C4",
      "Sopf;": "\u{1D54A}",
      "sopf;": "\u{1D564}",
      "spar;": "\u2225",
      "Sqrt;": "\u221A",
      "squf;": "\u25AA",
      "Sscr;": "\u{1D4AE}",
      "sscr;": "\u{1D4C8}",
      "Star;": "\u22C6",
      "star;": "\u2606",
      "subE;": "\u2AC5",
      "sube;": "\u2286",
      "succ;": "\u227B",
      "sung;": "\u266A",
      "sup1;": "\xB9",
      "sup2;": "\xB2",
      "sup3;": "\xB3",
      "supE;": "\u2AC6",
      "supe;": "\u2287",
      szlig: "\xDF",
      "tbrk;": "\u23B4",
      "tdot;": "\u20DB",
      THORN: "\xDE",
      thorn: "\xFE",
      times: "\xD7",
      "tint;": "\u222D",
      "toea;": "\u2928",
      "Topf;": "\u{1D54B}",
      "topf;": "\u{1D565}",
      "tosa;": "\u2929",
      "trie;": "\u225C",
      "Tscr;": "\u{1D4AF}",
      "tscr;": "\u{1D4C9}",
      "TScy;": "\u0426",
      "tscy;": "\u0446",
      "Uarr;": "\u219F",
      "uArr;": "\u21D1",
      "uarr;": "\u2191",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      "uHar;": "\u2963",
      "Uopf;": "\u{1D54C}",
      "uopf;": "\u{1D566}",
      "Upsi;": "\u03D2",
      "upsi;": "\u03C5",
      "Uscr;": "\u{1D4B0}",
      "uscr;": "\u{1D4CA}",
      "utri;": "\u25B5",
      "Uuml;": "\xDC",
      "uuml;": "\xFC",
      "vArr;": "\u21D5",
      "varr;": "\u2195",
      "Vbar;": "\u2AEB",
      "vBar;": "\u2AE8",
      "Vert;": "\u2016",
      "vert;": "|",
      "Vopf;": "\u{1D54D}",
      "vopf;": "\u{1D567}",
      "Vscr;": "\u{1D4B1}",
      "vscr;": "\u{1D4CB}",
      "Wopf;": "\u{1D54E}",
      "wopf;": "\u{1D568}",
      "Wscr;": "\u{1D4B2}",
      "wscr;": "\u{1D4CC}",
      "xcap;": "\u22C2",
      "xcup;": "\u22C3",
      "xmap;": "\u27FC",
      "xnis;": "\u22FB",
      "Xopf;": "\u{1D54F}",
      "xopf;": "\u{1D569}",
      "Xscr;": "\u{1D4B3}",
      "xscr;": "\u{1D4CD}",
      "xvee;": "\u22C1",
      "YAcy;": "\u042F",
      "yacy;": "\u044F",
      "YIcy;": "\u0407",
      "yicy;": "\u0457",
      "Yopf;": "\u{1D550}",
      "yopf;": "\u{1D56A}",
      "Yscr;": "\u{1D4B4}",
      "yscr;": "\u{1D4CE}",
      "YUcy;": "\u042E",
      "yucy;": "\u044E",
      "Yuml;": "\u0178",
      "yuml;": "\xFF",
      "Zdot;": "\u017B",
      "zdot;": "\u017C",
      "Zeta;": "\u0396",
      "zeta;": "\u03B6",
      "ZHcy;": "\u0416",
      "zhcy;": "\u0436",
      "Zopf;": "\u2124",
      "zopf;": "\u{1D56B}",
      "Zscr;": "\u{1D4B5}",
      "zscr;": "\u{1D4CF}",
      "zwnj;": "\u200C",
      Aacute: "\xC1",
      aacute: "\xE1",
      "Acirc;": "\xC2",
      "acirc;": "\xE2",
      "acute;": "\xB4",
      "AElig;": "\xC6",
      "aelig;": "\xE6",
      Agrave: "\xC0",
      agrave: "\xE0",
      "aleph;": "\u2135",
      "Alpha;": "\u0391",
      "alpha;": "\u03B1",
      "Amacr;": "\u0100",
      "amacr;": "\u0101",
      "amalg;": "\u2A3F",
      "angle;": "\u2220",
      "angrt;": "\u221F",
      "angst;": "\xC5",
      "Aogon;": "\u0104",
      "aogon;": "\u0105",
      "Aring;": "\xC5",
      "aring;": "\xE5",
      "asymp;": "\u2248",
      Atilde: "\xC3",
      atilde: "\xE3",
      "awint;": "\u2A11",
      "bcong;": "\u224C",
      "bdquo;": "\u201E",
      "bepsi;": "\u03F6",
      "blank;": "\u2423",
      "blk12;": "\u2592",
      "blk14;": "\u2591",
      "blk34;": "\u2593",
      "block;": "\u2588",
      "boxDL;": "\u2557",
      "boxDl;": "\u2556",
      "boxdL;": "\u2555",
      "boxdl;": "\u2510",
      "boxDR;": "\u2554",
      "boxDr;": "\u2553",
      "boxdR;": "\u2552",
      "boxdr;": "\u250C",
      "boxHD;": "\u2566",
      "boxHd;": "\u2564",
      "boxhD;": "\u2565",
      "boxhd;": "\u252C",
      "boxHU;": "\u2569",
      "boxHu;": "\u2567",
      "boxhU;": "\u2568",
      "boxhu;": "\u2534",
      "boxUL;": "\u255D",
      "boxUl;": "\u255C",
      "boxuL;": "\u255B",
      "boxul;": "\u2518",
      "boxUR;": "\u255A",
      "boxUr;": "\u2559",
      "boxuR;": "\u2558",
      "boxur;": "\u2514",
      "boxVH;": "\u256C",
      "boxVh;": "\u256B",
      "boxvH;": "\u256A",
      "boxvh;": "\u253C",
      "boxVL;": "\u2563",
      "boxVl;": "\u2562",
      "boxvL;": "\u2561",
      "boxvl;": "\u2524",
      "boxVR;": "\u2560",
      "boxVr;": "\u255F",
      "boxvR;": "\u255E",
      "boxvr;": "\u251C",
      "Breve;": "\u02D8",
      "breve;": "\u02D8",
      brvbar: "\xA6",
      "bsemi;": "\u204F",
      "bsime;": "\u22CD",
      "bsolb;": "\u29C5",
      "bumpE;": "\u2AAE",
      "bumpe;": "\u224F",
      "caret;": "\u2041",
      "caron;": "\u02C7",
      "ccaps;": "\u2A4D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      "Ccirc;": "\u0108",
      "ccirc;": "\u0109",
      "ccups;": "\u2A4C",
      "cedil;": "\xB8",
      "check;": "\u2713",
      "clubs;": "\u2663",
      "Colon;": "\u2237",
      "colon;": ":",
      "comma;": ",",
      "crarr;": "\u21B5",
      "Cross;": "\u2A2F",
      "cross;": "\u2717",
      "csube;": "\u2AD1",
      "csupe;": "\u2AD2",
      "ctdot;": "\u22EF",
      "cuepr;": "\u22DE",
      "cuesc;": "\u22DF",
      "cupor;": "\u2A45",
      curren: "\xA4",
      "cuvee;": "\u22CE",
      "cuwed;": "\u22CF",
      "cwint;": "\u2231",
      "Dashv;": "\u2AE4",
      "dashv;": "\u22A3",
      "dblac;": "\u02DD",
      "ddarr;": "\u21CA",
      "Delta;": "\u0394",
      "delta;": "\u03B4",
      "dharl;": "\u21C3",
      "dharr;": "\u21C2",
      "diams;": "\u2666",
      "disin;": "\u22F2",
      divide: "\xF7",
      "doteq;": "\u2250",
      "dtdot;": "\u22F1",
      "dtrif;": "\u25BE",
      "duarr;": "\u21F5",
      "duhar;": "\u296F",
      Eacute: "\xC9",
      eacute: "\xE9",
      "Ecirc;": "\xCA",
      "ecirc;": "\xEA",
      "eDDot;": "\u2A77",
      "efDot;": "\u2252",
      Egrave: "\xC8",
      egrave: "\xE8",
      "Emacr;": "\u0112",
      "emacr;": "\u0113",
      "empty;": "\u2205",
      "Eogon;": "\u0118",
      "eogon;": "\u0119",
      "eplus;": "\u2A71",
      "epsiv;": "\u03F5",
      "eqsim;": "\u2242",
      "Equal;": "\u2A75",
      "equiv;": "\u2261",
      "erarr;": "\u2971",
      "erDot;": "\u2253",
      "esdot;": "\u2250",
      "exist;": "\u2203",
      "fflig;": "\uFB00",
      "filig;": "\uFB01",
      "fjlig;": "fj",
      "fllig;": "\uFB02",
      "fltns;": "\u25B1",
      "forkv;": "\u2AD9",
      frac12: "\xBD",
      frac14: "\xBC",
      frac34: "\xBE",
      "frasl;": "\u2044",
      "frown;": "\u2322",
      "Gamma;": "\u0393",
      "gamma;": "\u03B3",
      "Gcirc;": "\u011C",
      "gcirc;": "\u011D",
      "gescc;": "\u2AA9",
      "gimel;": "\u2137",
      "gneqq;": "\u2269",
      "gnsim;": "\u22E7",
      "grave;": "`",
      "gsime;": "\u2A8E",
      "gsiml;": "\u2A90",
      "gtcir;": "\u2A7A",
      "gtdot;": "\u22D7",
      "Hacek;": "\u02C7",
      "harrw;": "\u21AD",
      "Hcirc;": "\u0124",
      "hcirc;": "\u0125",
      "hoarr;": "\u21FF",
      Iacute: "\xCD",
      iacute: "\xED",
      "Icirc;": "\xCE",
      "icirc;": "\xEE",
      "iexcl;": "\xA1",
      Igrave: "\xCC",
      igrave: "\xEC",
      "iiint;": "\u222D",
      "iiota;": "\u2129",
      "IJlig;": "\u0132",
      "ijlig;": "\u0133",
      "Imacr;": "\u012A",
      "imacr;": "\u012B",
      "image;": "\u2111",
      "imath;": "\u0131",
      "imped;": "\u01B5",
      "infin;": "\u221E",
      "Iogon;": "\u012E",
      "iogon;": "\u012F",
      "iprod;": "\u2A3C",
      iquest: "\xBF",
      "isinE;": "\u22F9",
      "isins;": "\u22F4",
      "isinv;": "\u2208",
      "Iukcy;": "\u0406",
      "iukcy;": "\u0456",
      "Jcirc;": "\u0134",
      "jcirc;": "\u0135",
      "jmath;": "\u0237",
      "Jukcy;": "\u0404",
      "jukcy;": "\u0454",
      "Kappa;": "\u039A",
      "kappa;": "\u03BA",
      "lAarr;": "\u21DA",
      "langd;": "\u2991",
      "laquo;": "\xAB",
      "larrb;": "\u21E4",
      "lates;": "\u2AAD\uFE00",
      "lBarr;": "\u290E",
      "lbarr;": "\u290C",
      "lbbrk;": "\u2772",
      "lbrke;": "\u298B",
      "lceil;": "\u2308",
      "ldquo;": "\u201C",
      "lescc;": "\u2AA8",
      "lhard;": "\u21BD",
      "lharu;": "\u21BC",
      "lhblk;": "\u2584",
      "llarr;": "\u21C7",
      "lltri;": "\u25FA",
      "lneqq;": "\u2268",
      "lnsim;": "\u22E6",
      "loang;": "\u27EC",
      "loarr;": "\u21FD",
      "lobrk;": "\u27E6",
      "lopar;": "\u2985",
      "lrarr;": "\u21C6",
      "lrhar;": "\u21CB",
      "lrtri;": "\u22BF",
      "lsime;": "\u2A8D",
      "lsimg;": "\u2A8F",
      "lsquo;": "\u2018",
      "ltcir;": "\u2A79",
      "ltdot;": "\u22D6",
      "ltrie;": "\u22B4",
      "ltrif;": "\u25C2",
      "mdash;": "\u2014",
      "mDDot;": "\u223A",
      "micro;": "\xB5",
      middot: "\xB7",
      "minus;": "\u2212",
      "mumap;": "\u22B8",
      "nabla;": "\u2207",
      "napid;": "\u224B\u0338",
      "napos;": "\u0149",
      "natur;": "\u266E",
      "nbump;": "\u224E\u0338",
      "ncong;": "\u2247",
      "ndash;": "\u2013",
      "neArr;": "\u21D7",
      "nearr;": "\u2197",
      "nedot;": "\u2250\u0338",
      "nesim;": "\u2242\u0338",
      "ngeqq;": "\u2267\u0338",
      "ngsim;": "\u2275",
      "nhArr;": "\u21CE",
      "nharr;": "\u21AE",
      "nhpar;": "\u2AF2",
      "nlArr;": "\u21CD",
      "nlarr;": "\u219A",
      "nleqq;": "\u2266\u0338",
      "nless;": "\u226E",
      "nlsim;": "\u2274",
      "nltri;": "\u22EA",
      "notin;": "\u2209",
      "notni;": "\u220C",
      "npart;": "\u2202\u0338",
      "nprec;": "\u2280",
      "nrArr;": "\u21CF",
      "nrarr;": "\u219B",
      "nrtri;": "\u22EB",
      "nsime;": "\u2244",
      "nsmid;": "\u2224",
      "nspar;": "\u2226",
      "nsubE;": "\u2AC5\u0338",
      "nsube;": "\u2288",
      "nsucc;": "\u2281",
      "nsupE;": "\u2AC6\u0338",
      "nsupe;": "\u2289",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      "numsp;": "\u2007",
      "nvsim;": "\u223C\u20D2",
      "nwArr;": "\u21D6",
      "nwarr;": "\u2196",
      Oacute: "\xD3",
      oacute: "\xF3",
      "Ocirc;": "\xD4",
      "ocirc;": "\xF4",
      "odash;": "\u229D",
      "OElig;": "\u0152",
      "oelig;": "\u0153",
      "ofcir;": "\u29BF",
      Ograve: "\xD2",
      ograve: "\xF2",
      "ohbar;": "\u29B5",
      "olarr;": "\u21BA",
      "olcir;": "\u29BE",
      "oline;": "\u203E",
      "Omacr;": "\u014C",
      "omacr;": "\u014D",
      "Omega;": "\u03A9",
      "omega;": "\u03C9",
      "operp;": "\u29B9",
      "oplus;": "\u2295",
      "orarr;": "\u21BB",
      "order;": "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      Otilde: "\xD5",
      otilde: "\xF5",
      "ovbar;": "\u233D",
      "parsl;": "\u2AFD",
      "phone;": "\u260E",
      "plusb;": "\u229E",
      "pluse;": "\u2A72",
      plusmn: "\xB1",
      "pound;": "\xA3",
      "prcue;": "\u227C",
      "Prime;": "\u2033",
      "prime;": "\u2032",
      "prnap;": "\u2AB9",
      "prsim;": "\u227E",
      "quest;": "?",
      "rAarr;": "\u21DB",
      "radic;": "\u221A",
      "rangd;": "\u2992",
      "range;": "\u29A5",
      "raquo;": "\xBB",
      "rarrb;": "\u21E5",
      "rarrc;": "\u2933",
      "rarrw;": "\u219D",
      "ratio;": "\u2236",
      "RBarr;": "\u2910",
      "rBarr;": "\u290F",
      "rbarr;": "\u290D",
      "rbbrk;": "\u2773",
      "rbrke;": "\u298C",
      "rceil;": "\u2309",
      "rdquo;": "\u201D",
      "reals;": "\u211D",
      "rhard;": "\u21C1",
      "rharu;": "\u21C0",
      "rlarr;": "\u21C4",
      "rlhar;": "\u21CC",
      "rnmid;": "\u2AEE",
      "roang;": "\u27ED",
      "roarr;": "\u21FE",
      "robrk;": "\u27E7",
      "ropar;": "\u2986",
      "rrarr;": "\u21C9",
      "rsquo;": "\u2019",
      "rtrie;": "\u22B5",
      "rtrif;": "\u25B8",
      "sbquo;": "\u201A",
      "sccue;": "\u227D",
      "Scirc;": "\u015C",
      "scirc;": "\u015D",
      "scnap;": "\u2ABA",
      "scsim;": "\u227F",
      "sdotb;": "\u22A1",
      "sdote;": "\u2A66",
      "seArr;": "\u21D8",
      "searr;": "\u2198",
      "setmn;": "\u2216",
      "sharp;": "\u266F",
      "Sigma;": "\u03A3",
      "sigma;": "\u03C3",
      "simeq;": "\u2243",
      "simgE;": "\u2AA0",
      "simlE;": "\u2A9F",
      "simne;": "\u2246",
      "slarr;": "\u2190",
      "smile;": "\u2323",
      "smtes;": "\u2AAC\uFE00",
      "sqcap;": "\u2293",
      "sqcup;": "\u2294",
      "sqsub;": "\u228F",
      "sqsup;": "\u2290",
      "srarr;": "\u2192",
      "starf;": "\u2605",
      "strns;": "\xAF",
      "subnE;": "\u2ACB",
      "subne;": "\u228A",
      "supnE;": "\u2ACC",
      "supne;": "\u228B",
      "swArr;": "\u21D9",
      "swarr;": "\u2199",
      "szlig;": "\xDF",
      "Theta;": "\u0398",
      "theta;": "\u03B8",
      "thkap;": "\u2248",
      "THORN;": "\xDE",
      "thorn;": "\xFE",
      "Tilde;": "\u223C",
      "tilde;": "\u02DC",
      "times;": "\xD7",
      "TRADE;": "\u2122",
      "trade;": "\u2122",
      "trisb;": "\u29CD",
      "TSHcy;": "\u040B",
      "tshcy;": "\u045B",
      "twixt;": "\u226C",
      Uacute: "\xDA",
      uacute: "\xFA",
      "Ubrcy;": "\u040E",
      "ubrcy;": "\u045E",
      "Ucirc;": "\xDB",
      "ucirc;": "\xFB",
      "udarr;": "\u21C5",
      "udhar;": "\u296E",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      "uharl;": "\u21BF",
      "uharr;": "\u21BE",
      "uhblk;": "\u2580",
      "ultri;": "\u25F8",
      "Umacr;": "\u016A",
      "umacr;": "\u016B",
      "Union;": "\u22C3",
      "Uogon;": "\u0172",
      "uogon;": "\u0173",
      "uplus;": "\u228E",
      "upsih;": "\u03D2",
      "UpTee;": "\u22A5",
      "Uring;": "\u016E",
      "uring;": "\u016F",
      "urtri;": "\u25F9",
      "utdot;": "\u22F0",
      "utrif;": "\u25B4",
      "uuarr;": "\u21C8",
      "varpi;": "\u03D6",
      "vBarv;": "\u2AE9",
      "VDash;": "\u22AB",
      "Vdash;": "\u22A9",
      "vDash;": "\u22A8",
      "vdash;": "\u22A2",
      "veeeq;": "\u225A",
      "vltri;": "\u22B2",
      "vnsub;": "\u2282\u20D2",
      "vnsup;": "\u2283\u20D2",
      "vprop;": "\u221D",
      "vrtri;": "\u22B3",
      "Wcirc;": "\u0174",
      "wcirc;": "\u0175",
      "Wedge;": "\u22C0",
      "wedge;": "\u2227",
      "xcirc;": "\u25EF",
      "xdtri;": "\u25BD",
      "xhArr;": "\u27FA",
      "xharr;": "\u27F7",
      "xlArr;": "\u27F8",
      "xlarr;": "\u27F5",
      "xodot;": "\u2A00",
      "xrArr;": "\u27F9",
      "xrarr;": "\u27F6",
      "xutri;": "\u25B3",
      Yacute: "\xDD",
      yacute: "\xFD",
      "Ycirc;": "\u0176",
      "ycirc;": "\u0177",
      "Aacute;": "\xC1",
      "aacute;": "\xE1",
      "Abreve;": "\u0102",
      "abreve;": "\u0103",
      "Agrave;": "\xC0",
      "agrave;": "\xE0",
      "andand;": "\u2A55",
      "angmsd;": "\u2221",
      "angsph;": "\u2222",
      "apacir;": "\u2A6F",
      "approx;": "\u2248",
      "Assign;": "\u2254",
      "Atilde;": "\xC3",
      "atilde;": "\xE3",
      "barvee;": "\u22BD",
      "Barwed;": "\u2306",
      "barwed;": "\u2305",
      "becaus;": "\u2235",
      "bernou;": "\u212C",
      "bigcap;": "\u22C2",
      "bigcup;": "\u22C3",
      "bigvee;": "\u22C1",
      "bkarow;": "\u290D",
      "bottom;": "\u22A5",
      "bowtie;": "\u22C8",
      "boxbox;": "\u29C9",
      "bprime;": "\u2035",
      "brvbar;": "\xA6",
      "bullet;": "\u2022",
      "Bumpeq;": "\u224E",
      "bumpeq;": "\u224F",
      "Cacute;": "\u0106",
      "cacute;": "\u0107",
      "capand;": "\u2A44",
      "capcap;": "\u2A4B",
      "capcup;": "\u2A47",
      "capdot;": "\u2A40",
      "Ccaron;": "\u010C",
      "ccaron;": "\u010D",
      "Ccedil;": "\xC7",
      "ccedil;": "\xE7",
      "circeq;": "\u2257",
      "cirmid;": "\u2AEF",
      "Colone;": "\u2A74",
      "colone;": "\u2254",
      "commat;": "@",
      "compfn;": "\u2218",
      "Conint;": "\u222F",
      "conint;": "\u222E",
      "coprod;": "\u2210",
      "copysr;": "\u2117",
      "cularr;": "\u21B6",
      "CupCap;": "\u224D",
      "cupcap;": "\u2A46",
      "cupcup;": "\u2A4A",
      "cupdot;": "\u228D",
      "curarr;": "\u21B7",
      "curren;": "\xA4",
      "cylcty;": "\u232D",
      "Dagger;": "\u2021",
      "dagger;": "\u2020",
      "daleth;": "\u2138",
      "Dcaron;": "\u010E",
      "dcaron;": "\u010F",
      "dfisht;": "\u297F",
      "divide;": "\xF7",
      "divonx;": "\u22C7",
      "dlcorn;": "\u231E",
      "dlcrop;": "\u230D",
      "dollar;": "$",
      "DotDot;": "\u20DC",
      "drcorn;": "\u231F",
      "drcrop;": "\u230C",
      "Dstrok;": "\u0110",
      "dstrok;": "\u0111",
      "Eacute;": "\xC9",
      "eacute;": "\xE9",
      "easter;": "\u2A6E",
      "Ecaron;": "\u011A",
      "ecaron;": "\u011B",
      "ecolon;": "\u2255",
      "Egrave;": "\xC8",
      "egrave;": "\xE8",
      "egsdot;": "\u2A98",
      "elsdot;": "\u2A97",
      "emptyv;": "\u2205",
      "emsp13;": "\u2004",
      "emsp14;": "\u2005",
      "eparsl;": "\u29E3",
      "eqcirc;": "\u2256",
      "equals;": "=",
      "equest;": "\u225F",
      "Exists;": "\u2203",
      "female;": "\u2640",
      "ffilig;": "\uFB03",
      "ffllig;": "\uFB04",
      "ForAll;": "\u2200",
      "forall;": "\u2200",
      "frac12;": "\xBD",
      "frac13;": "\u2153",
      "frac14;": "\xBC",
      "frac15;": "\u2155",
      "frac16;": "\u2159",
      "frac18;": "\u215B",
      "frac23;": "\u2154",
      "frac25;": "\u2156",
      "frac34;": "\xBE",
      "frac35;": "\u2157",
      "frac38;": "\u215C",
      "frac45;": "\u2158",
      "frac56;": "\u215A",
      "frac58;": "\u215D",
      "frac78;": "\u215E",
      "gacute;": "\u01F5",
      "Gammad;": "\u03DC",
      "gammad;": "\u03DD",
      "Gbreve;": "\u011E",
      "gbreve;": "\u011F",
      "Gcedil;": "\u0122",
      "gesdot;": "\u2A80",
      "gesles;": "\u2A94",
      "gtlPar;": "\u2995",
      "gtrarr;": "\u2978",
      "gtrdot;": "\u22D7",
      "gtrsim;": "\u2273",
      "hairsp;": "\u200A",
      "hamilt;": "\u210B",
      "HARDcy;": "\u042A",
      "hardcy;": "\u044A",
      "hearts;": "\u2665",
      "hellip;": "\u2026",
      "hercon;": "\u22B9",
      "homtht;": "\u223B",
      "horbar;": "\u2015",
      "hslash;": "\u210F",
      "Hstrok;": "\u0126",
      "hstrok;": "\u0127",
      "hybull;": "\u2043",
      "hyphen;": "\u2010",
      "Iacute;": "\xCD",
      "iacute;": "\xED",
      "Igrave;": "\xCC",
      "igrave;": "\xEC",
      "iiiint;": "\u2A0C",
      "iinfin;": "\u29DC",
      "incare;": "\u2105",
      "inodot;": "\u0131",
      "intcal;": "\u22BA",
      "iquest;": "\xBF",
      "isinsv;": "\u22F3",
      "Itilde;": "\u0128",
      "itilde;": "\u0129",
      "Jsercy;": "\u0408",
      "jsercy;": "\u0458",
      "kappav;": "\u03F0",
      "Kcedil;": "\u0136",
      "kcedil;": "\u0137",
      "kgreen;": "\u0138",
      "Lacute;": "\u0139",
      "lacute;": "\u013A",
      "lagran;": "\u2112",
      "Lambda;": "\u039B",
      "lambda;": "\u03BB",
      "langle;": "\u27E8",
      "larrfs;": "\u291D",
      "larrhk;": "\u21A9",
      "larrlp;": "\u21AB",
      "larrpl;": "\u2939",
      "larrtl;": "\u21A2",
      "lAtail;": "\u291B",
      "latail;": "\u2919",
      "lbrace;": "{",
      "lbrack;": "[",
      "Lcaron;": "\u013D",
      "lcaron;": "\u013E",
      "Lcedil;": "\u013B",
      "lcedil;": "\u013C",
      "ldquor;": "\u201E",
      "lesdot;": "\u2A7F",
      "lesges;": "\u2A93",
      "lfisht;": "\u297C",
      "lfloor;": "\u230A",
      "lharul;": "\u296A",
      "llhard;": "\u296B",
      "Lmidot;": "\u013F",
      "lmidot;": "\u0140",
      "lmoust;": "\u23B0",
      "loplus;": "\u2A2D",
      "lowast;": "\u2217",
      "lowbar;": "_",
      "lparlt;": "\u2993",
      "lrhard;": "\u296D",
      "lsaquo;": "\u2039",
      "lsquor;": "\u201A",
      "Lstrok;": "\u0141",
      "lstrok;": "\u0142",
      "lthree;": "\u22CB",
      "ltimes;": "\u22C9",
      "ltlarr;": "\u2976",
      "ltrPar;": "\u2996",
      "mapsto;": "\u21A6",
      "marker;": "\u25AE",
      "mcomma;": "\u2A29",
      "midast;": "*",
      "midcir;": "\u2AF0",
      "middot;": "\xB7",
      "minusb;": "\u229F",
      "minusd;": "\u2238",
      "mnplus;": "\u2213",
      "models;": "\u22A7",
      "mstpos;": "\u223E",
      "Nacute;": "\u0143",
      "nacute;": "\u0144",
      "nbumpe;": "\u224F\u0338",
      "Ncaron;": "\u0147",
      "ncaron;": "\u0148",
      "Ncedil;": "\u0145",
      "ncedil;": "\u0146",
      "nearhk;": "\u2924",
      "nequiv;": "\u2262",
      "nesear;": "\u2928",
      "nexist;": "\u2204",
      "nltrie;": "\u22EC",
      "notinE;": "\u22F9\u0338",
      "nparsl;": "\u2AFD\u20E5",
      "nprcue;": "\u22E0",
      "nrarrc;": "\u2933\u0338",
      "nrarrw;": "\u219D\u0338",
      "nrtrie;": "\u22ED",
      "nsccue;": "\u22E1",
      "nsimeq;": "\u2244",
      "Ntilde;": "\xD1",
      "ntilde;": "\xF1",
      "numero;": "\u2116",
      "nVDash;": "\u22AF",
      "nVdash;": "\u22AE",
      "nvDash;": "\u22AD",
      "nvdash;": "\u22AC",
      "nvHarr;": "\u2904",
      "nvlArr;": "\u2902",
      "nvrArr;": "\u2903",
      "nwarhk;": "\u2923",
      "nwnear;": "\u2927",
      "Oacute;": "\xD3",
      "oacute;": "\xF3",
      "Odblac;": "\u0150",
      "odblac;": "\u0151",
      "odsold;": "\u29BC",
      "Ograve;": "\xD2",
      "ograve;": "\xF2",
      "ominus;": "\u2296",
      "origof;": "\u22B6",
      "Oslash;": "\xD8",
      "oslash;": "\xF8",
      "Otilde;": "\xD5",
      "otilde;": "\xF5",
      "Otimes;": "\u2A37",
      "otimes;": "\u2297",
      "parsim;": "\u2AF3",
      "percnt;": "%",
      "period;": ".",
      "permil;": "\u2030",
      "phmmat;": "\u2133",
      "planck;": "\u210F",
      "plankv;": "\u210F",
      "plusdo;": "\u2214",
      "plusdu;": "\u2A25",
      "plusmn;": "\xB1",
      "preceq;": "\u2AAF",
      "primes;": "\u2119",
      "prnsim;": "\u22E8",
      "propto;": "\u221D",
      "prurel;": "\u22B0",
      "puncsp;": "\u2008",
      "qprime;": "\u2057",
      "Racute;": "\u0154",
      "racute;": "\u0155",
      "rangle;": "\u27E9",
      "rarrap;": "\u2975",
      "rarrfs;": "\u291E",
      "rarrhk;": "\u21AA",
      "rarrlp;": "\u21AC",
      "rarrpl;": "\u2945",
      "Rarrtl;": "\u2916",
      "rarrtl;": "\u21A3",
      "rAtail;": "\u291C",
      "ratail;": "\u291A",
      "rbrace;": "}",
      "rbrack;": "]",
      "Rcaron;": "\u0158",
      "rcaron;": "\u0159",
      "Rcedil;": "\u0156",
      "rcedil;": "\u0157",
      "rdquor;": "\u201D",
      "rfisht;": "\u297D",
      "rfloor;": "\u230B",
      "rharul;": "\u296C",
      "rmoust;": "\u23B1",
      "roplus;": "\u2A2E",
      "rpargt;": "\u2994",
      "rsaquo;": "\u203A",
      "rsquor;": "\u2019",
      "rthree;": "\u22CC",
      "rtimes;": "\u22CA",
      "Sacute;": "\u015A",
      "sacute;": "\u015B",
      "Scaron;": "\u0160",
      "scaron;": "\u0161",
      "Scedil;": "\u015E",
      "scedil;": "\u015F",
      "scnsim;": "\u22E9",
      "searhk;": "\u2925",
      "seswar;": "\u2929",
      "sfrown;": "\u2322",
      "SHCHcy;": "\u0429",
      "shchcy;": "\u0449",
      "sigmaf;": "\u03C2",
      "sigmav;": "\u03C2",
      "simdot;": "\u2A6A",
      "smashp;": "\u2A33",
      "SOFTcy;": "\u042C",
      "softcy;": "\u044C",
      "solbar;": "\u233F",
      "spades;": "\u2660",
      "sqcaps;": "\u2293\uFE00",
      "sqcups;": "\u2294\uFE00",
      "sqsube;": "\u2291",
      "sqsupe;": "\u2292",
      "Square;": "\u25A1",
      "square;": "\u25A1",
      "squarf;": "\u25AA",
      "ssetmn;": "\u2216",
      "ssmile;": "\u2323",
      "sstarf;": "\u22C6",
      "subdot;": "\u2ABD",
      "Subset;": "\u22D0",
      "subset;": "\u2282",
      "subsim;": "\u2AC7",
      "subsub;": "\u2AD5",
      "subsup;": "\u2AD3",
      "succeq;": "\u2AB0",
      "supdot;": "\u2ABE",
      "Supset;": "\u22D1",
      "supset;": "\u2283",
      "supsim;": "\u2AC8",
      "supsub;": "\u2AD4",
      "supsup;": "\u2AD6",
      "swarhk;": "\u2926",
      "swnwar;": "\u292A",
      "target;": "\u2316",
      "Tcaron;": "\u0164",
      "tcaron;": "\u0165",
      "Tcedil;": "\u0162",
      "tcedil;": "\u0163",
      "telrec;": "\u2315",
      "there4;": "\u2234",
      "thetav;": "\u03D1",
      "thinsp;": "\u2009",
      "thksim;": "\u223C",
      "timesb;": "\u22A0",
      "timesd;": "\u2A30",
      "topbot;": "\u2336",
      "topcir;": "\u2AF1",
      "tprime;": "\u2034",
      "tridot;": "\u25EC",
      "Tstrok;": "\u0166",
      "tstrok;": "\u0167",
      "Uacute;": "\xDA",
      "uacute;": "\xFA",
      "Ubreve;": "\u016C",
      "ubreve;": "\u016D",
      "Udblac;": "\u0170",
      "udblac;": "\u0171",
      "ufisht;": "\u297E",
      "Ugrave;": "\xD9",
      "ugrave;": "\xF9",
      "ulcorn;": "\u231C",
      "ulcrop;": "\u230F",
      "urcorn;": "\u231D",
      "urcrop;": "\u230E",
      "Utilde;": "\u0168",
      "utilde;": "\u0169",
      "vangrt;": "\u299C",
      "varphi;": "\u03D5",
      "varrho;": "\u03F1",
      "Vdashl;": "\u2AE6",
      "veebar;": "\u22BB",
      "vellip;": "\u22EE",
      "Verbar;": "\u2016",
      "verbar;": "|",
      "vsubnE;": "\u2ACB\uFE00",
      "vsubne;": "\u228A\uFE00",
      "vsupnE;": "\u2ACC\uFE00",
      "vsupne;": "\u228B\uFE00",
      "Vvdash;": "\u22AA",
      "wedbar;": "\u2A5F",
      "wedgeq;": "\u2259",
      "weierp;": "\u2118",
      "wreath;": "\u2240",
      "xoplus;": "\u2A01",
      "xotime;": "\u2A02",
      "xsqcup;": "\u2A06",
      "xuplus;": "\u2A04",
      "xwedge;": "\u22C0",
      "Yacute;": "\xDD",
      "yacute;": "\xFD",
      "Zacute;": "\u0179",
      "zacute;": "\u017A",
      "Zcaron;": "\u017D",
      "zcaron;": "\u017E",
      "zeetrf;": "\u2128",
      "alefsym;": "\u2135",
      "angrtvb;": "\u22BE",
      "angzarr;": "\u237C",
      "asympeq;": "\u224D",
      "backsim;": "\u223D",
      "Because;": "\u2235",
      "because;": "\u2235",
      "bemptyv;": "\u29B0",
      "between;": "\u226C",
      "bigcirc;": "\u25EF",
      "bigodot;": "\u2A00",
      "bigstar;": "\u2605",
      "bnequiv;": "\u2261\u20E5",
      "boxplus;": "\u229E",
      "Cayleys;": "\u212D",
      "Cconint;": "\u2230",
      "ccupssm;": "\u2A50",
      "Cedilla;": "\xB8",
      "cemptyv;": "\u29B2",
      "cirscir;": "\u29C2",
      "coloneq;": "\u2254",
      "congdot;": "\u2A6D",
      "cudarrl;": "\u2938",
      "cudarrr;": "\u2935",
      "cularrp;": "\u293D",
      "curarrm;": "\u293C",
      "dbkarow;": "\u290F",
      "ddagger;": "\u2021",
      "ddotseq;": "\u2A77",
      "demptyv;": "\u29B1",
      "Diamond;": "\u22C4",
      "diamond;": "\u22C4",
      "digamma;": "\u03DD",
      "dotplus;": "\u2214",
      "DownTee;": "\u22A4",
      "dwangle;": "\u29A6",
      "Element;": "\u2208",
      "Epsilon;": "\u0395",
      "epsilon;": "\u03B5",
      "eqcolon;": "\u2255",
      "equivDD;": "\u2A78",
      "gesdoto;": "\u2A82",
      "gtquest;": "\u2A7C",
      "gtrless;": "\u2277",
      "harrcir;": "\u2948",
      "Implies;": "\u21D2",
      "intprod;": "\u2A3C",
      "isindot;": "\u22F5",
      "larrbfs;": "\u291F",
      "larrsim;": "\u2973",
      "lbrksld;": "\u298F",
      "lbrkslu;": "\u298D",
      "ldrdhar;": "\u2967",
      "LeftTee;": "\u22A3",
      "lesdoto;": "\u2A81",
      "lessdot;": "\u22D6",
      "lessgtr;": "\u2276",
      "lesssim;": "\u2272",
      "lotimes;": "\u2A34",
      "lozenge;": "\u25CA",
      "ltquest;": "\u2A7B",
      "luruhar;": "\u2966",
      "maltese;": "\u2720",
      "minusdu;": "\u2A2A",
      "napprox;": "\u2249",
      "natural;": "\u266E",
      "nearrow;": "\u2197",
      "NewLine;": "\n",
      "nexists;": "\u2204",
      "NoBreak;": "\u2060",
      "notinva;": "\u2209",
      "notinvb;": "\u22F7",
      "notinvc;": "\u22F6",
      "NotLess;": "\u226E",
      "notniva;": "\u220C",
      "notnivb;": "\u22FE",
      "notnivc;": "\u22FD",
      "npolint;": "\u2A14",
      "npreceq;": "\u2AAF\u0338",
      "nsqsube;": "\u22E2",
      "nsqsupe;": "\u22E3",
      "nsubset;": "\u2282\u20D2",
      "nsucceq;": "\u2AB0\u0338",
      "nsupset;": "\u2283\u20D2",
      "nvinfin;": "\u29DE",
      "nvltrie;": "\u22B4\u20D2",
      "nvrtrie;": "\u22B5\u20D2",
      "nwarrow;": "\u2196",
      "olcross;": "\u29BB",
      "Omicron;": "\u039F",
      "omicron;": "\u03BF",
      "orderof;": "\u2134",
      "orslope;": "\u2A57",
      "OverBar;": "\u203E",
      "pertenk;": "\u2031",
      "planckh;": "\u210E",
      "pluscir;": "\u2A22",
      "plussim;": "\u2A26",
      "plustwo;": "\u2A27",
      "precsim;": "\u227E",
      "Product;": "\u220F",
      "quatint;": "\u2A16",
      "questeq;": "\u225F",
      "rarrbfs;": "\u2920",
      "rarrsim;": "\u2974",
      "rbrksld;": "\u298E",
      "rbrkslu;": "\u2990",
      "rdldhar;": "\u2969",
      "realine;": "\u211B",
      "rotimes;": "\u2A35",
      "ruluhar;": "\u2968",
      "searrow;": "\u2198",
      "simplus;": "\u2A24",
      "simrarr;": "\u2972",
      "subedot;": "\u2AC3",
      "submult;": "\u2AC1",
      "subplus;": "\u2ABF",
      "subrarr;": "\u2979",
      "succsim;": "\u227F",
      "supdsub;": "\u2AD8",
      "supedot;": "\u2AC4",
      "suphsol;": "\u27C9",
      "suphsub;": "\u2AD7",
      "suplarr;": "\u297B",
      "supmult;": "\u2AC2",
      "supplus;": "\u2AC0",
      "swarrow;": "\u2199",
      "topfork;": "\u2ADA",
      "triplus;": "\u2A39",
      "tritime;": "\u2A3B",
      "UpArrow;": "\u2191",
      "Uparrow;": "\u21D1",
      "uparrow;": "\u2191",
      "Upsilon;": "\u03A5",
      "upsilon;": "\u03C5",
      "uwangle;": "\u29A7",
      "vzigzag;": "\u299A",
      "zigrarr;": "\u21DD",
      "andslope;": "\u2A58",
      "angmsdaa;": "\u29A8",
      "angmsdab;": "\u29A9",
      "angmsdac;": "\u29AA",
      "angmsdad;": "\u29AB",
      "angmsdae;": "\u29AC",
      "angmsdaf;": "\u29AD",
      "angmsdag;": "\u29AE",
      "angmsdah;": "\u29AF",
      "angrtvbd;": "\u299D",
      "approxeq;": "\u224A",
      "awconint;": "\u2233",
      "backcong;": "\u224C",
      "barwedge;": "\u2305",
      "bbrktbrk;": "\u23B6",
      "bigoplus;": "\u2A01",
      "bigsqcup;": "\u2A06",
      "biguplus;": "\u2A04",
      "bigwedge;": "\u22C0",
      "boxminus;": "\u229F",
      "boxtimes;": "\u22A0",
      "bsolhsub;": "\u27C8",
      "capbrcup;": "\u2A49",
      "circledR;": "\xAE",
      "circledS;": "\u24C8",
      "cirfnint;": "\u2A10",
      "clubsuit;": "\u2663",
      "cupbrcap;": "\u2A48",
      "curlyvee;": "\u22CE",
      "cwconint;": "\u2232",
      "DDotrahd;": "\u2911",
      "doteqdot;": "\u2251",
      "DotEqual;": "\u2250",
      "dotminus;": "\u2238",
      "drbkarow;": "\u2910",
      "dzigrarr;": "\u27FF",
      "elinters;": "\u23E7",
      "emptyset;": "\u2205",
      "eqvparsl;": "\u29E5",
      "fpartint;": "\u2A0D",
      "geqslant;": "\u2A7E",
      "gesdotol;": "\u2A84",
      "gnapprox;": "\u2A8A",
      "hksearow;": "\u2925",
      "hkswarow;": "\u2926",
      "imagline;": "\u2110",
      "imagpart;": "\u2111",
      "infintie;": "\u29DD",
      "integers;": "\u2124",
      "Integral;": "\u222B",
      "intercal;": "\u22BA",
      "intlarhk;": "\u2A17",
      "laemptyv;": "\u29B4",
      "ldrushar;": "\u294B",
      "leqslant;": "\u2A7D",
      "lesdotor;": "\u2A83",
      "LessLess;": "\u2AA1",
      "llcorner;": "\u231E",
      "lnapprox;": "\u2A89",
      "lrcorner;": "\u231F",
      "lurdshar;": "\u294A",
      "mapstoup;": "\u21A5",
      "multimap;": "\u22B8",
      "naturals;": "\u2115",
      "ncongdot;": "\u2A6D\u0338",
      "NotEqual;": "\u2260",
      "notindot;": "\u22F5\u0338",
      "NotTilde;": "\u2241",
      "otimesas;": "\u2A36",
      "parallel;": "\u2225",
      "PartialD;": "\u2202",
      "plusacir;": "\u2A23",
      "pointint;": "\u2A15",
      "Precedes;": "\u227A",
      "precneqq;": "\u2AB5",
      "precnsim;": "\u22E8",
      "profalar;": "\u232E",
      "profline;": "\u2312",
      "profsurf;": "\u2313",
      "raemptyv;": "\u29B3",
      "realpart;": "\u211C",
      "RightTee;": "\u22A2",
      "rppolint;": "\u2A12",
      "rtriltri;": "\u29CE",
      "scpolint;": "\u2A13",
      "setminus;": "\u2216",
      "shortmid;": "\u2223",
      "smeparsl;": "\u29E4",
      "sqsubset;": "\u228F",
      "sqsupset;": "\u2290",
      "subseteq;": "\u2286",
      "Succeeds;": "\u227B",
      "succneqq;": "\u2AB6",
      "succnsim;": "\u22E9",
      "SuchThat;": "\u220B",
      "Superset;": "\u2283",
      "supseteq;": "\u2287",
      "thetasym;": "\u03D1",
      "thicksim;": "\u223C",
      "timesbar;": "\u2A31",
      "triangle;": "\u25B5",
      "triminus;": "\u2A3A",
      "trpezium;": "\u23E2",
      "Uarrocir;": "\u2949",
      "ulcorner;": "\u231C",
      "UnderBar;": "_",
      "urcorner;": "\u231D",
      "varkappa;": "\u03F0",
      "varsigma;": "\u03C2",
      "vartheta;": "\u03D1",
      "backprime;": "\u2035",
      "backsimeq;": "\u22CD",
      "Backslash;": "\u2216",
      "bigotimes;": "\u2A02",
      "CenterDot;": "\xB7",
      "centerdot;": "\xB7",
      "checkmark;": "\u2713",
      "CircleDot;": "\u2299",
      "complexes;": "\u2102",
      "Congruent;": "\u2261",
      "Coproduct;": "\u2210",
      "dotsquare;": "\u22A1",
      "DoubleDot;": "\xA8",
      "DownArrow;": "\u2193",
      "Downarrow;": "\u21D3",
      "downarrow;": "\u2193",
      "DownBreve;": "\u0311",
      "gtrapprox;": "\u2A86",
      "gtreqless;": "\u22DB",
      "gvertneqq;": "\u2269\uFE00",
      "heartsuit;": "\u2665",
      "HumpEqual;": "\u224F",
      "LeftArrow;": "\u2190",
      "Leftarrow;": "\u21D0",
      "leftarrow;": "\u2190",
      "LeftFloor;": "\u230A",
      "lesseqgtr;": "\u22DA",
      "LessTilde;": "\u2272",
      "lvertneqq;": "\u2268\uFE00",
      "Mellintrf;": "\u2133",
      "MinusPlus;": "\u2213",
      "ngeqslant;": "\u2A7E\u0338",
      "nleqslant;": "\u2A7D\u0338",
      "NotCupCap;": "\u226D",
      "NotExists;": "\u2204",
      "NotSubset;": "\u2282\u20D2",
      "nparallel;": "\u2226",
      "nshortmid;": "\u2224",
      "nsubseteq;": "\u2288",
      "nsupseteq;": "\u2289",
      "OverBrace;": "\u23DE",
      "pitchfork;": "\u22D4",
      "PlusMinus;": "\xB1",
      "rationals;": "\u211A",
      "spadesuit;": "\u2660",
      "subseteqq;": "\u2AC5",
      "subsetneq;": "\u228A",
      "supseteqq;": "\u2AC6",
      "supsetneq;": "\u228B",
      "Therefore;": "\u2234",
      "therefore;": "\u2234",
      "ThinSpace;": "\u2009",
      "triangleq;": "\u225C",
      "TripleDot;": "\u20DB",
      "UnionPlus;": "\u228E",
      "varpropto;": "\u221D",
      "Bernoullis;": "\u212C",
      "circledast;": "\u229B",
      "CirclePlus;": "\u2295",
      "complement;": "\u2201",
      "curlywedge;": "\u22CF",
      "eqslantgtr;": "\u2A96",
      "EqualTilde;": "\u2242",
      "Fouriertrf;": "\u2131",
      "gtreqqless;": "\u2A8C",
      "ImaginaryI;": "\u2148",
      "Laplacetrf;": "\u2112",
      "LeftVector;": "\u21BC",
      "lessapprox;": "\u2A85",
      "lesseqqgtr;": "\u2A8B",
      "Lleftarrow;": "\u21DA",
      "lmoustache;": "\u23B0",
      "longmapsto;": "\u27FC",
      "mapstodown;": "\u21A7",
      "mapstoleft;": "\u21A4",
      "nLeftarrow;": "\u21CD",
      "nleftarrow;": "\u219A",
      "NotElement;": "\u2209",
      "NotGreater;": "\u226F",
      "nsubseteqq;": "\u2AC5\u0338",
      "nsupseteqq;": "\u2AC6\u0338",
      "precapprox;": "\u2AB7",
      "Proportion;": "\u2237",
      "RightArrow;": "\u2192",
      "Rightarrow;": "\u21D2",
      "rightarrow;": "\u2192",
      "RightFloor;": "\u230B",
      "rmoustache;": "\u23B1",
      "sqsubseteq;": "\u2291",
      "sqsupseteq;": "\u2292",
      "subsetneqq;": "\u2ACB",
      "succapprox;": "\u2AB8",
      "supsetneqq;": "\u2ACC",
      "ThickSpace;": "\u205F\u200A",
      "TildeEqual;": "\u2243",
      "TildeTilde;": "\u2248",
      "UnderBrace;": "\u23DF",
      "UpArrowBar;": "\u2912",
      "UpTeeArrow;": "\u21A5",
      "upuparrows;": "\u21C8",
      "varepsilon;": "\u03F5",
      "varnothing;": "\u2205",
      "backepsilon;": "\u03F6",
      "blacksquare;": "\u25AA",
      "circledcirc;": "\u229A",
      "circleddash;": "\u229D",
      "CircleMinus;": "\u2296",
      "CircleTimes;": "\u2297",
      "curlyeqprec;": "\u22DE",
      "curlyeqsucc;": "\u22DF",
      "diamondsuit;": "\u2666",
      "eqslantless;": "\u2A95",
      "Equilibrium;": "\u21CC",
      "expectation;": "\u2130",
      "GreaterLess;": "\u2277",
      "LeftCeiling;": "\u2308",
      "LessGreater;": "\u2276",
      "MediumSpace;": "\u205F",
      "NotLessLess;": "\u226A\u0338",
      "NotPrecedes;": "\u2280",
      "NotSucceeds;": "\u2281",
      "NotSuperset;": "\u2283\u20D2",
      "nRightarrow;": "\u21CF",
      "nrightarrow;": "\u219B",
      "OverBracket;": "\u23B4",
      "preccurlyeq;": "\u227C",
      "precnapprox;": "\u2AB9",
      "quaternions;": "\u210D",
      "RightVector;": "\u21C0",
      "Rrightarrow;": "\u21DB",
      "RuleDelayed;": "\u29F4",
      "SmallCircle;": "\u2218",
      "SquareUnion;": "\u2294",
      "straightphi;": "\u03D5",
      "SubsetEqual;": "\u2286",
      "succcurlyeq;": "\u227D",
      "succnapprox;": "\u2ABA",
      "thickapprox;": "\u2248",
      "UpDownArrow;": "\u2195",
      "Updownarrow;": "\u21D5",
      "updownarrow;": "\u2195",
      "VerticalBar;": "\u2223",
      "blacklozenge;": "\u29EB",
      "DownArrowBar;": "\u2913",
      "DownTeeArrow;": "\u21A7",
      "ExponentialE;": "\u2147",
      "exponentiale;": "\u2147",
      "GreaterEqual;": "\u2265",
      "GreaterTilde;": "\u2273",
      "HilbertSpace;": "\u210B",
      "HumpDownHump;": "\u224E",
      "Intersection;": "\u22C2",
      "LeftArrowBar;": "\u21E4",
      "LeftTeeArrow;": "\u21A4",
      "LeftTriangle;": "\u22B2",
      "LeftUpVector;": "\u21BF",
      "NotCongruent;": "\u2262",
      "NotHumpEqual;": "\u224F\u0338",
      "NotLessEqual;": "\u2270",
      "NotLessTilde;": "\u2274",
      "Proportional;": "\u221D",
      "RightCeiling;": "\u2309",
      "risingdotseq;": "\u2253",
      "RoundImplies;": "\u2970",
      "ShortUpArrow;": "\u2191",
      "SquareSubset;": "\u228F",
      "triangledown;": "\u25BF",
      "triangleleft;": "\u25C3",
      "UnderBracket;": "\u23B5",
      "varsubsetneq;": "\u228A\uFE00",
      "varsupsetneq;": "\u228B\uFE00",
      "VerticalLine;": "|",
      "ApplyFunction;": "\u2061",
      "bigtriangleup;": "\u25B3",
      "blacktriangle;": "\u25B4",
      "DifferentialD;": "\u2146",
      "divideontimes;": "\u22C7",
      "DoubleLeftTee;": "\u2AE4",
      "DoubleUpArrow;": "\u21D1",
      "fallingdotseq;": "\u2252",
      "hookleftarrow;": "\u21A9",
      "leftarrowtail;": "\u21A2",
      "leftharpoonup;": "\u21BC",
      "LeftTeeVector;": "\u295A",
      "LeftVectorBar;": "\u2952",
      "LessFullEqual;": "\u2266",
      "LongLeftArrow;": "\u27F5",
      "Longleftarrow;": "\u27F8",
      "longleftarrow;": "\u27F5",
      "looparrowleft;": "\u21AB",
      "measuredangle;": "\u2221",
      "NotEqualTilde;": "\u2242\u0338",
      "NotTildeEqual;": "\u2244",
      "NotTildeTilde;": "\u2249",
      "ntriangleleft;": "\u22EA",
      "Poincareplane;": "\u210C",
      "PrecedesEqual;": "\u2AAF",
      "PrecedesTilde;": "\u227E",
      "RightArrowBar;": "\u21E5",
      "RightTeeArrow;": "\u21A6",
      "RightTriangle;": "\u22B3",
      "RightUpVector;": "\u21BE",
      "shortparallel;": "\u2225",
      "smallsetminus;": "\u2216",
      "SucceedsEqual;": "\u2AB0",
      "SucceedsTilde;": "\u227F",
      "SupersetEqual;": "\u2287",
      "triangleright;": "\u25B9",
      "UpEquilibrium;": "\u296E",
      "upharpoonleft;": "\u21BF",
      "varsubsetneqq;": "\u2ACB\uFE00",
      "varsupsetneqq;": "\u2ACC\uFE00",
      "VerticalTilde;": "\u2240",
      "VeryThinSpace;": "\u200A",
      "curvearrowleft;": "\u21B6",
      "DiacriticalDot;": "\u02D9",
      "doublebarwedge;": "\u2306",
      "DoubleRightTee;": "\u22A8",
      "downdownarrows;": "\u21CA",
      "DownLeftVector;": "\u21BD",
      "GreaterGreater;": "\u2AA2",
      "hookrightarrow;": "\u21AA",
      "HorizontalLine;": "\u2500",
      "InvisibleComma;": "\u2063",
      "InvisibleTimes;": "\u2062",
      "LeftDownVector;": "\u21C3",
      "leftleftarrows;": "\u21C7",
      "LeftRightArrow;": "\u2194",
      "Leftrightarrow;": "\u21D4",
      "leftrightarrow;": "\u2194",
      "leftthreetimes;": "\u22CB",
      "LessSlantEqual;": "\u2A7D",
      "LongRightArrow;": "\u27F6",
      "Longrightarrow;": "\u27F9",
      "longrightarrow;": "\u27F6",
      "looparrowright;": "\u21AC",
      "LowerLeftArrow;": "\u2199",
      "NestedLessLess;": "\u226A",
      "NotGreaterLess;": "\u2279",
      "NotLessGreater;": "\u2278",
      "NotSubsetEqual;": "\u2288",
      "NotVerticalBar;": "\u2224",
      "nshortparallel;": "\u2226",
      "ntriangleright;": "\u22EB",
      "OpenCurlyQuote;": "\u2018",
      "ReverseElement;": "\u220B",
      "rightarrowtail;": "\u21A3",
      "rightharpoonup;": "\u21C0",
      "RightTeeVector;": "\u295B",
      "RightVectorBar;": "\u2953",
      "ShortDownArrow;": "\u2193",
      "ShortLeftArrow;": "\u2190",
      "SquareSuperset;": "\u2290",
      "TildeFullEqual;": "\u2245",
      "trianglelefteq;": "\u22B4",
      "upharpoonright;": "\u21BE",
      "UpperLeftArrow;": "\u2196",
      "ZeroWidthSpace;": "\u200B",
      "bigtriangledown;": "\u25BD",
      "circlearrowleft;": "\u21BA",
      "CloseCurlyQuote;": "\u2019",
      "ContourIntegral;": "\u222E",
      "curvearrowright;": "\u21B7",
      "DoubleDownArrow;": "\u21D3",
      "DoubleLeftArrow;": "\u21D0",
      "downharpoonleft;": "\u21C3",
      "DownRightVector;": "\u21C1",
      "leftharpoondown;": "\u21BD",
      "leftrightarrows;": "\u21C6",
      "LeftRightVector;": "\u294E",
      "LeftTriangleBar;": "\u29CF",
      "LeftUpTeeVector;": "\u2960",
      "LeftUpVectorBar;": "\u2958",
      "LowerRightArrow;": "\u2198",
      "nLeftrightarrow;": "\u21CE",
      "nleftrightarrow;": "\u21AE",
      "NotGreaterEqual;": "\u2271",
      "NotGreaterTilde;": "\u2275",
      "NotHumpDownHump;": "\u224E\u0338",
      "NotLeftTriangle;": "\u22EA",
      "NotSquareSubset;": "\u228F\u0338",
      "ntrianglelefteq;": "\u22EC",
      "OverParenthesis;": "\u23DC",
      "RightDownVector;": "\u21C2",
      "rightleftarrows;": "\u21C4",
      "rightsquigarrow;": "\u219D",
      "rightthreetimes;": "\u22CC",
      "ShortRightArrow;": "\u2192",
      "straightepsilon;": "\u03F5",
      "trianglerighteq;": "\u22B5",
      "UpperRightArrow;": "\u2197",
      "vartriangleleft;": "\u22B2",
      "circlearrowright;": "\u21BB",
      "DiacriticalAcute;": "\xB4",
      "DiacriticalGrave;": "`",
      "DiacriticalTilde;": "\u02DC",
      "DoubleRightArrow;": "\u21D2",
      "DownArrowUpArrow;": "\u21F5",
      "downharpoonright;": "\u21C2",
      "EmptySmallSquare;": "\u25FB",
      "GreaterEqualLess;": "\u22DB",
      "GreaterFullEqual;": "\u2267",
      "LeftAngleBracket;": "\u27E8",
      "LeftUpDownVector;": "\u2951",
      "LessEqualGreater;": "\u22DA",
      "NonBreakingSpace;": "\xA0",
      "NotPrecedesEqual;": "\u2AAF\u0338",
      "NotRightTriangle;": "\u22EB",
      "NotSucceedsEqual;": "\u2AB0\u0338",
      "NotSucceedsTilde;": "\u227F\u0338",
      "NotSupersetEqual;": "\u2289",
      "ntrianglerighteq;": "\u22ED",
      "rightharpoondown;": "\u21C1",
      "rightrightarrows;": "\u21C9",
      "RightTriangleBar;": "\u29D0",
      "RightUpTeeVector;": "\u295C",
      "RightUpVectorBar;": "\u2954",
      "twoheadleftarrow;": "\u219E",
      "UnderParenthesis;": "\u23DD",
      "UpArrowDownArrow;": "\u21C5",
      "vartriangleright;": "\u22B3",
      "blacktriangledown;": "\u25BE",
      "blacktriangleleft;": "\u25C2",
      "DoubleUpDownArrow;": "\u21D5",
      "DoubleVerticalBar;": "\u2225",
      "DownLeftTeeVector;": "\u295E",
      "DownLeftVectorBar;": "\u2956",
      "FilledSmallSquare;": "\u25FC",
      "GreaterSlantEqual;": "\u2A7E",
      "LeftDoubleBracket;": "\u27E6",
      "LeftDownTeeVector;": "\u2961",
      "LeftDownVectorBar;": "\u2959",
      "leftrightharpoons;": "\u21CB",
      "LeftTriangleEqual;": "\u22B4",
      "NegativeThinSpace;": "\u200B",
      "NotGreaterGreater;": "\u226B\u0338",
      "NotLessSlantEqual;": "\u2A7D\u0338",
      "NotNestedLessLess;": "\u2AA1\u0338",
      "NotReverseElement;": "\u220C",
      "NotSquareSuperset;": "\u2290\u0338",
      "NotTildeFullEqual;": "\u2247",
      "RightAngleBracket;": "\u27E9",
      "rightleftharpoons;": "\u21CC",
      "RightUpDownVector;": "\u294F",
      "SquareSubsetEqual;": "\u2291",
      "twoheadrightarrow;": "\u21A0",
      "VerticalSeparator;": "\u2758",
      "blacktriangleright;": "\u25B8",
      "DownRightTeeVector;": "\u295F",
      "DownRightVectorBar;": "\u2957",
      "LongLeftRightArrow;": "\u27F7",
      "Longleftrightarrow;": "\u27FA",
      "longleftrightarrow;": "\u27F7",
      "NegativeThickSpace;": "\u200B",
      "NotLeftTriangleBar;": "\u29CF\u0338",
      "PrecedesSlantEqual;": "\u227C",
      "ReverseEquilibrium;": "\u21CB",
      "RightDoubleBracket;": "\u27E7",
      "RightDownTeeVector;": "\u295D",
      "RightDownVectorBar;": "\u2955",
      "RightTriangleEqual;": "\u22B5",
      "SquareIntersection;": "\u2293",
      "SucceedsSlantEqual;": "\u227D",
      "DoubleLongLeftArrow;": "\u27F8",
      "DownLeftRightVector;": "\u2950",
      "LeftArrowRightArrow;": "\u21C6",
      "leftrightsquigarrow;": "\u21AD",
      "NegativeMediumSpace;": "\u200B",
      "NotGreaterFullEqual;": "\u2267\u0338",
      "NotRightTriangleBar;": "\u29D0\u0338",
      "RightArrowLeftArrow;": "\u21C4",
      "SquareSupersetEqual;": "\u2292",
      "CapitalDifferentialD;": "\u2145",
      "DoubleLeftRightArrow;": "\u21D4",
      "DoubleLongRightArrow;": "\u27F9",
      "EmptyVerySmallSquare;": "\u25AB",
      "NestedGreaterGreater;": "\u226B",
      "NotDoubleVerticalBar;": "\u2226",
      "NotGreaterSlantEqual;": "\u2A7E\u0338",
      "NotLeftTriangleEqual;": "\u22EC",
      "NotSquareSubsetEqual;": "\u22E2",
      "OpenCurlyDoubleQuote;": "\u201C",
      "ReverseUpEquilibrium;": "\u296F",
      "CloseCurlyDoubleQuote;": "\u201D",
      "DoubleContourIntegral;": "\u222F",
      "FilledVerySmallSquare;": "\u25AA",
      "NegativeVeryThinSpace;": "\u200B",
      "NotPrecedesSlantEqual;": "\u22E0",
      "NotRightTriangleEqual;": "\u22ED",
      "NotSucceedsSlantEqual;": "\u22E1",
      "DiacriticalDoubleAcute;": "\u02DD",
      "NotSquareSupersetEqual;": "\u22E3",
      "NotNestedGreaterGreater;": "\u2AA2\u0338",
      "ClockwiseContourIntegral;": "\u2232",
      "DoubleLongLeftRightArrow;": "\u27FA",
      "CounterClockwiseContourIntegral;": "\u2233"
    };
    var maxCRNameLength;
    var decodeHtml = (rawText, asAttr) => {
      let offset = 0;
      const end = rawText.length;
      let decodedText = "";
      function advance(length) {
        offset += length;
        rawText = rawText.slice(length);
      }
      while (offset < end) {
        const head = /&(?:#x?)?/i.exec(rawText);
        if (!head || offset + head.index >= end) {
          const remaining = end - offset;
          decodedText += rawText.slice(0, remaining);
          advance(remaining);
          break;
        }
        decodedText += rawText.slice(0, head.index);
        advance(head.index);
        if (head[0] === "&") {
          let name = "";
          let value = void 0;
          if (/[0-9a-z]/i.test(rawText[1])) {
            if (!maxCRNameLength) {
              maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name2) => Math.max(max, name2.length), 0);
            }
            for (let length = maxCRNameLength; !value && length > 0; --length) {
              name = rawText.slice(1, 1 + length);
              value = namedCharacterReferences[name];
            }
            if (value) {
              const semi = name.endsWith(";");
              if (asAttr && !semi && /[=a-z0-9]/i.test(rawText[name.length + 1] || "")) {
                decodedText += "&" + name;
                advance(1 + name.length);
              } else {
                decodedText += value;
                advance(1 + name.length);
              }
            } else {
              decodedText += "&" + name;
              advance(1 + name.length);
            }
          } else {
            decodedText += "&";
            advance(1);
          }
        } else {
          const hex = head[0] === "&#x";
          const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;
          const body = pattern.exec(rawText);
          if (!body) {
            decodedText += head[0];
            advance(head[0].length);
          } else {
            let cp = Number.parseInt(body[1], hex ? 16 : 10);
            if (cp === 0) {
              cp = 65533;
            } else if (cp > 1114111) {
              cp = 65533;
            } else if (cp >= 55296 && cp <= 57343) {
              cp = 65533;
            } else if (cp >= 64976 && cp <= 65007 || (cp & 65534) === 65534)
              ;
            else if (cp >= 1 && cp <= 8 || cp === 11 || cp >= 13 && cp <= 31 || cp >= 127 && cp <= 159) {
              cp = CCR_REPLACEMENTS[cp] || cp;
            }
            decodedText += String.fromCodePoint(cp);
            advance(body[0].length);
          }
        }
      }
      return decodedText;
    };
    var CCR_REPLACEMENTS = {
      128: 8364,
      130: 8218,
      131: 402,
      132: 8222,
      133: 8230,
      134: 8224,
      135: 8225,
      136: 710,
      137: 8240,
      138: 352,
      139: 8249,
      140: 338,
      142: 381,
      145: 8216,
      146: 8217,
      147: 8220,
      148: 8221,
      149: 8226,
      150: 8211,
      151: 8212,
      152: 732,
      153: 8482,
      154: 353,
      155: 8250,
      156: 339,
      158: 382,
      159: 376
    };
    var isRawTextContainer = /* @__PURE__ */ shared.makeMap("style,iframe,script,noscript", true);
    var parserOptions = {
      isVoidTag: shared.isVoidTag,
      isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag),
      isPreTag: (tag) => tag === "pre",
      decodeEntities: decodeHtml,
      isBuiltInComponent: (tag) => {
        if (compilerCore.isBuiltInType(tag, `Transition`)) {
          return TRANSITION;
        } else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {
          return TRANSITION_GROUP;
        }
      },
      getNamespace(tag, parent) {
        let ns = parent ? parent.ns : 0;
        if (parent && ns === 2) {
          if (parent.tag === "annotation-xml") {
            if (tag === "svg") {
              return 1;
            }
            if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
              ns = 0;
            }
          } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
            ns = 0;
          }
        } else if (parent && ns === 1) {
          if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
            ns = 0;
          }
        }
        if (ns === 0) {
          if (tag === "svg") {
            return 1;
          }
          if (tag === "math") {
            return 2;
          }
        }
        return ns;
      },
      getTextMode({ tag, ns }) {
        if (ns === 0) {
          if (tag === "textarea" || tag === "title") {
            return 1;
          }
          if (isRawTextContainer(tag)) {
            return 2;
          }
        }
        return 0;
      }
    };
    var transformStyle = (node) => {
      if (node.type === 1) {
        node.props.forEach((p, i) => {
          if (p.type === 6 && p.name === "style" && p.value) {
            node.props[i] = {
              type: 7,
              name: `bind`,
              arg: compilerCore.createSimpleExpression(`style`, true, p.loc),
              exp: parseInlineCSS(p.value.content, p.loc),
              modifiers: [],
              loc: p.loc
            };
          }
        });
      }
    };
    var parseInlineCSS = (cssText, loc) => {
      const normalized = shared.parseStringStyle(cssText);
      return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
    };
    function createDOMCompilerError(code, loc) {
      return compilerCore.createCompilerError(code, loc, DOMErrorMessages);
    }
    var DOMErrorMessages = {
      [50]: `v-html is missing expression.`,
      [51]: `v-html will override element children.`,
      [52]: `v-text is missing expression.`,
      [53]: `v-text will override element children.`,
      [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [55]: `v-model argument is not supported on plain elements.`,
      [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [58]: `v-show is missing expression.`,
      [59]: `<Transition> expects exactly one child element or component.`,
      [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
    };
    var transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(50, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(51, loc));
        node.children.length = 0;
      }
      return {
        props: [
          compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression("", true))
        ]
      };
    };
    var transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(52, loc));
      }
      if (node.children.length) {
        context.onError(createDOMCompilerError(53, loc));
        node.children.length = 0;
      }
      return {
        props: [
          compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp ? compilerCore.createCallExpression(context.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc) : compilerCore.createSimpleExpression("", true))
        ]
      };
    };
    var transformModel = (dir, node, context) => {
      const baseResult = compilerCore.transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1) {
        return baseResult;
      }
      if (dir.arg) {
        context.onError(createDOMCompilerError(55, dir.arg.loc));
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
        let directiveToUse = V_MODEL_TEXT;
        let isInvalidType = false;
        if (tag === "input" || isCustomElement) {
          const type = compilerCore.findProp(node, `type`);
          if (type) {
            if (type.type === 7) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else if (type.value) {
              switch (type.value.content) {
                case "radio":
                  directiveToUse = V_MODEL_RADIO;
                  break;
                case "checkbox":
                  directiveToUse = V_MODEL_CHECKBOX;
                  break;
                case "file":
                  isInvalidType = true;
                  context.onError(createDOMCompilerError(56, dir.loc));
                  break;
              }
            }
          } else if (compilerCore.hasDynamicKeyVBind(node)) {
            directiveToUse = V_MODEL_DYNAMIC;
          } else
            ;
        } else if (tag === "select") {
          directiveToUse = V_MODEL_SELECT;
        } else
          ;
        if (!isInvalidType) {
          baseResult.needRuntime = context.helper(directiveToUse);
        }
      } else {
        context.onError(createDOMCompilerError(54, dir.loc));
      }
      baseResult.props = baseResult.props.filter((p) => !(p.key.type === 4 && p.key.content === "modelValue"));
      return baseResult;
    };
    var isEventOptionModifier = /* @__PURE__ */ shared.makeMap(`passive,once,capture`);
    var isNonKeyModifier = /* @__PURE__ */ shared.makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
    var maybeKeyModifier = /* @__PURE__ */ shared.makeMap("left,right");
    var isKeyboardEvent = /* @__PURE__ */ shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);
    var resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
        const modifier = modifiers[i];
        if (modifier === "native" && compilerCore.checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
          eventOptionModifiers.push(modifier);
        } else if (isEventOptionModifier(modifier)) {
          eventOptionModifiers.push(modifier);
        } else {
          if (maybeKeyModifier(modifier)) {
            if (compilerCore.isStaticExp(key)) {
              if (isKeyboardEvent(key.content)) {
                keyModifiers.push(modifier);
              } else {
                nonKeyModifiers.push(modifier);
              }
            } else {
              keyModifiers.push(modifier);
              nonKeyModifiers.push(modifier);
            }
          } else {
            if (isNonKeyModifier(modifier)) {
              nonKeyModifiers.push(modifier);
            } else {
              keyModifiers.push(modifier);
            }
          }
        }
      }
      return {
        keyModifiers,
        nonKeyModifiers,
        eventOptionModifiers
      };
    };
    var transformClick = (key, event) => {
      const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === "onclick";
      return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([
        `(`,
        key,
        `) === "onClick" ? "${event}" : (`,
        key,
        `)`
      ]) : key;
    };
    var transformOn = (dir, node, context) => {
      return compilerCore.transformOn(dir, node, context, (baseResult) => {
        const { modifiers } = dir;
        if (!modifiers.length)
          return baseResult;
        let { key, value: handlerExp } = baseResult.props[0];
        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
        if (nonKeyModifiers.includes("right")) {
          key = transformClick(key, `onContextmenu`);
        }
        if (nonKeyModifiers.includes("middle")) {
          key = transformClick(key, `onMouseup`);
        }
        if (nonKeyModifiers.length) {
          handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
            handlerExp,
            JSON.stringify(nonKeyModifiers)
          ]);
        }
        if (keyModifiers.length && (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {
          handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [
            handlerExp,
            JSON.stringify(keyModifiers)
          ]);
        }
        if (eventOptionModifiers.length) {
          const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join("");
          key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
        }
        return {
          props: [compilerCore.createObjectProperty(key, handlerExp)]
        };
      });
    };
    var transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
        context.onError(createDOMCompilerError(58, loc));
      }
      return {
        props: [],
        needRuntime: context.helper(V_SHOW)
      };
    };
    var expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
    var stringifyStatic = (children, context, parent) => {
      if (context.scopes.vSlot > 0) {
        return;
      }
      let nc = 0;
      let ec = 0;
      const currentChunk = [];
      const stringifyCurrentChunk = (currentIndex) => {
        if (nc >= 20 || ec >= 5) {
          const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [
            JSON.stringify(currentChunk.map((node) => stringifyNode(node, context)).join("")).replace(expReplaceRE, `" + $1 + "`),
            String(currentChunk.length)
          ]);
          replaceHoist(currentChunk[0], staticCall, context);
          if (currentChunk.length > 1) {
            for (let i2 = 1; i2 < currentChunk.length; i2++) {
              replaceHoist(currentChunk[i2], null, context);
            }
            const deleteCount = currentChunk.length - 1;
            children.splice(currentIndex - currentChunk.length + 1, deleteCount);
            return deleteCount;
          }
        }
        return 0;
      };
      let i = 0;
      for (; i < children.length; i++) {
        const child = children[i];
        const hoisted = getHoistedNode(child);
        if (hoisted) {
          const node = child;
          const result = analyzeNode(node);
          if (result) {
            nc += result[0];
            ec += result[1];
            currentChunk.push(node);
            continue;
          }
        }
        i -= stringifyCurrentChunk(i);
        nc = 0;
        ec = 0;
        currentChunk.length = 0;
      }
      stringifyCurrentChunk(i);
    };
    var getHoistedNode = (node) => (node.type === 1 && node.tagType === 0 || node.type == 12) && node.codegenNode && node.codegenNode.type === 4 && node.codegenNode.hoisted;
    var dataAriaRE = /^(data|aria)-/;
    var isStringifiableAttr = (name, ns) => {
      return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : false) || dataAriaRE.test(name);
    };
    var replaceHoist = (node, replacement, context) => {
      const hoistToReplace = node.codegenNode.hoisted;
      context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
    };
    var isNonStringifiable = /* @__PURE__ */ shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);
    function analyzeNode(node) {
      if (node.type === 1 && isNonStringifiable(node.tag)) {
        return false;
      }
      if (node.type === 12) {
        return [1, 0];
      }
      let nc = 1;
      let ec = node.props.length > 0 ? 1 : 0;
      let bailed = false;
      const bail = () => {
        bailed = true;
        return false;
      };
      function walk2(node2) {
        for (let i = 0; i < node2.props.length; i++) {
          const p = node2.props[i];
          if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {
            return bail();
          }
          if (p.type === 7 && p.name === "bind") {
            if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {
              return bail();
            }
            if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) {
              return bail();
            }
          }
        }
        for (let i = 0; i < node2.children.length; i++) {
          nc++;
          const child = node2.children[i];
          if (child.type === 1) {
            if (child.props.length > 0) {
              ec++;
            }
            walk2(child);
            if (bailed) {
              return false;
            }
          }
        }
        return true;
      }
      return walk2(node) ? [nc, ec] : false;
    }
    function stringifyNode(node, context) {
      if (shared.isString(node)) {
        return node;
      }
      if (shared.isSymbol(node)) {
        return ``;
      }
      switch (node.type) {
        case 1:
          return stringifyElement(node, context);
        case 2:
          return shared.escapeHtml(node.content);
        case 3:
          return `<!--${shared.escapeHtml(node.content)}-->`;
        case 5:
          return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));
        case 8:
          return shared.escapeHtml(evaluateConstant(node));
        case 12:
          return stringifyNode(node.content, context);
        default:
          return "";
      }
    }
    function stringifyElement(node, context) {
      let res = `<${node.tag}`;
      for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6) {
          res += ` ${p.name}`;
          if (p.value) {
            res += `="${shared.escapeHtml(p.value.content)}"`;
          }
        } else if (p.type === 7 && p.name === "bind") {
          const exp = p.exp;
          if (exp.content[0] === "_") {
            res += ` ${p.arg.content}="__VUE_EXP_START__${exp.content}__VUE_EXP_END__"`;
            continue;
          }
          let evaluated = evaluateConstant(exp);
          if (evaluated != null) {
            const arg = p.arg && p.arg.content;
            if (arg === "class") {
              evaluated = shared.normalizeClass(evaluated);
            } else if (arg === "style") {
              evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));
            }
            res += ` ${p.arg.content}="${shared.escapeHtml(evaluated)}"`;
          }
        }
      }
      if (context.scopeId) {
        res += ` ${context.scopeId}`;
      }
      res += `>`;
      for (let i = 0; i < node.children.length; i++) {
        res += stringifyNode(node.children[i], context);
      }
      if (!shared.isVoidTag(node.tag)) {
        res += `</${node.tag}>`;
      }
      return res;
    }
    function evaluateConstant(exp) {
      if (exp.type === 4) {
        return new Function(`return ${exp.content}`)();
      } else {
        let res = ``;
        exp.children.forEach((c) => {
          if (shared.isString(c) || shared.isSymbol(c)) {
            return;
          }
          if (c.type === 2) {
            res += c.content;
          } else if (c.type === 5) {
            res += shared.toDisplayString(evaluateConstant(c.content));
          } else {
            res += evaluateConstant(c);
          }
        });
        return res;
      }
    }
    var ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
        context.onError(createDOMCompilerError(60, node.loc));
        context.removeNode();
      }
    };
    var DOMNodeTransforms = [
      transformStyle,
      ...[]
    ];
    var DOMDirectiveTransforms = {
      cloak: compilerCore.noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel,
      on: transformOn,
      show: transformShow
    };
    function compile(template, options = {}) {
      return compilerCore.baseCompile(template, shared.extend({}, parserOptions, options, {
        nodeTransforms: [
          ignoreSideEffectTags,
          ...DOMNodeTransforms,
          ...options.nodeTransforms || []
        ],
        directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
        transformHoist: stringifyStatic
      }));
    }
    function parse2(template, options = {}) {
      return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));
    }
    Object.keys(compilerCore).forEach(function(k) {
      if (k !== "default")
        exports2[k] = compilerCore[k];
    });
    exports2.DOMDirectiveTransforms = DOMDirectiveTransforms;
    exports2.DOMNodeTransforms = DOMNodeTransforms;
    exports2.TRANSITION = TRANSITION;
    exports2.TRANSITION_GROUP = TRANSITION_GROUP;
    exports2.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;
    exports2.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;
    exports2.V_MODEL_RADIO = V_MODEL_RADIO;
    exports2.V_MODEL_SELECT = V_MODEL_SELECT;
    exports2.V_MODEL_TEXT = V_MODEL_TEXT;
    exports2.V_ON_WITH_KEYS = V_ON_WITH_KEYS;
    exports2.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;
    exports2.V_SHOW = V_SHOW;
    exports2.compile = compile;
    exports2.createDOMCompilerError = createDOMCompilerError;
    exports2.parse = parse2;
    exports2.parserOptions = parserOptions;
    exports2.transformStyle = transformStyle;
  }
});

// ../../node_modules/.pnpm/@vue+compiler-dom@3.2.31/node_modules/@vue/compiler-dom/index.js
var require_compiler_dom = __commonJS({
  "../../node_modules/.pnpm/@vue+compiler-dom@3.2.31/node_modules/@vue/compiler-dom/index.js"(exports2, module2) {
    "use strict";
    if (true) {
      module2.exports = require_compiler_dom_cjs_prod();
    } else {
      module2.exports = null;
    }
  }
});

// ../../packages/client/out/features/preview.js
var require_preview = __commonJS({
  "../../packages/client/out/features/preview.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var compiler_dom_1 = require_compiler_dom();
    var path = require_upath();
    var fs = require_fs();
    var shared = require_node4();
    var vscode_languageserver_textdocument_1 = (init_main3(), __toCommonJS(main_exports2));
    var splitEditors_1 = require_splitEditors();
    async function activate2(context) {
      let goToTemplateReq = 0;
      class FinderPanelSerializer {
        async deserializeWebviewPanel(panel, state) {
          const terminal = vscode2.window.terminals.find((terminal2) => terminal2.name === "volar-preview");
          const port = await openPreview("volar-webview", state.fileName, "", terminal, state.port, panel);
          panel.webview.html = getWebviewContent(`http://localhost:${port}`, state);
        }
      }
      class PreviewPanelSerializer {
        async deserializeWebviewPanel(panel, state) {
          const editor = vscode2.window.visibleTextEditors.find((document) => document.document.fileName === state.fileName);
          if (!editor)
            return;
          const terminal = vscode2.window.terminals.find((terminal2) => terminal2.name === "volar-preview");
          const port = await openPreview("volar-component-preview", editor.document.fileName, editor.document.getText(), terminal, state.port, panel);
          if (port !== void 0) {
            const previewQuery = createQuery(editor.document.fileName, editor.document.getText());
            updatePreviewPanel(panel, state.fileName, previewQuery, port);
          }
        }
      }
      context.subscriptions.push(vscode2.commands.registerCommand("volar.action.vite", async () => {
        const editor = vscode2.window.activeTextEditor;
        if (!editor)
          return;
        const viteConfigFile = await getViteConfigFile(editor.document.fileName);
        const select = await (0, splitEditors_1.userPick)({
          ["volar-webview"]: { label: "Preview Vite App", description: "(Experimental)", detail: vscode2.workspace.rootPath && viteConfigFile ? path.relative(vscode2.workspace.rootPath, viteConfigFile) : viteConfigFile },
          ["volar-component-preview"]: { label: `Preview Component with Vite`, description: "(WIP)", detail: vscode2.workspace.rootPath ? path.relative(vscode2.workspace.rootPath, editor.document.fileName) : editor.document.fileName }
        });
        if (select === void 0)
          return;
        openPreview(select, editor.document.fileName, editor.document.getText());
      }));
      context.subscriptions.push(vscode2.window.registerWebviewPanelSerializer("volar-webview", new FinderPanelSerializer()));
      context.subscriptions.push(vscode2.window.registerWebviewPanelSerializer("volar-component-preview", new PreviewPanelSerializer()));
      context.subscriptions.push(vscode2.window.onDidChangeActiveTextEditor(updateFoundViteDir));
      updateFoundViteDir();
      async function updateFoundViteDir() {
        var _a2;
        if (((_a2 = vscode2.window.activeTextEditor) === null || _a2 === void 0 ? void 0 : _a2.document.languageId) === "vue") {
          const viteConfigFile = await getViteConfigFile(vscode2.window.activeTextEditor.document.fileName);
          vscode2.commands.executeCommand("setContext", "volar.foundViteDir", viteConfigFile !== void 0);
        }
      }
      async function openPreview(mode, fileName, fileText, _terminal, _port, _panel) {
        const viteConfigFile = await getViteConfigFile(fileName);
        if (!viteConfigFile)
          return;
        const viteDir = path.dirname(viteConfigFile);
        const { terminal, port } = _terminal && _port ? { terminal: _terminal, port: _port } : await startViteServer(viteDir);
        const panel = _panel !== null && _panel !== void 0 ? _panel : vscode2.window.createWebviewPanel(mode, "Volar Webview", vscode2.ViewColumn.Beside, {
          retainContextWhenHidden: true,
          enableScripts: true
        });
        const panelContext = [];
        panel.onDidDispose(() => {
          for (const disposable of panelContext) {
            disposable.dispose();
          }
        });
        const statusBar = vscode2.window.createStatusBarItem(vscode2.StatusBarAlignment.Right);
        statusBar.command = "volar.inputWebviewUrl";
        statusBar.backgroundColor = new vscode2.ThemeColor("statusBarItem.warningBackground");
        panelContext.push(statusBar);
        panelContext.push(terminal);
        panelContext.push(vscode2.commands.registerCommand("volar.action.selectElement", () => {
          panel.webview.postMessage({ sender: "volar", command: "selectElement" });
        }));
        panelContext.push(vscode2.commands.registerCommand("volar.action.openInBrowser", () => {
          vscode2.env.openExternal(vscode2.Uri.parse(statusBar.text));
        }));
        if (mode === "volar-webview") {
          panelContext.push(panel.webview.onDidReceiveMessage(webviewEventHandler));
          panelContext.push(vscode2.workspace.onDidChangeConfiguration(() => {
            panel.webview.html = getWebviewContent(`http://localhost:${port}`, { port, fileName });
          }));
          panelContext.push(vscode2.commands.registerCommand("volar.inputWebviewUrl", async () => {
            const input = await vscode2.window.showInputBox({ value: statusBar.text });
            if (input !== void 0 && input !== statusBar.text) {
              panel.webview.html = getWebviewContent(input, { port, fileName });
            }
          }));
          panel.webview.html = getWebviewContent(`http://localhost:${port}`, { port, fileName });
          panel.onDidChangeViewState(() => {
            if (panel.active)
              statusBar.show();
            else
              statusBar.hide();
          });
        } else if (mode === "volar-component-preview") {
          let previewQuery = createQuery(fileText, fileName);
          panelContext.push(vscode2.workspace.onDidChangeTextDocument((e) => {
            if (e.document.fileName === fileName) {
              const newPreviewQuery = createQuery(e.document.getText(), e.document.fileName);
              if (newPreviewQuery !== previewQuery) {
                const url = `http://localhost:${port}/__preview${newPreviewQuery}#${e.document.fileName}`;
                panel.webview.postMessage({ sender: "volar", command: "updateUrl", data: url });
                previewQuery = newPreviewQuery;
              }
            }
          }));
          panelContext.push(panel.webview.onDidReceiveMessage(webviewEventHandler));
          panelContext.push(vscode2.workspace.onDidChangeConfiguration(() => {
            updatePreviewPanel(panel, fileName, previewQuery, port);
          }));
          updatePreviewPanel(panel, fileName, previewQuery, port);
        }
        return port;
        async function webviewEventHandler(message) {
          var _a2, _b;
          switch (message.command) {
            case "openUrl": {
              const url = message.data;
              vscode2.env.openExternal(vscode2.Uri.parse(url));
              break;
            }
            case "urlChanged": {
              const url = message.data;
              statusBar.text = url;
              break;
            }
            case "dontShowAgain": {
              vscode2.workspace.getConfiguration("volar").update("showWelcomePage", false);
              break;
            }
            case "log": {
              const text = message.data;
              vscode2.window.showInformationMessage(text);
              break;
            }
            case "warn": {
              const text = message.data;
              vscode2.window.showWarningMessage(text);
              break;
            }
            case "error": {
              const text = message.data;
              vscode2.window.showErrorMessage(text);
              break;
            }
            case "goToTemplate": {
              const req = ++goToTemplateReq;
              const data = message.data;
              const doc = await vscode2.workspace.openTextDocument(data.fileName);
              if (req !== goToTemplateReq)
                return;
              const sfc = shared.parseSfc(doc.getText(), splitEditors_1.htmlLs.parseHTMLDocument(vscode_languageserver_textdocument_1.TextDocument.create(doc.uri.toString(), doc.languageId, doc.version, doc.getText())));
              const offset = (_b = (_a2 = sfc.template) === null || _a2 === void 0 ? void 0 : _a2.startTagEnd) !== null && _b !== void 0 ? _b : 0;
              const start = doc.positionAt(data.range[0] + offset);
              const end = doc.positionAt(data.range[1] + offset);
              await vscode2.window.showTextDocument(doc, vscode2.ViewColumn.One);
              if (req !== goToTemplateReq)
                return;
              const editor = vscode2.window.activeTextEditor;
              if (editor) {
                editor.selection = new vscode2.Selection(start, end);
                editor.revealRange(new vscode2.Range(start, end));
              }
              break;
            }
          }
        }
      }
      async function startViteServer(viteDir) {
        var _a2;
        const port = await shared.getLocalHostAvaliablePort((_a2 = vscode2.workspace.getConfiguration("volar").get("preview.port")) !== null && _a2 !== void 0 ? _a2 : 3333);
        const terminal = vscode2.window.createTerminal("volar-preview");
        const viteProxyPath = require.resolve("./bin/vite", { paths: [context.extensionPath] });
        terminal.sendText(`cd ${viteDir}`);
        terminal.sendText(`node ${viteProxyPath} --port=${port}`);
        const start = Date.now();
        while (Date.now() - start < 1e4 && !await shared.isLocalHostPortUsing(port)) {
          await shared.sleep(100);
        }
        return {
          port,
          terminal
        };
      }
      async function getViteConfigFile(fileName) {
        let dir = path.dirname(fileName);
        let viteConfigFile;
        while (true) {
          const configTs = path.join(dir, "vite.config.ts");
          const configJs = path.join(dir, "vite.config.js");
          if (await fs.exists(vscode2.Uri.file(configTs))) {
            viteConfigFile = configTs;
            break;
          }
          if (await fs.exists(vscode2.Uri.file(configJs))) {
            viteConfigFile = configJs;
            break;
          }
          const upperDir = path.dirname(dir);
          if (upperDir === dir) {
            break;
          }
          dir = upperDir;
        }
        return viteConfigFile;
      }
      function createQuery(vueCode, fileName) {
        var _a2, _b;
        const sfc = shared.parseSfc(vueCode, splitEditors_1.htmlLs.parseHTMLDocument(vscode_languageserver_textdocument_1.TextDocument.create("", "", 0, vueCode)));
        let query = "";
        for (const customBlock of sfc.customBlocks) {
          if (customBlock.type === "preview") {
            const previewTagStart = vueCode.substring(0, customBlock.startTagEnd).lastIndexOf("<preview");
            const previewTag = vueCode.substring(previewTagStart, customBlock.startTagEnd);
            const previewGen = (0, compiler_dom_1.compile)(previewTag + "</preview>").ast;
            const props = {};
            for (const previewNode of previewGen.children) {
              if (previewNode.type === 1) {
                for (const prop of previewNode.props) {
                  if (prop.type === 6) {
                    if (prop.value) {
                      props[prop.name] = JSON.stringify(prop.value.content);
                    } else {
                      props[prop.name] = JSON.stringify(true);
                    }
                  } else if (prop.type === 7) {
                    if (((_a2 = prop.arg) === null || _a2 === void 0 ? void 0 : _a2.type) === 4 && ((_b = prop.exp) === null || _b === void 0 ? void 0 : _b.type) == 4) {
                      props[prop.arg.content] = prop.exp.content;
                    }
                  }
                }
              }
            }
            const keys = Object.keys(props);
            for (let i = 0; i < keys.length; i++) {
              query += i === 0 ? "?" : "&";
              const key = keys[i];
              const value = props[key];
              query += key;
              query += "=";
              query += encodeURIComponent(value);
            }
          } else if (customBlock.type === "preview-target" && customBlock.attrs.path) {
            fileName = path.resolve(path.dirname(fileName), customBlock.attrs.path);
          }
        }
        return query;
      }
      function updatePreviewPanel(previewPanel, fileName, query, port) {
        const bgPath = vscode2.Uri.file(path.join(context.extensionPath, "images", "preview-bg.png"));
        const bgSrc = previewPanel.webview.asWebviewUri(bgPath);
        const url = `http://localhost:${port}/__preview${query}#${fileName}`;
        previewPanel.title = "Preview " + path.basename(fileName);
        previewPanel.webview.html = getWebviewContent(url, { port, fileName }, bgSrc.toString());
      }
      function getWebviewContent(url, state, bg) {
        const configs = vscode2.workspace.getConfiguration("volar");
        const autoBack = !vscode2.workspace.getConfiguration("volar").get("showWelcomePage");
        return `
			<style>
			body {
				padding: 0;
				background-color: ${configs.get("preview.backgroundColor")};
				${bg && configs.get("preview.transparentGrid") ? `background-image: url(${bg});` : ""}
			}
			</style>

			<script>
			const vscode = acquireVsCodeApi();
			vscode.setState(${JSON.stringify(state)});
			window.addEventListener('message', e => {
				if (e.data.sender === 'volar') {
					document.getElementById('preview').contentWindow.postMessage(e.data, '*');
				}
				else {
					vscode.postMessage(e.data);
				}
			});
			<\/script>

			<iframe id="preview" src="https://volar-authentication.herokuapp.com/?backUrl=${encodeURIComponent(url)}&autoBack=${autoBack}&lang=${vscode2.env.language}" frameborder="0" style="display: block; margin: 0px; overflow: hidden; width: 100%; height: 100vh;" />
		`;
      }
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/showReferences.js
var require_showReferences = __commonJS({
  "../../packages/client/out/features/showReferences.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      context.subscriptions.push(languageClient.onNotification(shared.ShowReferencesNotification.type, (handler) => {
        const uri = handler.textDocument.uri;
        const pos = handler.position;
        const refs = handler.references;
        vscode2.commands.executeCommand("editor.action.showReferences", vscode2.Uri.parse(uri), new vscode2.Position(pos.line, pos.character), refs.map((ref) => new vscode2.Location(vscode2.Uri.parse(ref.uri), new vscode2.Range(ref.range.start.line, ref.range.start.character, ref.range.end.line, ref.range.end.character))));
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/autoInsertion.js
var require_autoInsertion = __commonJS({
  "../../packages/client/out/features/autoInsertion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    async function activate2(context, htmlClient, tsClient) {
      await htmlClient.onReady();
      context.subscriptions.push(activateAutoInsertion((document, position) => {
        const params = htmlClient.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
        return htmlClient.sendRequest(shared.GetAutoQuoteEditsRequest.type, params);
      }, { vue: true }, "html.autoCreateQuotes", (lastChange, lastCharacter) => lastChange.rangeLength === 0 && lastCharacter === "="));
      context.subscriptions.push(activateAutoInsertion((document, position) => {
        const params = htmlClient.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
        return htmlClient.sendRequest(shared.GetTagCloseEditsRequest.type, params);
      }, { vue: true }, "html.autoClosingTags", (lastChange, lastCharacter) => lastChange.rangeLength === 0 && (lastCharacter === ">" || lastCharacter === "/")));
      context.subscriptions.push(activateAutoInsertion(async (document, position) => {
        const params = htmlClient.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
        const result = await htmlClient.sendRequest(shared.GetWrapParenthesesEditsRequest.type, params);
        if (result) {
          return {
            text: result.text,
            range: htmlClient.protocol2CodeConverter.asRange(result.range)
          };
        }
      }, { vue: true }, "volar.autoWrapParentheses", isCharacterTyping));
      context.subscriptions.push(activateAutoInsertion((document, position) => {
        const params = tsClient.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
        return tsClient.sendRequest(shared.GetRefCompleteEditsRequest.type, params);
      }, {
        vue: true,
        javascript: true,
        typescript: true,
        javascriptreact: true,
        typescriptreact: true
      }, "volar.autoCompleteRefs", isCharacterTyping));
      function isCharacterTyping(lastChange, lastCharacter, document) {
        const rangeStart = lastChange.range.start;
        const position = new vscode2.Position(rangeStart.line, rangeStart.character + lastChange.text.length);
        const nextCharacter = document.getText(new vscode2.Range(position, document.positionAt(document.offsetAt(position) + 1)));
        if (lastCharacter === void 0) {
          return false;
        }
        if (lastChange.text.indexOf("\n") >= 0) {
          return false;
        }
        return /\w/.test(lastCharacter) && !/\w/.test(nextCharacter);
      }
    }
    exports2.activate = activate2;
    function activateAutoInsertion(provider, supportedLanguages, configName, changeValid) {
      let disposables = [];
      vscode2.workspace.onDidChangeTextDocument(onDidChangeTextDocument, null, disposables);
      let isEnabled = false;
      updateEnabledState();
      vscode2.window.onDidChangeActiveTextEditor(updateEnabledState, null, disposables);
      let timeout;
      function updateEnabledState() {
        isEnabled = false;
        let editor = vscode2.window.activeTextEditor;
        if (!editor) {
          return;
        }
        let document = editor.document;
        if (!supportedLanguages[document.languageId]) {
          return;
        }
        if (!vscode2.workspace.getConfiguration(void 0, document.uri).get(configName, true)) {
          return;
        }
        isEnabled = true;
      }
      function onDidChangeTextDocument({ document, contentChanges, reason }) {
        var _a2;
        if (!isEnabled || contentChanges.length === 0 || reason === vscode2.TextDocumentChangeReason.Undo || reason === vscode2.TextDocumentChangeReason.Redo) {
          return;
        }
        const activeDocument = (_a2 = vscode2.window.activeTextEditor) === null || _a2 === void 0 ? void 0 : _a2.document;
        if (document !== activeDocument) {
          return;
        }
        if (timeout) {
          clearTimeout(timeout);
          timeout = void 0;
        }
        const lastChange = contentChanges[contentChanges.length - 1];
        const lastCharacter = lastChange.text[lastChange.text.length - 1];
        if (changeValid(lastChange, lastCharacter, document)) {
          doAutoInsert(document, lastChange);
        }
      }
      function doAutoInsert(document, lastChange) {
        const rangeStart = lastChange.range.start;
        const version = document.version;
        timeout = setTimeout(() => {
          const position = new vscode2.Position(rangeStart.line, rangeStart.character + lastChange.text.length);
          provider(document, position).then((text) => {
            if (text && isEnabled) {
              const activeEditor = vscode2.window.activeTextEditor;
              if (activeEditor) {
                const activeDocument = activeEditor.document;
                if (document === activeDocument && activeDocument.version === version) {
                  if (typeof text === "string") {
                    const selections = activeEditor.selections;
                    if (selections.length && selections.some((s) => s.active.isEqual(position))) {
                      activeEditor.insertSnippet(new vscode2.SnippetString(text), selections.map((s) => s.active));
                    } else {
                      activeEditor.insertSnippet(new vscode2.SnippetString(text), position);
                    }
                  } else {
                    activeEditor.insertSnippet(new vscode2.SnippetString(text.text), text.range);
                  }
                }
              }
            }
          });
          timeout = void 0;
        }, 100);
      }
      return vscode2.Disposable.from(...disposables);
    }
  }
});

// ../../packages/client/out/features/tagNameCase.js
var require_tagNameCase = __commonJS({
  "../../packages/client/out/features/tagNameCase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var splitEditors_1 = require_splitEditors();
    var vscode_languageclient_1 = require_main3();
    var shared = require_node4();
    async function activate2(context, languageClient) {
      var _a2;
      await languageClient.onReady();
      await languageClient.sendRequest(shared.InitDoneRequest.type);
      const tagCases = shared.createPathMap();
      const statusBar = vscode2.window.createStatusBarItem(vscode2.StatusBarAlignment.Right);
      statusBar.command = "volar.action.tagNameCase";
      onChangeDocument((_a2 = vscode2.window.activeTextEditor) === null || _a2 === void 0 ? void 0 : _a2.document);
      const d_1 = vscode2.window.onDidChangeActiveTextEditor((e) => {
        onChangeDocument(e === null || e === void 0 ? void 0 : e.document);
      });
      const d_2 = vscode2.workspace.onDidCloseTextDocument((doc) => {
        tagCases.uriDelete(doc.uri.toString());
      });
      const d_3 = vscode2.commands.registerCommand("volar.action.tagNameCase", async () => {
        var _a3;
        const crtDoc = (_a3 = vscode2.window.activeTextEditor) === null || _a3 === void 0 ? void 0 : _a3.document;
        if (!crtDoc)
          return;
        const tagCase = tagCases.uriGet(crtDoc.uri.toString());
        const options = {};
        options[0] = { label: (tagCase === "both" ? "\u2022 " : "") + "Component Using kebab-case and PascalCase (Both)" };
        options[1] = { label: (tagCase === "kebabCase" ? "\u2022 " : "") + "Component Using kebab-case" };
        options[2] = { label: (tagCase === "pascalCase" ? "\u2022 " : "") + "Component Using PascalCase" };
        options[3] = { label: "Detect Component name from Content" };
        options[7] = { label: "Convert Component name to kebab-case" };
        options[8] = { label: "Convert Component name to PascalCase" };
        const select = await (0, splitEditors_1.userPick)(options);
        if (select === void 0)
          return;
        if (select === "0") {
          tagCases.uriSet(crtDoc.uri.toString(), "both");
          updateStatusBarText("both");
        }
        if (select === "1") {
          tagCases.uriSet(crtDoc.uri.toString(), "kebabCase");
          updateStatusBarText("kebabCase");
        }
        if (select === "2") {
          tagCases.uriSet(crtDoc.uri.toString(), "pascalCase");
          updateStatusBarText("pascalCase");
        }
        if (select === "3") {
          const detects = await languageClient.sendRequest(shared.DetectDocumentNameCasesRequest.type, languageClient.code2ProtocolConverter.asTextDocumentIdentifier(crtDoc));
          if (detects) {
            tagCases.uriSet(crtDoc.uri.toString(), detects.tag);
            updateStatusBarText(detects.tag);
          }
        }
        if (select === "7") {
          vscode2.commands.executeCommand("volar.action.tagNameCase.convertToKebabCase");
        }
        if (select === "8") {
          vscode2.commands.executeCommand("volar.action.tagNameCase.convertToPascalCase");
        }
      });
      const d_4 = vscode2.commands.registerCommand("volar.action.tagNameCase.convertToKebabCase", async () => {
        if (vscode2.window.activeTextEditor) {
          await vscode2.commands.executeCommand("volar.server.executeConvertToKebabCase", vscode2.window.activeTextEditor.document.uri.toString());
          tagCases.uriSet(vscode2.window.activeTextEditor.document.uri.toString(), "kebabCase");
          updateStatusBarText("kebabCase");
        }
      });
      const d_5 = vscode2.commands.registerCommand("volar.action.tagNameCase.convertToPascalCase", async () => {
        if (vscode2.window.activeTextEditor) {
          await vscode2.commands.executeCommand("volar.server.executeConvertToPascalCase", vscode2.window.activeTextEditor.document.uri.toString());
          tagCases.uriSet(vscode2.window.activeTextEditor.document.uri.toString(), "pascalCase");
          updateStatusBarText("pascalCase");
        }
      });
      languageClient.onDidChangeState((e) => {
        if (e.newState === vscode_languageclient_1.State.Stopped) {
          d_1.dispose();
          d_2.dispose();
          d_3.dispose();
          d_4.dispose();
          d_5.dispose();
          statusBar.dispose();
        }
      });
      return (uri) => {
        var _a3;
        let tagCase = tagCases.uriGet(uri);
        if (uri.toLowerCase() === ((_a3 = vscode2.window.activeTextEditor) === null || _a3 === void 0 ? void 0 : _a3.document.uri.toString().toLowerCase())) {
          updateStatusBarText(tagCase);
        }
        return !tagCase || tagCase === "unsure" ? "both" : tagCase;
      };
      async function onChangeDocument(newDoc) {
        if ((newDoc === null || newDoc === void 0 ? void 0 : newDoc.languageId) === "vue") {
          let tagCase = tagCases.uriGet(newDoc.uri.toString());
          if (!tagCase) {
            const tagMode = vscode2.workspace.getConfiguration("volar").get("completion.preferredTagNameCase");
            if (tagMode === "both") {
              tagCase = "both";
            } else if (tagMode === "kebab") {
              tagCase = "kebabCase";
            } else if (tagMode === "pascal") {
              tagCase = "pascalCase";
            } else {
              const templateCases = await languageClient.sendRequest(shared.DetectDocumentNameCasesRequest.type, languageClient.code2ProtocolConverter.asTextDocumentIdentifier(newDoc));
              tagCase = templateCases === null || templateCases === void 0 ? void 0 : templateCases.tag;
            }
          }
          if (tagCase) {
            tagCases.uriSet(newDoc.uri.toString(), tagCase);
          }
          updateStatusBarText(tagCase);
          statusBar.show();
        } else {
          statusBar.hide();
        }
      }
      function updateStatusBarText(tagCase) {
        let text = `Tag: `;
        if (tagCase === "unsure" || tagCase === void 0) {
          text += `UNSURE`;
        } else if (tagCase === "both") {
          text += `BOTH`;
        } else if (tagCase === "kebabCase") {
          text += `kebab-case`;
        } else if (tagCase === "pascalCase") {
          text += `PascalCase`;
        }
        statusBar.text = text;
      }
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/tsVersion.js
var require_tsVersion = __commonJS({
  "../../packages/client/out/features/tsVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCurrentTsPaths = exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    var splitEditors_1 = require_splitEditors();
    var defaultTsdk = "node_modules/typescript/lib";
    async function activate2(context, clients) {
      const statusBar = vscode2.window.createStatusBarItem(vscode2.StatusBarAlignment.Right);
      statusBar.command = "volar.selectTypeScriptVersion";
      const subscription = vscode2.commands.registerCommand("volar.selectTypeScriptVersion", async () => {
        var _a2;
        const useWorkspaceTsdk = getCurrentTsPaths(context).isWorkspacePath;
        const workspaceTsPaths = getWorkspaceTsPaths();
        const workspaceTsVersion = workspaceTsPaths ? shared.getTypeScriptVersion(workspaceTsPaths.serverPath) : void 0;
        const vscodeTsPaths = getVscodeTsPaths();
        const vscodeTsVersion = shared.getTypeScriptVersion(vscodeTsPaths.serverPath);
        const tsdk2 = getTsdk();
        const defaultTsServer = shared.getWorkspaceTypescriptPath(defaultTsdk, ((_a2 = vscode2.workspace.workspaceFolders) !== null && _a2 !== void 0 ? _a2 : []).map((folder) => folder.uri.fsPath));
        const defaultTsVersion = defaultTsServer ? shared.getTypeScriptVersion(defaultTsServer) : void 0;
        const options = {};
        options[0] = {
          label: (!useWorkspaceTsdk ? "\u2022 " : "") + "Use VS Code's Version",
          description: vscodeTsVersion
        };
        if (tsdk2) {
          options[1] = {
            label: (useWorkspaceTsdk ? "\u2022 " : "") + "Use Workspace Version",
            description: workspaceTsVersion !== null && workspaceTsVersion !== void 0 ? workspaceTsVersion : "Could not load the TypeScript version at this path",
            detail: tsdk2
          };
        }
        if (tsdk2 !== defaultTsdk) {
          options[2] = {
            label: (useWorkspaceTsdk ? "\u2022 " : "") + "Use Workspace Version",
            description: defaultTsVersion !== null && defaultTsVersion !== void 0 ? defaultTsVersion : "Could not load the TypeScript version at this path",
            detail: defaultTsdk
          };
        }
        const select = await (0, splitEditors_1.userPick)(options);
        if (select === void 0)
          return;
        if (select === "2") {
          vscode2.workspace.getConfiguration("typescript").update("tsdk", defaultTsdk);
        }
        const nowUseWorkspaceTsdk = select !== "0";
        if (nowUseWorkspaceTsdk !== isUseWorkspaceTsdk(context)) {
          context.workspaceState.update("typescript.useWorkspaceTsdk", nowUseWorkspaceTsdk);
          reloadServers();
        }
        updateStatusBar();
      });
      context.subscriptions.push(subscription);
      let tsdk = getTsdk();
      vscode2.workspace.onDidChangeConfiguration(() => {
        const newTsdk = getTsdk();
        if (newTsdk !== tsdk) {
          tsdk = newTsdk;
          if (isUseWorkspaceTsdk(context)) {
            reloadServers();
          }
        }
      });
      updateStatusBar();
      vscode2.window.onDidChangeActiveTextEditor(updateStatusBar, void 0, context.subscriptions);
      function updateStatusBar() {
        var _a2;
        if (((_a2 = vscode2.window.activeTextEditor) === null || _a2 === void 0 ? void 0 : _a2.document.languageId) !== "vue") {
          statusBar.hide();
        } else {
          const tsPaths = getCurrentTsPaths(context);
          const tsVersion = shared.getTypeScriptVersion(tsPaths.serverPath);
          statusBar.text = "TS " + tsVersion;
          statusBar.show();
        }
      }
      async function reloadServers() {
        const tsPaths = getCurrentTsPaths(context);
        for (const client of clients) {
          const newInitOptions = {
            ...client.clientOptions.initializationOptions,
            typescript: tsPaths
          };
          client.clientOptions.initializationOptions = newInitOptions;
        }
        vscode2.commands.executeCommand("volar.action.restartServer");
      }
    }
    exports2.activate = activate2;
    function getCurrentTsPaths(context) {
      if (isUseWorkspaceTsdk(context)) {
        const workspaceTsPaths = getWorkspaceTsPaths(true);
        if (workspaceTsPaths) {
          return { ...workspaceTsPaths, isWorkspacePath: true };
        }
      }
      return { ...getVscodeTsPaths(), isWorkspacePath: false };
    }
    exports2.getCurrentTsPaths = getCurrentTsPaths;
    function getWorkspaceTsPaths(useDefault = false) {
      var _a2;
      let tsdk = getTsdk();
      if (!tsdk && useDefault) {
        tsdk = defaultTsdk;
      }
      if (tsdk) {
        const fsPaths = ((_a2 = vscode2.workspace.workspaceFolders) !== null && _a2 !== void 0 ? _a2 : []).map((folder) => folder.uri.fsPath);
        const tsPath = shared.getWorkspaceTypescriptPath(tsdk, fsPaths);
        if (tsPath) {
          return {
            serverPath: tsPath,
            localizedPath: shared.getWorkspaceTypescriptLocalizedPath(tsdk, vscode2.env.language, fsPaths)
          };
        }
      }
    }
    function getVscodeTsPaths() {
      return {
        serverPath: shared.getVscodeTypescriptPath(vscode2.env.appRoot),
        localizedPath: shared.getVscodeTypescriptLocalizedPath(vscode2.env.appRoot, vscode2.env.language)
      };
    }
    function getTsdk() {
      const tsConfigs = vscode2.workspace.getConfiguration("typescript");
      const tsdk = tsConfigs.get("tsdk");
      return tsdk;
    }
    function isUseWorkspaceTsdk(context) {
      return context.workspaceState.get("typescript.useWorkspaceTsdk", false);
    }
  }
});

// ../../packages/client/out/features/verifyAll.js
var require_verifyAll = __commonJS({
  "../../packages/client/out/features/verifyAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      context.subscriptions.push(vscode2.commands.registerCommand("volar.action.verifyAllScripts", () => {
        languageClient.sendNotification(shared.VerifyAllScriptsNotification.type);
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/virtualFiles.js
var require_virtualFiles = __commonJS({
  "../../packages/client/out/features/virtualFiles.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      context.subscriptions.push(vscode2.commands.registerCommand("volar.action.writeTemplateLsVirtualFiles", () => {
        languageClient.sendNotification(shared.WriteVirtualFilesNotification.type, { lsType: "template" });
      }));
      context.subscriptions.push(vscode2.commands.registerCommand("volar.action.writeScriptLsVirtualFiles", () => {
        languageClient.sendNotification(shared.WriteVirtualFilesNotification.type, { lsType: "script" });
      }));
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/features/tsconfig.js
var require_tsconfig = __commonJS({
  "../../packages/client/out/features/tsconfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.activate = void 0;
    var vscode2 = require("vscode");
    var shared = require_node4();
    var path = require_upath();
    async function activate2(context, languageClient) {
      await languageClient.onReady();
      await languageClient.sendRequest(shared.InitDoneRequest.type);
      const statusBar = vscode2.window.createStatusBarItem(vscode2.StatusBarAlignment.Right);
      let currentTsconfig = "";
      updateStatusBar();
      vscode2.window.onDidChangeActiveTextEditor(updateStatusBar, void 0, context.subscriptions);
      vscode2.commands.registerCommand("volar.openTsconfig", async () => {
        const document = await vscode2.workspace.openTextDocument(currentTsconfig);
        await vscode2.window.showTextDocument(document);
      });
      async function updateStatusBar() {
        var _a2;
        if (((_a2 = vscode2.window.activeTextEditor) === null || _a2 === void 0 ? void 0 : _a2.document.languageId) !== "vue") {
          statusBar.hide();
        } else {
          const tsconfig = await languageClient.sendRequest(shared.GetMatchTsConfigRequest.type, languageClient.code2ProtocolConverter.asTextDocumentIdentifier(vscode2.window.activeTextEditor.document));
          if (tsconfig) {
            statusBar.text = path.relative(vscode2.workspace.rootPath, tsconfig);
            statusBar.command = "volar.openTsconfig";
            currentTsconfig = tsconfig;
          } else {
            statusBar.text = "No tsconfig";
            statusBar.command = void 0;
          }
          statusBar.show();
        }
      }
    }
    exports2.activate = activate2;
  }
});

// ../../packages/client/out/common.js
var require_common3 = __commonJS({
  "../../packages/client/out/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeOverModeEnabled = exports2.deactivate = exports2.activate = void 0;
    var shared = require_node4();
    var vscode2 = require("vscode");
    var activeSelection = require_activeSelection();
    var attrNameCase = require_attrNameCase();
    var callGraph = require_callGraph();
    var createWorkspaceSnippets = require_createWorkspaceSnippets();
    var documentVersion = require_documentVersion();
    var documentContent = require_documentContent();
    var documentPrintWidth = require_documentPrintWidth();
    var preview = require_preview();
    var showReferences = require_showReferences();
    var splitEditors = require_splitEditors();
    var autoInsertion = require_autoInsertion();
    var tagNameCase = require_tagNameCase();
    var tsVersion = require_tsVersion();
    var verifyAll = require_verifyAll();
    var virtualFiles = require_virtualFiles();
    var tsconfig = require_tsconfig();
    var apiClient;
    var docClient;
    var htmlClient;
    async function activate2(context, createLc) {
      const stopCheck = vscode2.window.onDidChangeActiveTextEditor(tryActivate);
      tryActivate();
      function tryActivate() {
        if (!vscode2.window.activeTextEditor) {
          doActivate(context, createLc);
          stopCheck.dispose();
          return;
        }
        const currentlangId = vscode2.window.activeTextEditor.document.languageId;
        if (currentlangId === "vue") {
          doActivate(context, createLc);
          stopCheck.dispose();
        }
        const takeOverMode = takeOverModeEnabled();
        if (takeOverMode && ["javascript", "typescript", "javascriptreact", "typescriptreact"].includes(currentlangId)) {
          doActivate(context, createLc);
          stopCheck.dispose();
        }
      }
    }
    exports2.activate = activate2;
    async function doActivate(context, createLc) {
      vscode2.commands.executeCommand("setContext", "volar.activated", true);
      const lowPowerMode = lowPowerModeEnabled();
      if (lowPowerMode) {
        vscode2.window.showInformationMessage("Low Power Mode Enabled.", "Disable").then((option) => {
          if (option !== void 0) {
            vscode2.commands.executeCommand("workbench.action.openSettings", "volar.lowPowerMode");
          }
        });
      }
      const takeOverMode = takeOverModeEnabled();
      if (takeOverMode) {
        vscode2.window.showInformationMessage("Take Over Mode enabled.", "What is Take Over Mode?").then((option) => {
          if (option !== void 0) {
            vscode2.env.openExternal(vscode2.Uri.parse("https://github.com/johnsoncodehk/volar/discussions/471"));
          }
        });
      }
      const languageFeaturesDocumentSelector = takeOverMode ? [
        { scheme: "file", language: "vue" },
        { scheme: "file", language: "javascript" },
        { scheme: "file", language: "typescript" },
        { scheme: "file", language: "javascriptreact" },
        { scheme: "file", language: "typescriptreact" },
        { scheme: "file", language: "json" }
      ] : [
        { scheme: "file", language: "vue" }
      ];
      const documentFeaturesDocumentSelector = takeOverMode ? [
        { language: "vue" },
        { language: "javascript" },
        { language: "typescript" },
        { language: "javascriptreact" },
        { language: "typescriptreact" }
      ] : [
        { language: "vue" }
      ];
      apiClient = createLc("volar-api", "Volar - API", languageFeaturesDocumentSelector, getInitializationOptions(context, "api", void 0, lowPowerMode), 6009);
      docClient = !lowPowerMode ? createLc("volar-document", "Volar - Document", languageFeaturesDocumentSelector, getInitializationOptions(context, "doc", void 0, lowPowerMode), 6010) : void 0;
      htmlClient = createLc("volar-html", "Volar - HTML", documentFeaturesDocumentSelector, getInitializationOptions(context, "html", void 0, lowPowerMode), 6011);
      const clients = [apiClient, docClient, htmlClient].filter(shared.notEmpty);
      registarLowPowerModeChange();
      registarRestartRequest();
      registarClientRequests();
      splitEditors.activate(context);
      preview.activate(context);
      createWorkspaceSnippets.activate(context);
      callGraph.activate(context, apiClient);
      verifyAll.activate(context, docClient !== null && docClient !== void 0 ? docClient : apiClient);
      virtualFiles.activate(context, docClient !== null && docClient !== void 0 ? docClient : apiClient);
      autoInsertion.activate(context, htmlClient, apiClient);
      tsVersion.activate(context, [apiClient, docClient].filter(shared.notEmpty));
      tsconfig.activate(context, docClient !== null && docClient !== void 0 ? docClient : apiClient);
      async function registarLowPowerModeChange() {
        vscode2.workspace.onDidChangeConfiguration(async () => {
          const nowIsLowPowerMode = lowPowerModeEnabled();
          if (lowPowerMode !== nowIsLowPowerMode) {
            const reload = await vscode2.window.showInformationMessage("Please reload VSCode to switch low power mode.", "Reload Window");
            if (reload === void 0)
              return;
            vscode2.commands.executeCommand("workbench.action.reloadWindow");
          }
        });
      }
      async function registarRestartRequest() {
        await Promise.all(clients.map((client) => client.onReady()));
        context.subscriptions.push(vscode2.commands.registerCommand("volar.action.restartServer", async () => {
          await Promise.all(clients.map((client) => client.stop()));
          await Promise.all(clients.map((client) => client.start()));
          registarClientRequests();
        }));
      }
      function registarClientRequests() {
        for (const client of clients) {
          showReferences.activate(context, client);
          documentVersion.activate(context, client);
          documentContent.activate(context, client);
          documentPrintWidth.activate(context, client);
          activeSelection.activate(context, client);
        }
        (async () => {
          const getTagNameCase = await tagNameCase.activate(context, apiClient);
          const getAttrNameCase = await attrNameCase.activate(context, apiClient);
          apiClient.onRequest(shared.GetDocumentNameCasesRequest.type, async (handler) => ({
            tagNameCase: getTagNameCase(handler.uri),
            attrNameCase: getAttrNameCase(handler.uri)
          }));
        })();
      }
    }
    function deactivate2() {
      return Promise.all([
        apiClient === null || apiClient === void 0 ? void 0 : apiClient.stop(),
        docClient === null || docClient === void 0 ? void 0 : docClient.stop(),
        htmlClient === null || htmlClient === void 0 ? void 0 : htmlClient.stop()
      ].filter(shared.notEmpty));
    }
    exports2.deactivate = deactivate2;
    function takeOverModeEnabled() {
      const status = vscode2.workspace.getConfiguration("volar").get("takeOverMode.enabled");
      if (status === "auto") {
        return !vscode2.extensions.getExtension("vscode.typescript-language-features");
      }
      return status;
    }
    exports2.takeOverModeEnabled = takeOverModeEnabled;
    function lowPowerModeEnabled() {
      return !!vscode2.workspace.getConfiguration("volar").get("lowPowerMode");
    }
    function getInitializationOptions(context, mode, initMessage, lowPowerMode) {
      const initializationOptions = {
        typescript: tsVersion.getCurrentTsPaths(context),
        languageFeatures: mode === "api" || mode === "doc" ? {
          ...mode === "api" ? {
            references: true,
            definition: true,
            typeDefinition: true,
            callHierarchy: true,
            hover: true,
            rename: true,
            renameFileRefactoring: true,
            signatureHelp: true,
            codeAction: true,
            workspaceSymbol: true,
            completion: {
              defaultTagNameCase: "both",
              defaultAttrNameCase: "kebabCase",
              getDocumentNameCasesRequest: true,
              getDocumentSelectionRequest: true
            },
            schemaRequestService: { getDocumentContentRequest: true }
          } : {},
          ...mode === "doc" || mode === "api" && lowPowerMode ? {
            documentHighlight: true,
            documentLink: true,
            codeLens: { showReferencesNotification: true },
            semanticTokens: true,
            diagnostics: { getDocumentVersionRequest: true },
            schemaRequestService: { getDocumentContentRequest: true }
          } : {}
        } : void 0,
        documentFeatures: mode === "html" ? {
          selectionRange: true,
          foldingRange: true,
          linkedEditingRange: true,
          documentSymbol: true,
          documentColor: true,
          documentFormatting: {
            defaultPrintWidth: 100,
            getDocumentPrintWidthRequest: true
          }
        } : void 0,
        initializationMessage: initMessage
      };
      return initializationOptions;
    }
  }
});

// ../../packages/client/out/nodeClientMain.js
Object.defineProperty(exports, "__esModule", { value: true });
exports.deactivate = exports.activate = void 0;
var vscode = require("vscode");
var lsp = require_node3();
var common_1 = require_common3();
function activate(context) {
  return (0, common_1.activate)(context, (id, name, documentSelector, initOptions, port) => {
    const serverModule = vscode.Uri.joinPath(context.extensionUri, "out", "node", "server");
    const debugOptions = { execArgv: ["--nolazy", "--inspect=" + port] };
    const serverOptions = {
      run: { module: serverModule.fsPath, transport: lsp.TransportKind.ipc },
      debug: {
        module: serverModule.fsPath,
        transport: lsp.TransportKind.ipc,
        options: debugOptions
      }
    };
    const clientOptions = {
      documentSelector,
      initializationOptions: initOptions,
      synchronize: {
        fileEvents: vscode.workspace.createFileSystemWatcher("{**/*.vue,**/*.js,**/*.jsx,**/*.ts,**/*.tsx,**/*.json}")
      }
    };
    const client = new lsp.LanguageClient(id, name, serverOptions, clientOptions);
    context.subscriptions.push(client.start());
    return client;
  });
}
exports.activate = activate;
function deactivate() {
  return (0, common_1.deactivate)();
}
exports.deactivate = deactivate;
